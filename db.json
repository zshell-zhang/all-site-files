{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514465959000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514465959000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514465959000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514465959000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514465959000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514465959000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514465959000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514465959000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514465959000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514465959000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514465959000},{"_id":"themes/next/README.md","hash":"aa2fb15ef016074b10755323c99025df506d5ca3","modified":1514465959000},{"_id":"themes/next/_config.yml","hash":"295bea5403bc000e935e0b8b858537a272418441","modified":1515247713225},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1514465959000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514465959000},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1514465959000},{"_id":"source/_posts/linux-conf--ulimit调参与优化.md","hash":"09596099c95cc180bddb2198deb922b67c9766ad","modified":1515425661501},{"_id":"source/_posts/linux-other--cli控制字符.md","hash":"d7141a567e9c505e7f0ee4147ea7e3020fa9549d","modified":1515330801678},{"_id":"source/_posts/linux-other--du,df使用及其区别.md","hash":"17f4ad568da5d1af55d4f8382d1d20bb287d6cc8","modified":1515337571325},{"_id":"source/_posts/linux-other--lsof札记.md","hash":"633106ef2122fb7e0f444aaf0560b8a80d5a3fcb","modified":1515337624349},{"_id":"source/_posts/linux-process--linux_signals总体认识.md","hash":"bd691fb2a14066a55c0118d891a6f1799ef53677","modified":1515166203954},{"_id":"source/_posts/linux-shell--bash数组与映射.md","hash":"06daf749bafbff6851b24ceaca542243c22706ed","modified":1514992691226},{"_id":"source/_posts/linux-shell--bash条件判断全梳理.md","hash":"684a8bade06fd83db7344ee3f4e7e53b4dca8462","modified":1514907657771},{"_id":"source/_posts/linux-shell--bash结束死循环的方法.md","hash":"0387df780421ea28436ae0f1284da10d37c57258","modified":1514907681515},{"_id":"source/_posts/linux-text-sed命令整理.md","hash":"e08002174fcd8da5f0fbb7142a5f43e78a54eb43","modified":1515077927480},{"_id":"source/_posts/rsync--rsyncd配置与运行.md","hash":"0a27d43072f0921fda19f4d2729a69b76864a913","modified":1514995235882},{"_id":"source/_posts/tools-git--git忽略文件的特殊场景.md","hash":"3c8710f2dd4360ae93e4ce401234cd170eb6c13e","modified":1515828000322},{"_id":"source/_posts/tools-maven--assembly_plugin.md","hash":"e398399521e21fdd2b09ccc8abdb17a2448a931e","modified":1515512786692},{"_id":"source/_posts/证券-财富先锋--财富先锋2017年各股池成绩单.md","hash":"98a87185460a0bb421e1b4e2d9f73c727a1fdcd0","modified":1514909264593},{"_id":"source/about/index.md","hash":"b90e5fe9a9d5354c678f308562811f9fdebad3c3","modified":1515769580284},{"_id":"source/categories/index.md","hash":"9059810d4bea597318151a26b6702190e4695d89","modified":1514815093229},{"_id":"source/tags/index.md","hash":"64622508336303bc387a88d93daba8bc1ed5cf0b","modified":1514815145493},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514465959000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514465959000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514465959000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514465959000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514465959000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514465959000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514465959000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514465959000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514465959000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514465959000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514465959000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514465959000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514465959000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514465959000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514465959000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514465959000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514465959000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"c90ce83b39b879871e4594bb3f6c220f9a0466d0","modified":1515234943587},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514465959000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514465959000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514465959000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514465959000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514465959000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514465959000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514465959000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514465959000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514465959000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514465959000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1514465959000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514465959000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514465959000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514465959000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514465959000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514465959000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514465959000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514465959000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514465959000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514465959000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514465959000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1514465959000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514465959000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514465959000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514465959000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514465959000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514465959000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514465959000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514465959000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514465959000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514465959000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514465959000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514465959000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514465959000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514465959000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514465959000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514465959000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514465959000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514465959000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514465959000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514465959000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514465959000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514465959000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514465959000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514465959000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514465959000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514465959000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514465959000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514465959000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514465959000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514465959000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514465959000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514465959000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514465959000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514465959000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514465959000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514465959000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514465959000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514465959000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514465959000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514465959000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514465959000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514465959000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514465959000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514465959000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514465959000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514465959000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514465959000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514465959000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514465959000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514465959000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514465959000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514465959000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514465959000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514465959000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514465959000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514465959000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514465959000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514465959000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514465959000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514465959000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514465959000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514465959000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514465959000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514465959000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514465959000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514465959000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"f8bdac67c97c6c7f880288801069da8ae5bb6993","modified":1515237180777},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514465959000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514465959000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514465959000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514465959000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514465959000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514465959000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1515250373875},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514465959000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514465959000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514465959000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514465959000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514465959000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514465959000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514465959000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514465959000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514465959000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514465959000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514465959000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514465959000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514465959000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514465959000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514465959000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514465959000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514465959000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514465959000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514465959000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514465959000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514465959000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514465959000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514465959000},{"_id":"themes/next/source/images/background.jpg","hash":"c2a98968d9dad8a0747f193bc86e0c77cb84e08f","modified":1515245301060},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514465959000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514465959000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514465959000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514465959000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514465959000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514465959000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514465959000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514465959000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514465959000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"058a7a29431b9c7ee72da529d8ed24fbb03f1946","modified":1515250321588},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"54aa9c0ff7b1b6828b5c1341c45ed60bf04d4dce","modified":1515251282237},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5f724d5f4bf855a6a92fc763b837333e6e974033","modified":1515251190517},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514465959000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514465959000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514465959000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514465959000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514465959000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514465959000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514465959000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514465959000}],"Category":[{"name":"linux","_id":"cjcd0cb100004fejxklbpae5d"},{"name":"other","parent":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb1r000jfejxlnrk5gk4"},{"name":"conf","parent":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb1z000ofejxs5vl490r"},{"name":"process","parent":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb25000tfejxmx7rjsju"},{"name":"shell","parent":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb26000zfejxw07zqtv5"},{"name":"text","parent":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2f001nfejx408wy4bz"},{"name":"rsync","_id":"cjcd0cb2g001tfejx9j6i6hwp"},{"name":"tools","_id":"cjcd0cb2j001yfejxs6ln8ri8"},{"name":"证券","_id":"cjcd0cb2k0025fejxa1y7h7r8"},{"name":"git","parent":"cjcd0cb2j001yfejxs6ln8ri8","_id":"cjcd0cb2k0026fejxxp7q7yeq"},{"name":"maven","parent":"cjcd0cb2j001yfejxs6ln8ri8","_id":"cjcd0cb2l0027fejxrfo3gam9"},{"name":"财富先锋","parent":"cjcd0cb2k0025fejxa1y7h7r8","_id":"cjcd0cb2l0029fejxh0c7q2uo"}],"Data":[],"Page":[{"title":"about me","date":"2016-07-05T07:21:04.000Z","_content":"\n> 我坠入了一个全栈式陷阱: 在T型技术理论的指导下, 不断在那一条横上筑底, 然未能找到合适的支点累起那一道竖;\n时不我待, 毕竟技术不是股市, 横有多长, 竖未必有多高;\n\n## 联系方式\n\n**微信** : &nbsp;XaaService\n\n**手机** : 18513585440\n\n**邮箱** : zshell.zhang@qunar.com  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com\n\n## 职业状态\n\n2016 年 6 月毕业;\n2016.7 - 至今: 去哪儿网 dev;\n","source":"about/index.md","raw":"---\ntitle: about me\ndate: 2016-07-05 15:21:04\n---\n\n> 我坠入了一个全栈式陷阱: 在T型技术理论的指导下, 不断在那一条横上筑底, 然未能找到合适的支点累起那一道竖;\n时不我待, 毕竟技术不是股市, 横有多长, 竖未必有多高;\n\n## 联系方式\n\n**微信** : &nbsp;XaaService\n\n**手机** : 18513585440\n\n**邮箱** : zshell.zhang@qunar.com  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com\n\n## 职业状态\n\n2016 年 6 月毕业;\n2016.7 - 至今: 去哪儿网 dev;\n","updated":"2018-01-12T15:06:20.284Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjcd0cb0p0001fejx9af8ly8v","content":"<blockquote>\n<p>我坠入了一个全栈式陷阱: 在T型技术理论的指导下, 不断在那一条横上筑底, 然未能找到合适的支点累起那一道竖;<br>时不我待, 毕竟技术不是股市, 横有多长, 竖未必有多高;</p>\n</blockquote>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p><strong>微信</strong> : &nbsp;XaaService</p>\n<p><strong>手机</strong> : 18513585440</p>\n<p><strong>邮箱</strong> : zshell.zhang@qunar.com<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com</p>\n<h2 id=\"职业状态\"><a href=\"#职业状态\" class=\"headerlink\" title=\"职业状态\"></a>职业状态</h2><p>2016 年 6 月毕业;<br>2016.7 - 至今: 去哪儿网 dev;</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我坠入了一个全栈式陷阱: 在T型技术理论的指导下, 不断在那一条横上筑底, 然未能找到合适的支点累起那一道竖;<br>时不我待, 毕竟技术不是股市, 横有多长, 竖未必有多高;</p>\n</blockquote>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p><strong>微信</strong> : &nbsp;XaaService</p>\n<p><strong>手机</strong> : 18513585440</p>\n<p><strong>邮箱</strong> : zshell.zhang@qunar.com<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com</p>\n<h2 id=\"职业状态\"><a href=\"#职业状态\" class=\"headerlink\" title=\"职业状态\"></a>职业状态</h2><p>2016 年 6 月毕业;<br>2016.7 - 至今: 去哪儿网 dev;</p>\n"},{"title":"categories","date":"2016-08-01T11:40:08.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-01 19:40:08\ntype: \"categories\"\n---\n\n","updated":"2018-01-01T13:58:13.229Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjcd0cb0z0003fejxsidq25gi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-07-05T13:58:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-05 21:58:26\ntype: \"tags\"\n---\n","updated":"2018-01-01T13:59:05.493Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjcd0cb77002ffejxw0xhmdx7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ulimit 调参与优化","date":"2017-10-28T15:23:05.000Z","_content":"\n> ulimit 未正确设置是很多线上故障的根源: \n`Too many open files`;\n`java.lang.OutOfMemoryError: unable to create new native thread`;\n对于生产环境来说, ulimit 的调参优化至关重要;\n本文详细介绍并梳理一下与 ulimit 相关的林林总总;\n\n<!--more-->\n\n------\n\nulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;\n注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;\n在 `/etc/security/limits.conf` 文件中的第一段注释如下:\n> This file sets the resource limits for the users logged in via PAM.\nIt does not affect resource limits of the system services.\n\n关于 linux PAM 相关的内容, 可以前往另外一篇文章: [pam 认证与配置]();\n\n## **ulimit 基本信息**\n``` bash\n# 查看所有 ulimit 设置\n> ulimit -a\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 15018\nmax locked memory       (kbytes, -l) 64             # 每个进程可以锁住而不被 swap 出去的内存\nmax memory size         (kbytes, -m) unlimited      # 每个进程可使用的最大内存大小\nopen files                      (-n) 1024           # 每个进程可打开的文件数\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192           # 每个进程可使用的最大堆栈大小\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 4096           # 每个用户的最大进程数\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n## **ulimit 需要优化的场景及待优化参数**\nlinux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;\n### **场景1: tomcat web 容器 **\n一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;\n如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;\n所以, 可以对该机器的 ulimit 作出如下调整:\n``` bash\n1. max memory size -> unlimit\n2. open files -> 65536\n3. stack size -> unlimit\n```\n另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 `java.lang.OutOfMemoryError: unable to create new native thread` 的异常;\n最后确定问题的原因是 `ulimit -u` max user processes 的数量配置过低, 增大后解决问题:\n``` bash\n4. max user processes -> 65535\n```\n具体的情况可以参见这篇文章: [dubbo 服务治理框架设计]();\n\n### **场景2: elasticsearch data node**\n32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: '-Xmx30g -Xms30g', 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;\n所以, 可以对该机器的 ulimit 作出如下调整:\n```\n1. max locked memory -> unlimit\n2. max memory size -> unlimit\n3. open files -> 65536\n4. stack size -> unlimit\n```\n当然, 对于 max locked memory, elasticsearch.yml 本身有一个配置项 bootstrap.mlockall/bootstrap.memory_lock, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的;\n&nbsp;\n另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;\n以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;\n\n## **ulimit 当前 session 下的临时修改**\nulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;\n其调整方法也已经在 `ulimit -a` 中被注明了:\n```\n# max locked mem\nulimit -l unlimit\n# max mem size\nulimit -m unlimit\n# open files\nulimit -n 65536\n# max user processes\nulimit -u 65536\n...\n```\n\n## **ulimit 的永久修改**\n上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:\n\n1. `/etc/security/limits.conf`;\n2. `/etc/security/limits.d 目录`;\n\n这些文件用于持久化每个用户的资源限制设置;\n其中, `/etc/security/limits.conf` 自不必说, 这是配置 ulimit 的主要文件:\n``` bash\ndomain  限制的目标:\n        username    用户名;\n        @groupname  组名, 需加 '@' 前缀;\n        *           通配所有用户/组;\n        %groupname  这种写法只能用于限制 某个 group 的 maxlogin limit, 即最大登陆用户数限制;\n        \ntype    限制的属性:\n        `soft` 对 domain 给出的用户设置默认值; \n        `hard` 限制 domain 给出的用户自己所能设置的最大值; \n        `-` 将 soft 与 hard 都设为相同的值;\n        \nitem    限制的资源类型, 与 ulimit 所限制的资源类型大致相同:\n        - core - limits the core file size (KB)\n        - data - max data size (KB)\n        - fsize - maximum filesize (KB)\n        - memlock - max locked-in-memory address space (KB)\n        - nofile - max number of open file descriptors\n        - rss - max resident set size (KB)\n        - stack - max stack size (KB)\n        - cpu - max CPU time (MIN)\n        - nproc - max number of processes\n        - as - address space limit (KB)\n        - maxlogins - max number of logins for this user\n        - maxsyslogins - max number of logins on the system\n        - priority - the priority to run user process with\n        - locks - max number of file locks the user can hold\n        - sigpending - max number of pending signals\n        - msgqueue - max memory used by POSIX message queues (bytes)\n        - nice - max nice priority allowed to raise to values: [-20, 19]\n        - rtprio - max realtime priority\n\nvalue   限制的具体值;\n```\n以下是一个具体的例子:\n``` bash\n#<domain>        <type>     <item>     <value>\n*                 soft      nproc       65536\n*                 hard      nproc       65536\n*                 -         nofile      65536\n%guest            -         maxlogins   10\nelastic           -         memlock     unlimit\n@dev              hard      fsize       10737418240\n```\n&nbsp;\n而对于 `/etc/security/limits.d` 目录的作用,  `/etc/security/limits.conf` 文件中的第二段与第三段有如下注释:\n\n> Also note that configuration files in /etc/security/limits.d directory,\nwhich are read in alphabetical order, override the settings in this\nfile in case the domain is the same or more specific.\n&nbsp;\nThat means for example that setting a limit for wildcard domain here\ncan be overriden with a wildcard setting in a config file in the\nsubdirectory, but a user specific setting here can be overriden only\nwith a user specific setting in the subdirectory.\n\n也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;\n举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 `20-nproc.conf`:\n``` bash\n# Default limit for number of user's processes to prevent\n# accidental fork bombs.\n# See rhbz #432903 for reasoning.\n*          soft    nproc     4096\nroot       soft    nproc     unlimited\n```\n这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;\n如果修改 limits.conf 文件:\n``` bash\n*          hard    nproc     65535\n```\n这时会发现, 除非自己试图 `ulimit -u` 修改 max processes, 否则这个值会依然被限制为 4096;\n而要想将该值默认放到 65535, 就必须修改 `20-nproc.conf` 文件方才生效;\n\n### **永久修改生效的必要条件**\n\n## **参考链接**\n- [ulimit 命令详解](http://www.cnblogs.com/zengkefu/p/5649407.html)\n- [linux /etc/security/limits.conf的相关说明](http://blog.csdn.net/taijianyu/article/details/5976319)\n\n","source":"_posts/linux-conf--ulimit调参与优化.md","raw":"---\ntitle: ulimit 调参与优化\ndate: 2017-10-28 23:23:05\ncategories:\n - linux\n - conf\ntags:\n - linux:conf\n---\n\n> ulimit 未正确设置是很多线上故障的根源: \n`Too many open files`;\n`java.lang.OutOfMemoryError: unable to create new native thread`;\n对于生产环境来说, ulimit 的调参优化至关重要;\n本文详细介绍并梳理一下与 ulimit 相关的林林总总;\n\n<!--more-->\n\n------\n\nulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;\n注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;\n在 `/etc/security/limits.conf` 文件中的第一段注释如下:\n> This file sets the resource limits for the users logged in via PAM.\nIt does not affect resource limits of the system services.\n\n关于 linux PAM 相关的内容, 可以前往另外一篇文章: [pam 认证与配置]();\n\n## **ulimit 基本信息**\n``` bash\n# 查看所有 ulimit 设置\n> ulimit -a\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 15018\nmax locked memory       (kbytes, -l) 64             # 每个进程可以锁住而不被 swap 出去的内存\nmax memory size         (kbytes, -m) unlimited      # 每个进程可使用的最大内存大小\nopen files                      (-n) 1024           # 每个进程可打开的文件数\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192           # 每个进程可使用的最大堆栈大小\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 4096           # 每个用户的最大进程数\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n## **ulimit 需要优化的场景及待优化参数**\nlinux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;\n### **场景1: tomcat web 容器 **\n一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;\n如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;\n所以, 可以对该机器的 ulimit 作出如下调整:\n``` bash\n1. max memory size -> unlimit\n2. open files -> 65536\n3. stack size -> unlimit\n```\n另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 `java.lang.OutOfMemoryError: unable to create new native thread` 的异常;\n最后确定问题的原因是 `ulimit -u` max user processes 的数量配置过低, 增大后解决问题:\n``` bash\n4. max user processes -> 65535\n```\n具体的情况可以参见这篇文章: [dubbo 服务治理框架设计]();\n\n### **场景2: elasticsearch data node**\n32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: '-Xmx30g -Xms30g', 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;\n所以, 可以对该机器的 ulimit 作出如下调整:\n```\n1. max locked memory -> unlimit\n2. max memory size -> unlimit\n3. open files -> 65536\n4. stack size -> unlimit\n```\n当然, 对于 max locked memory, elasticsearch.yml 本身有一个配置项 bootstrap.mlockall/bootstrap.memory_lock, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的;\n&nbsp;\n另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;\n以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;\n\n## **ulimit 当前 session 下的临时修改**\nulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;\n其调整方法也已经在 `ulimit -a` 中被注明了:\n```\n# max locked mem\nulimit -l unlimit\n# max mem size\nulimit -m unlimit\n# open files\nulimit -n 65536\n# max user processes\nulimit -u 65536\n...\n```\n\n## **ulimit 的永久修改**\n上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:\n\n1. `/etc/security/limits.conf`;\n2. `/etc/security/limits.d 目录`;\n\n这些文件用于持久化每个用户的资源限制设置;\n其中, `/etc/security/limits.conf` 自不必说, 这是配置 ulimit 的主要文件:\n``` bash\ndomain  限制的目标:\n        username    用户名;\n        @groupname  组名, 需加 '@' 前缀;\n        *           通配所有用户/组;\n        %groupname  这种写法只能用于限制 某个 group 的 maxlogin limit, 即最大登陆用户数限制;\n        \ntype    限制的属性:\n        `soft` 对 domain 给出的用户设置默认值; \n        `hard` 限制 domain 给出的用户自己所能设置的最大值; \n        `-` 将 soft 与 hard 都设为相同的值;\n        \nitem    限制的资源类型, 与 ulimit 所限制的资源类型大致相同:\n        - core - limits the core file size (KB)\n        - data - max data size (KB)\n        - fsize - maximum filesize (KB)\n        - memlock - max locked-in-memory address space (KB)\n        - nofile - max number of open file descriptors\n        - rss - max resident set size (KB)\n        - stack - max stack size (KB)\n        - cpu - max CPU time (MIN)\n        - nproc - max number of processes\n        - as - address space limit (KB)\n        - maxlogins - max number of logins for this user\n        - maxsyslogins - max number of logins on the system\n        - priority - the priority to run user process with\n        - locks - max number of file locks the user can hold\n        - sigpending - max number of pending signals\n        - msgqueue - max memory used by POSIX message queues (bytes)\n        - nice - max nice priority allowed to raise to values: [-20, 19]\n        - rtprio - max realtime priority\n\nvalue   限制的具体值;\n```\n以下是一个具体的例子:\n``` bash\n#<domain>        <type>     <item>     <value>\n*                 soft      nproc       65536\n*                 hard      nproc       65536\n*                 -         nofile      65536\n%guest            -         maxlogins   10\nelastic           -         memlock     unlimit\n@dev              hard      fsize       10737418240\n```\n&nbsp;\n而对于 `/etc/security/limits.d` 目录的作用,  `/etc/security/limits.conf` 文件中的第二段与第三段有如下注释:\n\n> Also note that configuration files in /etc/security/limits.d directory,\nwhich are read in alphabetical order, override the settings in this\nfile in case the domain is the same or more specific.\n&nbsp;\nThat means for example that setting a limit for wildcard domain here\ncan be overriden with a wildcard setting in a config file in the\nsubdirectory, but a user specific setting here can be overriden only\nwith a user specific setting in the subdirectory.\n\n也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;\n举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 `20-nproc.conf`:\n``` bash\n# Default limit for number of user's processes to prevent\n# accidental fork bombs.\n# See rhbz #432903 for reasoning.\n*          soft    nproc     4096\nroot       soft    nproc     unlimited\n```\n这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;\n如果修改 limits.conf 文件:\n``` bash\n*          hard    nproc     65535\n```\n这时会发现, 除非自己试图 `ulimit -u` 修改 max processes, 否则这个值会依然被限制为 4096;\n而要想将该值默认放到 65535, 就必须修改 `20-nproc.conf` 文件方才生效;\n\n### **永久修改生效的必要条件**\n\n## **参考链接**\n- [ulimit 命令详解](http://www.cnblogs.com/zengkefu/p/5649407.html)\n- [linux /etc/security/limits.conf的相关说明](http://blog.csdn.net/taijianyu/article/details/5976319)\n\n","slug":"linux-conf--ulimit调参与优化","published":1,"updated":"2018-01-08T15:34:21.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb0i0000fejxz00jg6g3","content":"<blockquote>\n<p>ulimit 未正确设置是很多线上故障的根源:<br><code>Too many open files</code>;<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>;<br>对于生产环境来说, ulimit 的调参优化至关重要;<br>本文详细介绍并梳理一下与 ulimit 相关的林林总总;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p>ulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;<br>注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;<br>在 <code>/etc/security/limits.conf</code> 文件中的第一段注释如下:</p>\n<blockquote>\n<p>This file sets the resource limits for the users logged in via PAM.<br>It does not affect resource limits of the system services.</p>\n</blockquote>\n<p>关于 linux PAM 相关的内容, 可以前往另外一篇文章: <a href=\"\">pam 认证与配置</a>;</p>\n<h2 id=\"ulimit-基本信息\"><a href=\"#ulimit-基本信息\" class=\"headerlink\" title=\"ulimit 基本信息\"></a><strong>ulimit 基本信息</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 ulimit 设置</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">ulimit</span> -a</span><br><span class=\"line\">core file size          (blocks, -c) 0</span><br><span class=\"line\">data seg size           (kbytes, -d) unlimited</span><br><span class=\"line\">scheduling priority             (-e) 0</span><br><span class=\"line\">file size               (blocks, -f) unlimited</span><br><span class=\"line\">pending signals                 (-i) 15018</span><br><span class=\"line\">max locked memory       (kbytes, -l) 64             <span class=\"comment\"># 每个进程可以锁住而不被 swap 出去的内存</span></span><br><span class=\"line\">max memory size         (kbytes, -m) unlimited      <span class=\"comment\"># 每个进程可使用的最大内存大小</span></span><br><span class=\"line\">open files                      (-n) 1024           <span class=\"comment\"># 每个进程可打开的文件数</span></span><br><span class=\"line\">pipe size            (512 bytes, -p) 8</span><br><span class=\"line\">POSIX message queues     (bytes, -q) 819200</span><br><span class=\"line\">real-time priority              (-r) 0</span><br><span class=\"line\">stack size              (kbytes, -s) 8192           <span class=\"comment\"># 每个进程可使用的最大堆栈大小</span></span><br><span class=\"line\">cpu time               (seconds, -t) unlimited</span><br><span class=\"line\">max user processes              (-u) 4096           <span class=\"comment\"># 每个用户的最大进程数</span></span><br><span class=\"line\">virtual memory          (kbytes, -v) unlimited</span><br><span class=\"line\">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>\n<h2 id=\"ulimit-需要优化的场景及待优化参数\"><a href=\"#ulimit-需要优化的场景及待优化参数\" class=\"headerlink\" title=\"ulimit 需要优化的场景及待优化参数\"></a><strong>ulimit 需要优化的场景及待优化参数</strong></h2><p>linux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;</p>\n<h3 id=\"场景1-tomcat-web-容器\"><a href=\"#场景1-tomcat-web-容器\" class=\"headerlink\" title=\"场景1: tomcat web 容器 \"></a><strong>场景1: tomcat web 容器 </strong></h3><p>一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;<br>如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max memory size -&gt; <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">2. open files -&gt; 65536</span><br><span class=\"line\">3. stack size -&gt; <span class=\"built_in\">unlimit</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 <code>java.lang.OutOfMemoryError: unable to create new native thread</code> 的异常;<br>最后确定问题的原因是 <code>ulimit -u</code> max user processes 的数量配置过低, 增大后解决问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. max user processes -&gt; 65535</span><br></pre></td></tr></table></figure></p>\n<p>具体的情况可以参见这篇文章: <a href=\"\">dubbo 服务治理框架设计</a>;</p>\n<h3 id=\"场景2-elasticsearch-data-node\"><a href=\"#场景2-elasticsearch-data-node\" class=\"headerlink\" title=\"场景2: elasticsearch data node\"></a><strong>场景2: elasticsearch data node</strong></h3><p>32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: ‘-Xmx30g -Xms30g’, 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max locked memory -&gt; unlimit</span><br><span class=\"line\">2. max memory size -&gt; unlimit</span><br><span class=\"line\">3. open files -&gt; 65536</span><br><span class=\"line\">4. stack size -&gt; unlimit</span><br></pre></td></tr></table></figure></p>\n<p>当然, 对于 max locked memory, elasticsearch.yml 本身有一个配置项 bootstrap.mlockall/bootstrap.memory_lock, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的;<br>&nbsp;<br>另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;<br>以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;</p>\n<h2 id=\"ulimit-当前-session-下的临时修改\"><a href=\"#ulimit-当前-session-下的临时修改\" class=\"headerlink\" title=\"ulimit 当前 session 下的临时修改\"></a><strong>ulimit 当前 session 下的临时修改</strong></h2><p>ulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;<br>其调整方法也已经在 <code>ulimit -a</code> 中被注明了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># max locked mem</span><br><span class=\"line\">ulimit -l unlimit</span><br><span class=\"line\"># max mem size</span><br><span class=\"line\">ulimit -m unlimit</span><br><span class=\"line\"># open files</span><br><span class=\"line\">ulimit -n 65536</span><br><span class=\"line\"># max user processes</span><br><span class=\"line\">ulimit -u 65536</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ulimit-的永久修改\"><a href=\"#ulimit-的永久修改\" class=\"headerlink\" title=\"ulimit 的永久修改\"></a><strong>ulimit 的永久修改</strong></h2><p>上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:</p>\n<ol>\n<li><code>/etc/security/limits.conf</code>;</li>\n<li><code>/etc/security/limits.d 目录</code>;</li>\n</ol>\n<p>这些文件用于持久化每个用户的资源限制设置;<br>其中, <code>/etc/security/limits.conf</code> 自不必说, 这是配置 ulimit 的主要文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">domain  限制的目标:</span><br><span class=\"line\">        username    用户名;</span><br><span class=\"line\">        @groupname  组名, 需加 <span class=\"string\">'@'</span> 前缀;</span><br><span class=\"line\">        *           通配所有用户/组;</span><br><span class=\"line\">        %groupname  这种写法只能用于限制 某个 group 的 maxlogin <span class=\"built_in\">limit</span>, 即最大登陆用户数限制;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"built_in\">type</span>    限制的属性:</span><br><span class=\"line\">        `soft` 对 domain 给出的用户设置默认值; </span><br><span class=\"line\">        `hard` 限制 domain 给出的用户自己所能设置的最大值; </span><br><span class=\"line\">        `-` 将 soft 与 hard 都设为相同的值;</span><br><span class=\"line\">        </span><br><span class=\"line\">item    限制的资源类型, 与 <span class=\"built_in\">ulimit</span> 所限制的资源类型大致相同:</span><br><span class=\"line\">        - core - limits the core file size (KB)</span><br><span class=\"line\">        - data - max data size (KB)</span><br><span class=\"line\">        - fsize - maximum filesize (KB)</span><br><span class=\"line\">        - memlock - max locked-in-memory address space (KB)</span><br><span class=\"line\">        - nofile - max number of open file descriptors</span><br><span class=\"line\">        - rss - max resident <span class=\"built_in\">set</span> size (KB)</span><br><span class=\"line\">        - stack - max stack size (KB)</span><br><span class=\"line\">        - cpu - max CPU time (MIN)</span><br><span class=\"line\">        - nproc - max number of processes</span><br><span class=\"line\">        - as - address space <span class=\"built_in\">limit</span> (KB)</span><br><span class=\"line\">        - maxlogins - max number of logins <span class=\"keyword\">for</span> this user</span><br><span class=\"line\">        - maxsyslogins - max number of logins on the system</span><br><span class=\"line\">        - priority - the priority to run user process with</span><br><span class=\"line\">        - locks - max number of file locks the user can hold</span><br><span class=\"line\">        - sigpending - max number of pending signals</span><br><span class=\"line\">        - msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class=\"line\">        - nice - max nice priority allowed to raise to values: [-20, 19]</span><br><span class=\"line\">        - rtprio - max realtime priority</span><br><span class=\"line\"></span><br><span class=\"line\">value   限制的具体值;</span><br></pre></td></tr></table></figure></p>\n<p>以下是一个具体的例子:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#&lt;domain&gt;        &lt;type&gt;     &lt;item&gt;     &lt;value&gt;</span></span><br><span class=\"line\">*                 soft      nproc       65536</span><br><span class=\"line\">*                 hard      nproc       65536</span><br><span class=\"line\">*                 -         nofile      65536</span><br><span class=\"line\">%guest            -         maxlogins   10</span><br><span class=\"line\">elastic           -         memlock     <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">@dev              hard      fsize       10737418240</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>而对于 <code>/etc/security/limits.d</code> 目录的作用,  <code>/etc/security/limits.conf</code> 文件中的第二段与第三段有如下注释:</p>\n<blockquote>\n<p>Also note that configuration files in /etc/security/limits.d directory,<br>which are read in alphabetical order, override the settings in this<br>file in case the domain is the same or more specific.<br>&nbsp;<br>That means for example that setting a limit for wildcard domain here<br>can be overriden with a wildcard setting in a config file in the<br>subdirectory, but a user specific setting here can be overriden only<br>with a user specific setting in the subdirectory.</p>\n</blockquote>\n<p>也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;<br>举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 <code>20-nproc.conf</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default limit for number of user's processes to prevent</span></span><br><span class=\"line\"><span class=\"comment\"># accidental fork bombs.</span></span><br><span class=\"line\"><span class=\"comment\"># See rhbz #432903 for reasoning.</span></span><br><span class=\"line\">*          soft    nproc     4096</span><br><span class=\"line\">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure></p>\n<p>这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;<br>如果修改 limits.conf 文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*          hard    nproc     65535</span><br></pre></td></tr></table></figure></p>\n<p>这时会发现, 除非自己试图 <code>ulimit -u</code> 修改 max processes, 否则这个值会依然被限制为 4096;<br>而要想将该值默认放到 65535, 就必须修改 <code>20-nproc.conf</code> 文件方才生效;</p>\n<h3 id=\"永久修改生效的必要条件\"><a href=\"#永久修改生效的必要条件\" class=\"headerlink\" title=\"永久修改生效的必要条件\"></a><strong>永久修改生效的必要条件</strong></h3><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/zengkefu/p/5649407.html\" target=\"_blank\" rel=\"noopener\">ulimit 命令详解</a></li>\n<li><a href=\"http://blog.csdn.net/taijianyu/article/details/5976319\" target=\"_blank\" rel=\"noopener\">linux /etc/security/limits.conf的相关说明</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>ulimit 未正确设置是很多线上故障的根源:<br><code>Too many open files</code>;<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>;<br>对于生产环境来说, ulimit 的调参优化至关重要;<br>本文详细介绍并梳理一下与 ulimit 相关的林林总总;</p>\n</blockquote>","more":"<hr>\n<p>ulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;<br>注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;<br>在 <code>/etc/security/limits.conf</code> 文件中的第一段注释如下:</p>\n<blockquote>\n<p>This file sets the resource limits for the users logged in via PAM.<br>It does not affect resource limits of the system services.</p>\n</blockquote>\n<p>关于 linux PAM 相关的内容, 可以前往另外一篇文章: <a href=\"\">pam 认证与配置</a>;</p>\n<h2 id=\"ulimit-基本信息\"><a href=\"#ulimit-基本信息\" class=\"headerlink\" title=\"ulimit 基本信息\"></a><strong>ulimit 基本信息</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 ulimit 设置</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">ulimit</span> -a</span><br><span class=\"line\">core file size          (blocks, -c) 0</span><br><span class=\"line\">data seg size           (kbytes, -d) unlimited</span><br><span class=\"line\">scheduling priority             (-e) 0</span><br><span class=\"line\">file size               (blocks, -f) unlimited</span><br><span class=\"line\">pending signals                 (-i) 15018</span><br><span class=\"line\">max locked memory       (kbytes, -l) 64             <span class=\"comment\"># 每个进程可以锁住而不被 swap 出去的内存</span></span><br><span class=\"line\">max memory size         (kbytes, -m) unlimited      <span class=\"comment\"># 每个进程可使用的最大内存大小</span></span><br><span class=\"line\">open files                      (-n) 1024           <span class=\"comment\"># 每个进程可打开的文件数</span></span><br><span class=\"line\">pipe size            (512 bytes, -p) 8</span><br><span class=\"line\">POSIX message queues     (bytes, -q) 819200</span><br><span class=\"line\">real-time priority              (-r) 0</span><br><span class=\"line\">stack size              (kbytes, -s) 8192           <span class=\"comment\"># 每个进程可使用的最大堆栈大小</span></span><br><span class=\"line\">cpu time               (seconds, -t) unlimited</span><br><span class=\"line\">max user processes              (-u) 4096           <span class=\"comment\"># 每个用户的最大进程数</span></span><br><span class=\"line\">virtual memory          (kbytes, -v) unlimited</span><br><span class=\"line\">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>\n<h2 id=\"ulimit-需要优化的场景及待优化参数\"><a href=\"#ulimit-需要优化的场景及待优化参数\" class=\"headerlink\" title=\"ulimit 需要优化的场景及待优化参数\"></a><strong>ulimit 需要优化的场景及待优化参数</strong></h2><p>linux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;</p>\n<h3 id=\"场景1-tomcat-web-容器\"><a href=\"#场景1-tomcat-web-容器\" class=\"headerlink\" title=\"场景1: tomcat web 容器 \"></a><strong>场景1: tomcat web 容器 </strong></h3><p>一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;<br>如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max memory size -&gt; <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">2. open files -&gt; 65536</span><br><span class=\"line\">3. stack size -&gt; <span class=\"built_in\">unlimit</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 <code>java.lang.OutOfMemoryError: unable to create new native thread</code> 的异常;<br>最后确定问题的原因是 <code>ulimit -u</code> max user processes 的数量配置过低, 增大后解决问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. max user processes -&gt; 65535</span><br></pre></td></tr></table></figure></p>\n<p>具体的情况可以参见这篇文章: <a href=\"\">dubbo 服务治理框架设计</a>;</p>\n<h3 id=\"场景2-elasticsearch-data-node\"><a href=\"#场景2-elasticsearch-data-node\" class=\"headerlink\" title=\"场景2: elasticsearch data node\"></a><strong>场景2: elasticsearch data node</strong></h3><p>32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: ‘-Xmx30g -Xms30g’, 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max locked memory -&gt; unlimit</span><br><span class=\"line\">2. max memory size -&gt; unlimit</span><br><span class=\"line\">3. open files -&gt; 65536</span><br><span class=\"line\">4. stack size -&gt; unlimit</span><br></pre></td></tr></table></figure></p>\n<p>当然, 对于 max locked memory, elasticsearch.yml 本身有一个配置项 bootstrap.mlockall/bootstrap.memory_lock, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的;<br>&nbsp;<br>另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;<br>以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;</p>\n<h2 id=\"ulimit-当前-session-下的临时修改\"><a href=\"#ulimit-当前-session-下的临时修改\" class=\"headerlink\" title=\"ulimit 当前 session 下的临时修改\"></a><strong>ulimit 当前 session 下的临时修改</strong></h2><p>ulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;<br>其调整方法也已经在 <code>ulimit -a</code> 中被注明了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># max locked mem</span><br><span class=\"line\">ulimit -l unlimit</span><br><span class=\"line\"># max mem size</span><br><span class=\"line\">ulimit -m unlimit</span><br><span class=\"line\"># open files</span><br><span class=\"line\">ulimit -n 65536</span><br><span class=\"line\"># max user processes</span><br><span class=\"line\">ulimit -u 65536</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ulimit-的永久修改\"><a href=\"#ulimit-的永久修改\" class=\"headerlink\" title=\"ulimit 的永久修改\"></a><strong>ulimit 的永久修改</strong></h2><p>上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:</p>\n<ol>\n<li><code>/etc/security/limits.conf</code>;</li>\n<li><code>/etc/security/limits.d 目录</code>;</li>\n</ol>\n<p>这些文件用于持久化每个用户的资源限制设置;<br>其中, <code>/etc/security/limits.conf</code> 自不必说, 这是配置 ulimit 的主要文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">domain  限制的目标:</span><br><span class=\"line\">        username    用户名;</span><br><span class=\"line\">        @groupname  组名, 需加 <span class=\"string\">'@'</span> 前缀;</span><br><span class=\"line\">        *           通配所有用户/组;</span><br><span class=\"line\">        %groupname  这种写法只能用于限制 某个 group 的 maxlogin <span class=\"built_in\">limit</span>, 即最大登陆用户数限制;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"built_in\">type</span>    限制的属性:</span><br><span class=\"line\">        `soft` 对 domain 给出的用户设置默认值; </span><br><span class=\"line\">        `hard` 限制 domain 给出的用户自己所能设置的最大值; </span><br><span class=\"line\">        `-` 将 soft 与 hard 都设为相同的值;</span><br><span class=\"line\">        </span><br><span class=\"line\">item    限制的资源类型, 与 <span class=\"built_in\">ulimit</span> 所限制的资源类型大致相同:</span><br><span class=\"line\">        - core - limits the core file size (KB)</span><br><span class=\"line\">        - data - max data size (KB)</span><br><span class=\"line\">        - fsize - maximum filesize (KB)</span><br><span class=\"line\">        - memlock - max locked-in-memory address space (KB)</span><br><span class=\"line\">        - nofile - max number of open file descriptors</span><br><span class=\"line\">        - rss - max resident <span class=\"built_in\">set</span> size (KB)</span><br><span class=\"line\">        - stack - max stack size (KB)</span><br><span class=\"line\">        - cpu - max CPU time (MIN)</span><br><span class=\"line\">        - nproc - max number of processes</span><br><span class=\"line\">        - as - address space <span class=\"built_in\">limit</span> (KB)</span><br><span class=\"line\">        - maxlogins - max number of logins <span class=\"keyword\">for</span> this user</span><br><span class=\"line\">        - maxsyslogins - max number of logins on the system</span><br><span class=\"line\">        - priority - the priority to run user process with</span><br><span class=\"line\">        - locks - max number of file locks the user can hold</span><br><span class=\"line\">        - sigpending - max number of pending signals</span><br><span class=\"line\">        - msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class=\"line\">        - nice - max nice priority allowed to raise to values: [-20, 19]</span><br><span class=\"line\">        - rtprio - max realtime priority</span><br><span class=\"line\"></span><br><span class=\"line\">value   限制的具体值;</span><br></pre></td></tr></table></figure></p>\n<p>以下是一个具体的例子:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#&lt;domain&gt;        &lt;type&gt;     &lt;item&gt;     &lt;value&gt;</span></span><br><span class=\"line\">*                 soft      nproc       65536</span><br><span class=\"line\">*                 hard      nproc       65536</span><br><span class=\"line\">*                 -         nofile      65536</span><br><span class=\"line\">%guest            -         maxlogins   10</span><br><span class=\"line\">elastic           -         memlock     <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">@dev              hard      fsize       10737418240</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>而对于 <code>/etc/security/limits.d</code> 目录的作用,  <code>/etc/security/limits.conf</code> 文件中的第二段与第三段有如下注释:</p>\n<blockquote>\n<p>Also note that configuration files in /etc/security/limits.d directory,<br>which are read in alphabetical order, override the settings in this<br>file in case the domain is the same or more specific.<br>&nbsp;<br>That means for example that setting a limit for wildcard domain here<br>can be overriden with a wildcard setting in a config file in the<br>subdirectory, but a user specific setting here can be overriden only<br>with a user specific setting in the subdirectory.</p>\n</blockquote>\n<p>也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;<br>举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 <code>20-nproc.conf</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default limit for number of user's processes to prevent</span></span><br><span class=\"line\"><span class=\"comment\"># accidental fork bombs.</span></span><br><span class=\"line\"><span class=\"comment\"># See rhbz #432903 for reasoning.</span></span><br><span class=\"line\">*          soft    nproc     4096</span><br><span class=\"line\">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure></p>\n<p>这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;<br>如果修改 limits.conf 文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*          hard    nproc     65535</span><br></pre></td></tr></table></figure></p>\n<p>这时会发现, 除非自己试图 <code>ulimit -u</code> 修改 max processes, 否则这个值会依然被限制为 4096;<br>而要想将该值默认放到 65535, 就必须修改 <code>20-nproc.conf</code> 文件方才生效;</p>\n<h3 id=\"永久修改生效的必要条件\"><a href=\"#永久修改生效的必要条件\" class=\"headerlink\" title=\"永久修改生效的必要条件\"></a><strong>永久修改生效的必要条件</strong></h3><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/zengkefu/p/5649407.html\" target=\"_blank\" rel=\"noopener\">ulimit 命令详解</a></li>\n<li><a href=\"http://blog.csdn.net/taijianyu/article/details/5976319\" target=\"_blank\" rel=\"noopener\">linux /etc/security/limits.conf的相关说明</a></li>\n</ul>"},{"title":"cli 控制字符","date":"2016-11-17T13:11:33.000Z","_content":"\n> cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;\n另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: [linux signals 总体认识](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/);\n本文总结一些常用的 cli 控制字符的使用及技巧;\n\n<!--more-->\n\n------\n\n### **简单的 cli 控制字符**\n``` bash\n# 发送 SIGINT 中断信号\nctrl + c\n# 清屏\nctrl + l\n# reverse-i-search 搜索历史命令\nctrl + r\n# 从机器上 logout\nctrl + d\n# 暂停控制台标准输出 / 恢复控制台标准输出\nctrl + s / ctrl + q\n# 发送 SIGQUIT 信号给前台进程, 并生成 core dump\nctrl + /\n# 向前删除到第一个空格\nctrl + w\n# 向后删除到第一个空格\n alt + d\n# 向后删除所有的内容\nctrl + k\n# 撤销上一步操作\nctrl + ?\n# 光标快速跃进\nctrl + 方向键\n# 补全命令/文件\ntab\n```\n\n### **与其他命令组合的 cli 控制字符 **\n``` bash\n# 发送 SIGTSTP 信号, 挂起前台进程\nctrl + z\n# ctrl + z 的输出\n[1]+  Stopped                 sudo vim /etc/profile\n```\n此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;\n接下来可以有以下配套操作:\n``` bash\n# 查看后台任务\n> jobs\n[1]+  Stopped                 sudo vim /etc/profile\n# 查看后台任务的 pid\njobs -p\n\n# 将后台作业 1 恢复到前台\nfg 1\nfg %1\n# 将后台作业 1 恢复到后台\nbg 1\nbg %1\n```\n要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:\n``` bash\nkill -9 %1\nkill -9 `jobs -p`\n```\n还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:\n``` bash\n# 当任务被唤醒, 将接收到 SIGTERM 信号并终止\nkill %1 && fg\nkill %1 && bg\nkill `jobs -p` && bg\nkill `jobs -p` && fg\n```\n\n### **控制字符的管理与设置**\n``` bash\n# 打印所有控制字符的设置 (--all)\n> stty -a\nspeed 38400 baud; rows 60; columns 211; line = 0;\nintr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;\n-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr\n-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8\nopost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke\n```\n\n### **参考链接**\n- [Bg, Fg, &, Ctrl-Z – 5 Examples to Manage Unix Background Jobs](http://www.thegeekstuff.com/2010/05/unix-background-job/)\n- [Linux中 ctrl-c, ctrl-z, ctrl-d 区别](http://blog.csdn.net/mylizh/article/details/38385739)\n\n","source":"_posts/linux-other--cli控制字符.md","raw":"---\ntitle: cli 控制字符\ndate: 2016-11-17 21:11:33\ncategories:\n - linux\n - other\ntags:\n - cheat sheet\n---\n\n> cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;\n另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: [linux signals 总体认识](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/);\n本文总结一些常用的 cli 控制字符的使用及技巧;\n\n<!--more-->\n\n------\n\n### **简单的 cli 控制字符**\n``` bash\n# 发送 SIGINT 中断信号\nctrl + c\n# 清屏\nctrl + l\n# reverse-i-search 搜索历史命令\nctrl + r\n# 从机器上 logout\nctrl + d\n# 暂停控制台标准输出 / 恢复控制台标准输出\nctrl + s / ctrl + q\n# 发送 SIGQUIT 信号给前台进程, 并生成 core dump\nctrl + /\n# 向前删除到第一个空格\nctrl + w\n# 向后删除到第一个空格\n alt + d\n# 向后删除所有的内容\nctrl + k\n# 撤销上一步操作\nctrl + ?\n# 光标快速跃进\nctrl + 方向键\n# 补全命令/文件\ntab\n```\n\n### **与其他命令组合的 cli 控制字符 **\n``` bash\n# 发送 SIGTSTP 信号, 挂起前台进程\nctrl + z\n# ctrl + z 的输出\n[1]+  Stopped                 sudo vim /etc/profile\n```\n此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;\n接下来可以有以下配套操作:\n``` bash\n# 查看后台任务\n> jobs\n[1]+  Stopped                 sudo vim /etc/profile\n# 查看后台任务的 pid\njobs -p\n\n# 将后台作业 1 恢复到前台\nfg 1\nfg %1\n# 将后台作业 1 恢复到后台\nbg 1\nbg %1\n```\n要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:\n``` bash\nkill -9 %1\nkill -9 `jobs -p`\n```\n还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:\n``` bash\n# 当任务被唤醒, 将接收到 SIGTERM 信号并终止\nkill %1 && fg\nkill %1 && bg\nkill `jobs -p` && bg\nkill `jobs -p` && fg\n```\n\n### **控制字符的管理与设置**\n``` bash\n# 打印所有控制字符的设置 (--all)\n> stty -a\nspeed 38400 baud; rows 60; columns 211; line = 0;\nintr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;\n-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr\n-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8\nopost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke\n```\n\n### **参考链接**\n- [Bg, Fg, &, Ctrl-Z – 5 Examples to Manage Unix Background Jobs](http://www.thegeekstuff.com/2010/05/unix-background-job/)\n- [Linux中 ctrl-c, ctrl-z, ctrl-d 区别](http://blog.csdn.net/mylizh/article/details/38385739)\n\n","slug":"linux-other--cli控制字符","published":1,"updated":"2018-01-07T13:13:21.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb0u0002fejxza9dysx8","content":"<blockquote>\n<p>cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;<br>另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/\">linux signals 总体认识</a>;<br>本文总结一些常用的 cli 控制字符的使用及技巧;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"简单的-cli-控制字符\"><a href=\"#简单的-cli-控制字符\" class=\"headerlink\" title=\"简单的 cli 控制字符\"></a><strong>简单的 cli 控制字符</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGINT 中断信号</span></span><br><span class=\"line\">ctrl + c</span><br><span class=\"line\"><span class=\"comment\"># 清屏</span></span><br><span class=\"line\">ctrl + l</span><br><span class=\"line\"><span class=\"comment\"># reverse-i-search 搜索历史命令</span></span><br><span class=\"line\">ctrl + r</span><br><span class=\"line\"><span class=\"comment\"># 从机器上 logout</span></span><br><span class=\"line\">ctrl + d</span><br><span class=\"line\"><span class=\"comment\"># 暂停控制台标准输出 / 恢复控制台标准输出</span></span><br><span class=\"line\">ctrl + s / ctrl + q</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGQUIT 信号给前台进程, 并生成 core dump</span></span><br><span class=\"line\">ctrl + /</span><br><span class=\"line\"><span class=\"comment\"># 向前删除到第一个空格</span></span><br><span class=\"line\">ctrl + w</span><br><span class=\"line\"><span class=\"comment\"># 向后删除到第一个空格</span></span><br><span class=\"line\"> alt + d</span><br><span class=\"line\"><span class=\"comment\"># 向后删除所有的内容</span></span><br><span class=\"line\">ctrl + k</span><br><span class=\"line\"><span class=\"comment\"># 撤销上一步操作</span></span><br><span class=\"line\">ctrl + ?</span><br><span class=\"line\"><span class=\"comment\"># 光标快速跃进</span></span><br><span class=\"line\">ctrl + 方向键</span><br><span class=\"line\"><span class=\"comment\"># 补全命令/文件</span></span><br><span class=\"line\">tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"与其他命令组合的-cli-控制字符\"><a href=\"#与其他命令组合的-cli-控制字符\" class=\"headerlink\" title=\"与其他命令组合的 cli 控制字符 \"></a><strong>与其他命令组合的 cli 控制字符 </strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGTSTP 信号, 挂起前台进程</span></span><br><span class=\"line\">ctrl + z</span><br><span class=\"line\"><span class=\"comment\"># ctrl + z 的输出</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br></pre></td></tr></table></figure>\n<p>此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;<br>接下来可以有以下配套操作:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看后台任务</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">jobs</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 查看后台任务的 pid</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span> -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到前台</span></span><br><span class=\"line\"><span class=\"built_in\">fg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">fg</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到后台</span></span><br><span class=\"line\"><span class=\"built_in\">bg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">bg</span> %1</span><br></pre></td></tr></table></figure></p>\n<p>要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 %1</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `<span class=\"built_in\">jobs</span> -p`</span><br></pre></td></tr></table></figure></p>\n<p>还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当任务被唤醒, 将接收到 SIGTERM 信号并终止</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">fg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">fg</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制字符的管理与设置\"><a href=\"#控制字符的管理与设置\" class=\"headerlink\" title=\"控制字符的管理与设置\"></a><strong>控制字符的管理与设置</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印所有控制字符的设置 (--all)</span></span><br><span class=\"line\">&gt; stty -a</span><br><span class=\"line\">speed 38400 baud; rows 60; columns 211; line = 0;</span><br><span class=\"line\">intr = ^C; quit = ^\\; erase = ^?; <span class=\"built_in\">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</span><br><span class=\"line\">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr</span><br><span class=\"line\">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8</span><br><span class=\"line\">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class=\"line\">isig icanon iexten <span class=\"built_in\">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.thegeekstuff.com/2010/05/unix-background-job/\" target=\"_blank\" rel=\"noopener\">Bg, Fg, &amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs</a></li>\n<li><a href=\"http://blog.csdn.net/mylizh/article/details/38385739\" target=\"_blank\" rel=\"noopener\">Linux中 ctrl-c, ctrl-z, ctrl-d 区别</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;<br>另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/\">linux signals 总体认识</a>;<br>本文总结一些常用的 cli 控制字符的使用及技巧;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"简单的-cli-控制字符\"><a href=\"#简单的-cli-控制字符\" class=\"headerlink\" title=\"简单的 cli 控制字符\"></a><strong>简单的 cli 控制字符</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGINT 中断信号</span></span><br><span class=\"line\">ctrl + c</span><br><span class=\"line\"><span class=\"comment\"># 清屏</span></span><br><span class=\"line\">ctrl + l</span><br><span class=\"line\"><span class=\"comment\"># reverse-i-search 搜索历史命令</span></span><br><span class=\"line\">ctrl + r</span><br><span class=\"line\"><span class=\"comment\"># 从机器上 logout</span></span><br><span class=\"line\">ctrl + d</span><br><span class=\"line\"><span class=\"comment\"># 暂停控制台标准输出 / 恢复控制台标准输出</span></span><br><span class=\"line\">ctrl + s / ctrl + q</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGQUIT 信号给前台进程, 并生成 core dump</span></span><br><span class=\"line\">ctrl + /</span><br><span class=\"line\"><span class=\"comment\"># 向前删除到第一个空格</span></span><br><span class=\"line\">ctrl + w</span><br><span class=\"line\"><span class=\"comment\"># 向后删除到第一个空格</span></span><br><span class=\"line\"> alt + d</span><br><span class=\"line\"><span class=\"comment\"># 向后删除所有的内容</span></span><br><span class=\"line\">ctrl + k</span><br><span class=\"line\"><span class=\"comment\"># 撤销上一步操作</span></span><br><span class=\"line\">ctrl + ?</span><br><span class=\"line\"><span class=\"comment\"># 光标快速跃进</span></span><br><span class=\"line\">ctrl + 方向键</span><br><span class=\"line\"><span class=\"comment\"># 补全命令/文件</span></span><br><span class=\"line\">tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"与其他命令组合的-cli-控制字符\"><a href=\"#与其他命令组合的-cli-控制字符\" class=\"headerlink\" title=\"与其他命令组合的 cli 控制字符 \"></a><strong>与其他命令组合的 cli 控制字符 </strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGTSTP 信号, 挂起前台进程</span></span><br><span class=\"line\">ctrl + z</span><br><span class=\"line\"><span class=\"comment\"># ctrl + z 的输出</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br></pre></td></tr></table></figure>\n<p>此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;<br>接下来可以有以下配套操作:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看后台任务</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">jobs</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 查看后台任务的 pid</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span> -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到前台</span></span><br><span class=\"line\"><span class=\"built_in\">fg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">fg</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到后台</span></span><br><span class=\"line\"><span class=\"built_in\">bg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">bg</span> %1</span><br></pre></td></tr></table></figure></p>\n<p>要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 %1</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `<span class=\"built_in\">jobs</span> -p`</span><br></pre></td></tr></table></figure></p>\n<p>还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当任务被唤醒, 将接收到 SIGTERM 信号并终止</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">fg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">fg</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制字符的管理与设置\"><a href=\"#控制字符的管理与设置\" class=\"headerlink\" title=\"控制字符的管理与设置\"></a><strong>控制字符的管理与设置</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印所有控制字符的设置 (--all)</span></span><br><span class=\"line\">&gt; stty -a</span><br><span class=\"line\">speed 38400 baud; rows 60; columns 211; line = 0;</span><br><span class=\"line\">intr = ^C; quit = ^\\; erase = ^?; <span class=\"built_in\">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</span><br><span class=\"line\">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr</span><br><span class=\"line\">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8</span><br><span class=\"line\">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class=\"line\">isig icanon iexten <span class=\"built_in\">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.thegeekstuff.com/2010/05/unix-background-job/\" target=\"_blank\" rel=\"noopener\">Bg, Fg, &amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs</a></li>\n<li><a href=\"http://blog.csdn.net/mylizh/article/details/38385739\" target=\"_blank\" rel=\"noopener\">Linux中 ctrl-c, ctrl-z, ctrl-d 区别</a></li>\n</ul>"},{"title":"du / df 使用及其区别","date":"2017-04-07T14:58:04.000Z","_content":"\n> 本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;\n接着, 一般性得总结这两个命令在实际工作中的应用;\n然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;\n\n<!--more-->\n\n------\n\n## **du命令**\nestimate disk file space usage. ---- man du\n### **du 的常用选项**\n``` bash\n# 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小\nsudo du /target_path\n# 列举指定路径下所有的文件(包括目录与文件)的大小\nsudo du -a /target_path\n# 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)\nsudo du -s /target_path\n# 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和(诊断 磁盘满问题 最常用的方式)\nsudo du -sh /target_path/*\n# 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和\n# 理论上这与目标路径不含通配符的 -sh 输出结果是相同的\nsudo du -c /target_path\n```\n&nbsp;\n\n## **df 命令**\nfile system disk space usage. ---- man df\n### **df 的常用选项**\n``` bash\n# 显示给定的路径所挂载的磁盘分区的大小及使用量等\ndf /target_path\n# 以 MB 最小单位显示大小及使用量\ndf --block-size=1m /target_path\ndf -B 1m /target_path\n# 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况\ndf -h # 1024\ndf -H # 1000\n# 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)\ndf -a\n# 过滤 nfs 远程文件系统后的本地文件系统\ndf -l\n```\n&nbsp;\n**一般性总结:**\ndf 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小; \n所以 df 命令的主要运用场景是: `df -h`, 判断所挂载的每个分区的使用率, 是不是满了;\n作为先决判断依据, 如果发现磁盘满了, 再接着使用 `du -sh` 等命令进一步排查;\n&nbsp;\n\n## **du 与 df 命令的区别**\n### **df 命令与 du 命令的工作原理**\ndf 命令使用 系统调用 `statfs`, 获取磁盘分区的超级块 (super block) 使用情况;\ndu 命令使用 系统调用 `fstat`, 获取待统计文件的大小;\n### **df 命令与 du 命令可接受范围内不一致**\n问题场景: *du -s 与 df 核算精确结果总有差异;*\n&nbsp;\n原因: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;\ndf 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;\n所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;\n&nbsp;\n结论: *这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;*\n### **df 命令与 du 命令显著不一致**\n问题场景: *当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量会将其计入在内;*\n&nbsp;\n原因: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;\n这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;\n&nbsp;\n结论: *这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;*\n### **问题解决方案**\n磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:\n1.配合使用 lsof 找出相关的 `幽灵文件` 的句柄持有情况(command 与 pid):\n``` bash\n> sudo lsof | grep deleted\nnginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/local/openresty/nginx/client_body_temp/0068359496 (deleted)\nnginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/local/openresty/nginx/client_body_temp/0068359498 (deleted)\n...\n```\n然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;\n当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号) 和 [nginx signals 处理]();\n另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来; \n所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: [logrotate 配置与运维]();\n&nbsp;\n2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:\n``` bash\n# 将文件写空\nsudo echo > file_path\n```\n将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;\n&nbsp;\n\n## **参考链接**\n- [df和du显示的磁盘空间使用情况不一致的原因及处理](http://www.cnblogs.com/heyonggang/p/3644736.html)\n- [linux lsof 详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n\n","source":"_posts/linux-other--du,df使用及其区别.md","raw":"---\ntitle: du / df 使用及其区别\ndate: 2017-04-07 22:58:04\ncategories:\n - linux\n - other\ntags:\n - linux:disk\n---\n\n> 本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;\n接着, 一般性得总结这两个命令在实际工作中的应用;\n然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;\n\n<!--more-->\n\n------\n\n## **du命令**\nestimate disk file space usage. ---- man du\n### **du 的常用选项**\n``` bash\n# 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小\nsudo du /target_path\n# 列举指定路径下所有的文件(包括目录与文件)的大小\nsudo du -a /target_path\n# 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)\nsudo du -s /target_path\n# 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和(诊断 磁盘满问题 最常用的方式)\nsudo du -sh /target_path/*\n# 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和\n# 理论上这与目标路径不含通配符的 -sh 输出结果是相同的\nsudo du -c /target_path\n```\n&nbsp;\n\n## **df 命令**\nfile system disk space usage. ---- man df\n### **df 的常用选项**\n``` bash\n# 显示给定的路径所挂载的磁盘分区的大小及使用量等\ndf /target_path\n# 以 MB 最小单位显示大小及使用量\ndf --block-size=1m /target_path\ndf -B 1m /target_path\n# 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况\ndf -h # 1024\ndf -H # 1000\n# 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)\ndf -a\n# 过滤 nfs 远程文件系统后的本地文件系统\ndf -l\n```\n&nbsp;\n**一般性总结:**\ndf 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小; \n所以 df 命令的主要运用场景是: `df -h`, 判断所挂载的每个分区的使用率, 是不是满了;\n作为先决判断依据, 如果发现磁盘满了, 再接着使用 `du -sh` 等命令进一步排查;\n&nbsp;\n\n## **du 与 df 命令的区别**\n### **df 命令与 du 命令的工作原理**\ndf 命令使用 系统调用 `statfs`, 获取磁盘分区的超级块 (super block) 使用情况;\ndu 命令使用 系统调用 `fstat`, 获取待统计文件的大小;\n### **df 命令与 du 命令可接受范围内不一致**\n问题场景: *du -s 与 df 核算精确结果总有差异;*\n&nbsp;\n原因: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;\ndf 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;\n所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;\n&nbsp;\n结论: *这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;*\n### **df 命令与 du 命令显著不一致**\n问题场景: *当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量会将其计入在内;*\n&nbsp;\n原因: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;\n这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;\n&nbsp;\n结论: *这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;*\n### **问题解决方案**\n磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:\n1.配合使用 lsof 找出相关的 `幽灵文件` 的句柄持有情况(command 与 pid):\n``` bash\n> sudo lsof | grep deleted\nnginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/local/openresty/nginx/client_body_temp/0068359496 (deleted)\nnginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/local/openresty/nginx/client_body_temp/0068359498 (deleted)\n...\n```\n然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;\n当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号) 和 [nginx signals 处理]();\n另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来; \n所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: [logrotate 配置与运维]();\n&nbsp;\n2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:\n``` bash\n# 将文件写空\nsudo echo > file_path\n```\n将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;\n&nbsp;\n\n## **参考链接**\n- [df和du显示的磁盘空间使用情况不一致的原因及处理](http://www.cnblogs.com/heyonggang/p/3644736.html)\n- [linux lsof 详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n\n","slug":"linux-other--du,df使用及其区别","published":1,"updated":"2018-01-07T15:06:11.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb180006fejxffysqrq6","content":"<blockquote>\n<p>本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;<br>接着, 一般性得总结这两个命令在实际工作中的应用;<br>然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a><strong>du命令</strong></h2><p>estimate disk file space usage. —- man du</p>\n<h3 id=\"du-的常用选项\"><a href=\"#du-的常用选项\" class=\"headerlink\" title=\"du 的常用选项\"></a><strong>du 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小</span></span><br><span class=\"line\">sudo du /target_path</span><br><span class=\"line\"><span class=\"comment\"># 列举指定路径下所有的文件(包括目录与文件)的大小</span></span><br><span class=\"line\">sudo du -a /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)</span></span><br><span class=\"line\">sudo du -s /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和(诊断 磁盘满问题 最常用的方式)</span></span><br><span class=\"line\">sudo du -sh /target_path/*</span><br><span class=\"line\"><span class=\"comment\"># 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和</span></span><br><span class=\"line\"><span class=\"comment\"># 理论上这与目标路径不含通配符的 -sh 输出结果是相同的</span></span><br><span class=\"line\">sudo du -c /target_path</span><br></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<h2 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a><strong>df 命令</strong></h2><p>file system disk space usage. —- man df</p>\n<h3 id=\"df-的常用选项\"><a href=\"#df-的常用选项\" class=\"headerlink\" title=\"df 的常用选项\"></a><strong>df 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示给定的路径所挂载的磁盘分区的大小及使用量等</span></span><br><span class=\"line\">df /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 MB 最小单位显示大小及使用量</span></span><br><span class=\"line\">df --block-size=1m /target_path</span><br><span class=\"line\">df -B 1m /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况</span></span><br><span class=\"line\">df -h <span class=\"comment\"># 1024</span></span><br><span class=\"line\">df -H <span class=\"comment\"># 1000</span></span><br><span class=\"line\"><span class=\"comment\"># 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)</span></span><br><span class=\"line\">df -a</span><br><span class=\"line\"><span class=\"comment\"># 过滤 nfs 远程文件系统后的本地文件系统</span></span><br><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n<p>&nbsp;<br><strong>一般性总结:</strong><br>df 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小;<br>所以 df 命令的主要运用场景是: <code>df -h</code>, 判断所挂载的每个分区的使用率, 是不是满了;<br>作为先决判断依据, 如果发现磁盘满了, 再接着使用 <code>du -sh</code> 等命令进一步排查;<br>&nbsp;</p>\n<h2 id=\"du-与-df-命令的区别\"><a href=\"#du-与-df-命令的区别\" class=\"headerlink\" title=\"du 与 df 命令的区别\"></a><strong>du 与 df 命令的区别</strong></h2><h3 id=\"df-命令与-du-命令的工作原理\"><a href=\"#df-命令与-du-命令的工作原理\" class=\"headerlink\" title=\"df 命令与 du 命令的工作原理\"></a><strong>df 命令与 du 命令的工作原理</strong></h3><p>df 命令使用 系统调用 <code>statfs</code>, 获取磁盘分区的超级块 (super block) 使用情况;<br>du 命令使用 系统调用 <code>fstat</code>, 获取待统计文件的大小;</p>\n<h3 id=\"df-命令与-du-命令可接受范围内不一致\"><a href=\"#df-命令与-du-命令可接受范围内不一致\" class=\"headerlink\" title=\"df 命令与 du 命令可接受范围内不一致\"></a><strong>df 命令与 du 命令可接受范围内不一致</strong></h3><p>问题场景: <em>du -s 与 df 核算精确结果总有差异;</em><br>&nbsp;<br>原因: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;<br>df 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;<br>所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;<br>&nbsp;<br>结论: <em>这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;</em></p>\n<h3 id=\"df-命令与-du-命令显著不一致\"><a href=\"#df-命令与-du-命令显著不一致\" class=\"headerlink\" title=\"df 命令与 du 命令显著不一致\"></a><strong>df 命令与 du 命令显著不一致</strong></h3><p>问题场景: <em>当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量会将其计入在内;</em><br>&nbsp;<br>原因: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;<br>这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;<br>&nbsp;<br>结论: <em>这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;</em></p>\n<h3 id=\"问题解决方案\"><a href=\"#问题解决方案\" class=\"headerlink\" title=\"问题解决方案\"></a><strong>问题解决方案</strong></h3><p>磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:<br>1.配合使用 lsof 找出相关的 <code>幽灵文件</code> 的句柄持有情况(command 与 pid):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo lsof | grep deleted</span><br><span class=\"line\">nginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359496 (deleted)</span><br><span class=\"line\">nginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359498 (deleted)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;<br>当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\">linux signals 总体认识#其他信号</a> 和 <a href=\"\">nginx signals 处理</a>;<br>另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来;<br>所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: <a href=\"\">logrotate 配置与运维</a>;<br>&nbsp;<br>2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件写空</span></span><br><span class=\"line\">sudo <span class=\"built_in\">echo</span> &gt; file_path</span><br></pre></td></tr></table></figure></p>\n<p>将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;<br>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/heyonggang/p/3644736.html\" target=\"_blank\" rel=\"noopener\">df和du显示的磁盘空间使用情况不一致的原因及处理</a></li>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof 详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;<br>接着, 一般性得总结这两个命令在实际工作中的应用;<br>然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a><strong>du命令</strong></h2><p>estimate disk file space usage. —- man du</p>\n<h3 id=\"du-的常用选项\"><a href=\"#du-的常用选项\" class=\"headerlink\" title=\"du 的常用选项\"></a><strong>du 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小</span></span><br><span class=\"line\">sudo du /target_path</span><br><span class=\"line\"><span class=\"comment\"># 列举指定路径下所有的文件(包括目录与文件)的大小</span></span><br><span class=\"line\">sudo du -a /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)</span></span><br><span class=\"line\">sudo du -s /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和(诊断 磁盘满问题 最常用的方式)</span></span><br><span class=\"line\">sudo du -sh /target_path/*</span><br><span class=\"line\"><span class=\"comment\"># 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和</span></span><br><span class=\"line\"><span class=\"comment\"># 理论上这与目标路径不含通配符的 -sh 输出结果是相同的</span></span><br><span class=\"line\">sudo du -c /target_path</span><br></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<h2 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a><strong>df 命令</strong></h2><p>file system disk space usage. —- man df</p>\n<h3 id=\"df-的常用选项\"><a href=\"#df-的常用选项\" class=\"headerlink\" title=\"df 的常用选项\"></a><strong>df 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示给定的路径所挂载的磁盘分区的大小及使用量等</span></span><br><span class=\"line\">df /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 MB 最小单位显示大小及使用量</span></span><br><span class=\"line\">df --block-size=1m /target_path</span><br><span class=\"line\">df -B 1m /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况</span></span><br><span class=\"line\">df -h <span class=\"comment\"># 1024</span></span><br><span class=\"line\">df -H <span class=\"comment\"># 1000</span></span><br><span class=\"line\"><span class=\"comment\"># 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)</span></span><br><span class=\"line\">df -a</span><br><span class=\"line\"><span class=\"comment\"># 过滤 nfs 远程文件系统后的本地文件系统</span></span><br><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n<p>&nbsp;<br><strong>一般性总结:</strong><br>df 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小;<br>所以 df 命令的主要运用场景是: <code>df -h</code>, 判断所挂载的每个分区的使用率, 是不是满了;<br>作为先决判断依据, 如果发现磁盘满了, 再接着使用 <code>du -sh</code> 等命令进一步排查;<br>&nbsp;</p>\n<h2 id=\"du-与-df-命令的区别\"><a href=\"#du-与-df-命令的区别\" class=\"headerlink\" title=\"du 与 df 命令的区别\"></a><strong>du 与 df 命令的区别</strong></h2><h3 id=\"df-命令与-du-命令的工作原理\"><a href=\"#df-命令与-du-命令的工作原理\" class=\"headerlink\" title=\"df 命令与 du 命令的工作原理\"></a><strong>df 命令与 du 命令的工作原理</strong></h3><p>df 命令使用 系统调用 <code>statfs</code>, 获取磁盘分区的超级块 (super block) 使用情况;<br>du 命令使用 系统调用 <code>fstat</code>, 获取待统计文件的大小;</p>\n<h3 id=\"df-命令与-du-命令可接受范围内不一致\"><a href=\"#df-命令与-du-命令可接受范围内不一致\" class=\"headerlink\" title=\"df 命令与 du 命令可接受范围内不一致\"></a><strong>df 命令与 du 命令可接受范围内不一致</strong></h3><p>问题场景: <em>du -s 与 df 核算精确结果总有差异;</em><br>&nbsp;<br>原因: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;<br>df 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;<br>所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;<br>&nbsp;<br>结论: <em>这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;</em></p>\n<h3 id=\"df-命令与-du-命令显著不一致\"><a href=\"#df-命令与-du-命令显著不一致\" class=\"headerlink\" title=\"df 命令与 du 命令显著不一致\"></a><strong>df 命令与 du 命令显著不一致</strong></h3><p>问题场景: <em>当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量会将其计入在内;</em><br>&nbsp;<br>原因: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;<br>这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;<br>&nbsp;<br>结论: <em>这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;</em></p>\n<h3 id=\"问题解决方案\"><a href=\"#问题解决方案\" class=\"headerlink\" title=\"问题解决方案\"></a><strong>问题解决方案</strong></h3><p>磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:<br>1.配合使用 lsof 找出相关的 <code>幽灵文件</code> 的句柄持有情况(command 与 pid):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo lsof | grep deleted</span><br><span class=\"line\">nginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359496 (deleted)</span><br><span class=\"line\">nginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359498 (deleted)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;<br>当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\">linux signals 总体认识#其他信号</a> 和 <a href=\"\">nginx signals 处理</a>;<br>另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来;<br>所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: <a href=\"\">logrotate 配置与运维</a>;<br>&nbsp;<br>2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件写空</span></span><br><span class=\"line\">sudo <span class=\"built_in\">echo</span> &gt; file_path</span><br></pre></td></tr></table></figure></p>\n<p>将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;<br>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/heyonggang/p/3644736.html\" target=\"_blank\" rel=\"noopener\">df和du显示的磁盘空间使用情况不一致的原因及处理</a></li>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof 详解</a></li>\n</ul>"},{"title":"lsof 札记","date":"2017-01-06T07:17:04.000Z","_content":"\n> 第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: [netstat/ss 使用对比]() );\n使用之后, 发现 lsof 被人称为 `神器`, 还是有一定道理的; 在任何资源都被抽象为 `文件` 的 linux 中, 一个面向 `文件` 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;\n本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;\n\n<!--more-->\n\n------\n\n## **lsof 命令的输出结构**\n``` bash\n# COMMAND   启动进程的命令\n# PID       进程号\n# TID       线程号\n# USER      用户\n# FD        文件描述符\n# TYPE      文件类型\n# DEVICE    磁盘名称\n# SIZE      文件大小\n# NODE      inode 号\n# NAME      文件资源的名称\n> sudo lsof | head -n 2\nCOMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME\nsystemd       1            root  cwd       DIR              253,1        4096        128 /\n```\n\n### **各字段的不同输出含义**\nFD: 文件描述符 file description\n``` bash\n# 任何进程都必须有的\n0:      标准输入流\n1:      标准输出流\n2:      标准错误流\n\n# 几种特殊的保留 fd\ncwd:    current work directory, 应用程序启动的目录\ntxt:    二进制可执行文件或共享库\nrtd:    root directory, 根目录\nmem:    memory mapped file, 内存映射文件\nmmap:   memory-mapped device, 内存映射设备\n\n# 整数后面跟着的字母\nu:      可读可写模式\nr:      只读模式\nw:      只写模式\n```\nTYPE: 文件类型\n``` bash\nDIR:    目录文件\nREG:    普通文件\nCHR:    char, 字符设备文件\nBLK:    block, 块设备文件\nIPV4:   ipv4 socket 套接字文件\nIPV6:   ipv6 socket 套接字文件\n```\nDEVICE:\n``` bash\ntodo\n```\nSIZE: 文件大小\n``` bash\n# 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size\n0t0:    套接字文件的默认占位\n```\n&nbsp;\n## **lsof 的日常应用**\n### **lsof 网络 相关的应用**\n``` bash\n# 显示所有网络连接\nsudo lsof -i\n# 只显示 ipv6 的连接\nsudo lsof -i 6\n# 只显示 tcp 协议的连接\nsudo lsof -i TCP\n# 指定端口号\nsudo lsof -i:port\n# 指定主机(与端口)\nsudo lsof -i@l-tracer15.tc.cn2.xx.com:9999\n```\n\n### **lsof 用户 相关的应用**\n``` bash\n# 显示某用户所打开的文件\nsudo lsof -u zshell.zhang\nsudo lsof -u ^zshell.zhang (排除此用户)\n```\n\n### **lsof 命令/进程 相关的应用**\n``` bash\n# 只显示 pid\nsudo lsof -t\n# 只显示指定的命令打开的文件\nsudo lsof -c nginx\n# 只显示指定 pid 的进程打开的文件\nsudo lsof -p pid\n```\n\n### **lsof 文件/目录 相关的应用**\n``` bash\n# 搜索与指定路径相关的一切资源(user, process 等)\nsudo lsof /target_path\n# +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)\nsudo lsof +d /target_path\nsudo lsof +D /target_path\n```\n\n### **lsof 的选项组合及实践技巧**\n上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;\nlsof 与(and) 的逻辑运算关系如下:\n``` bash\n# 使用 -a 达到 与(and) 的效果\n# 必须同时满足三个条件: \n#   1. 是用户 zshell.zhang 启动的进程;\n#   2. 是套接字文件, 且连接的主机是 10.64.4.11;\n#   3. 该进程命令是 java;\nsudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java\n```\nlsof 常用的组合及实践:\n``` bash\n# 寻找已删除但未释放文件句柄的幽灵文件\nsudo lsof | grep deleted\n# 杀死所有匹配一定文件打开条件的进程\nsudo kill `sudo lsof -t -c java` # 杀死所有 java 进程\nsudo kill `sudo lsof -t -u zshell.zhang` # 杀死所有 zshell.zhang 的用户进程\n# 恢复删除的文件\n# 找到误删文件被什么进程持有, 获得 pid 和 fd\n1. sudo lsof /target_deleted_file\n# /proc/{pid}/fd/{fd_num} 的内容即为误删内容, 重定向到误删文件中即可\n2. cat /proc/{pid}/fd/{fd_num} > /target_deleted_file\n```\n另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/);\n\n## **参考链接**\n- [linux lsof详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n- [每天一个Linux命令（45）lsof命令](http://www.cnblogs.com/MenAngel/p/5575479.html)\n- [Linux 命令神器: lsof 入门](https://linux.cn/article-4099-1.html)\n- [what-does-the-fd-column-of-pipes-listed-by-lsof-mean](https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean)\n\n","source":"_posts/linux-other--lsof札记.md","raw":"---\ntitle: lsof 札记\ndate: 2017-01-06 15:17:04\ncategories:\n  - linux\n  - other\ntags:\n  - linux:net\n  - linux:disk\n---\n\n> 第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: [netstat/ss 使用对比]() );\n使用之后, 发现 lsof 被人称为 `神器`, 还是有一定道理的; 在任何资源都被抽象为 `文件` 的 linux 中, 一个面向 `文件` 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;\n本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;\n\n<!--more-->\n\n------\n\n## **lsof 命令的输出结构**\n``` bash\n# COMMAND   启动进程的命令\n# PID       进程号\n# TID       线程号\n# USER      用户\n# FD        文件描述符\n# TYPE      文件类型\n# DEVICE    磁盘名称\n# SIZE      文件大小\n# NODE      inode 号\n# NAME      文件资源的名称\n> sudo lsof | head -n 2\nCOMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME\nsystemd       1            root  cwd       DIR              253,1        4096        128 /\n```\n\n### **各字段的不同输出含义**\nFD: 文件描述符 file description\n``` bash\n# 任何进程都必须有的\n0:      标准输入流\n1:      标准输出流\n2:      标准错误流\n\n# 几种特殊的保留 fd\ncwd:    current work directory, 应用程序启动的目录\ntxt:    二进制可执行文件或共享库\nrtd:    root directory, 根目录\nmem:    memory mapped file, 内存映射文件\nmmap:   memory-mapped device, 内存映射设备\n\n# 整数后面跟着的字母\nu:      可读可写模式\nr:      只读模式\nw:      只写模式\n```\nTYPE: 文件类型\n``` bash\nDIR:    目录文件\nREG:    普通文件\nCHR:    char, 字符设备文件\nBLK:    block, 块设备文件\nIPV4:   ipv4 socket 套接字文件\nIPV6:   ipv6 socket 套接字文件\n```\nDEVICE:\n``` bash\ntodo\n```\nSIZE: 文件大小\n``` bash\n# 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size\n0t0:    套接字文件的默认占位\n```\n&nbsp;\n## **lsof 的日常应用**\n### **lsof 网络 相关的应用**\n``` bash\n# 显示所有网络连接\nsudo lsof -i\n# 只显示 ipv6 的连接\nsudo lsof -i 6\n# 只显示 tcp 协议的连接\nsudo lsof -i TCP\n# 指定端口号\nsudo lsof -i:port\n# 指定主机(与端口)\nsudo lsof -i@l-tracer15.tc.cn2.xx.com:9999\n```\n\n### **lsof 用户 相关的应用**\n``` bash\n# 显示某用户所打开的文件\nsudo lsof -u zshell.zhang\nsudo lsof -u ^zshell.zhang (排除此用户)\n```\n\n### **lsof 命令/进程 相关的应用**\n``` bash\n# 只显示 pid\nsudo lsof -t\n# 只显示指定的命令打开的文件\nsudo lsof -c nginx\n# 只显示指定 pid 的进程打开的文件\nsudo lsof -p pid\n```\n\n### **lsof 文件/目录 相关的应用**\n``` bash\n# 搜索与指定路径相关的一切资源(user, process 等)\nsudo lsof /target_path\n# +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)\nsudo lsof +d /target_path\nsudo lsof +D /target_path\n```\n\n### **lsof 的选项组合及实践技巧**\n上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;\nlsof 与(and) 的逻辑运算关系如下:\n``` bash\n# 使用 -a 达到 与(and) 的效果\n# 必须同时满足三个条件: \n#   1. 是用户 zshell.zhang 启动的进程;\n#   2. 是套接字文件, 且连接的主机是 10.64.4.11;\n#   3. 该进程命令是 java;\nsudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java\n```\nlsof 常用的组合及实践:\n``` bash\n# 寻找已删除但未释放文件句柄的幽灵文件\nsudo lsof | grep deleted\n# 杀死所有匹配一定文件打开条件的进程\nsudo kill `sudo lsof -t -c java` # 杀死所有 java 进程\nsudo kill `sudo lsof -t -u zshell.zhang` # 杀死所有 zshell.zhang 的用户进程\n# 恢复删除的文件\n# 找到误删文件被什么进程持有, 获得 pid 和 fd\n1. sudo lsof /target_deleted_file\n# /proc/{pid}/fd/{fd_num} 的内容即为误删内容, 重定向到误删文件中即可\n2. cat /proc/{pid}/fd/{fd_num} > /target_deleted_file\n```\n另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/);\n\n## **参考链接**\n- [linux lsof详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n- [每天一个Linux命令（45）lsof命令](http://www.cnblogs.com/MenAngel/p/5575479.html)\n- [Linux 命令神器: lsof 入门](https://linux.cn/article-4099-1.html)\n- [what-does-the-fd-column-of-pipes-listed-by-lsof-mean](https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean)\n\n","slug":"linux-other--lsof札记","published":1,"updated":"2018-01-07T15:07:04.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1a0007fejxcee04ed0","content":"<blockquote>\n<p>第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: <a href=\"\">netstat/ss 使用对比</a> );<br>使用之后, 发现 lsof 被人称为 <code>神器</code>, 还是有一定道理的; 在任何资源都被抽象为 <code>文件</code> 的 linux 中, 一个面向 <code>文件</code> 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;<br>本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"lsof-命令的输出结构\"><a href=\"#lsof-命令的输出结构\" class=\"headerlink\" title=\"lsof 命令的输出结构\"></a><strong>lsof 命令的输出结构</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># COMMAND   启动进程的命令</span></span><br><span class=\"line\"><span class=\"comment\"># PID       进程号</span></span><br><span class=\"line\"><span class=\"comment\"># TID       线程号</span></span><br><span class=\"line\"><span class=\"comment\"># USER      用户</span></span><br><span class=\"line\"><span class=\"comment\"># FD        文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"># TYPE      文件类型</span></span><br><span class=\"line\"><span class=\"comment\"># DEVICE    磁盘名称</span></span><br><span class=\"line\"><span class=\"comment\"># SIZE      文件大小</span></span><br><span class=\"line\"><span class=\"comment\"># NODE      inode 号</span></span><br><span class=\"line\"><span class=\"comment\"># NAME      文件资源的名称</span></span><br><span class=\"line\">&gt; sudo lsof | head -n 2</span><br><span class=\"line\">COMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class=\"line\">systemd       1            root  cwd       DIR              253,1        4096        128 /</span><br></pre></td></tr></table></figure>\n<h3 id=\"各字段的不同输出含义\"><a href=\"#各字段的不同输出含义\" class=\"headerlink\" title=\"各字段的不同输出含义\"></a><strong>各字段的不同输出含义</strong></h3><p>FD: 文件描述符 file description<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任何进程都必须有的</span></span><br><span class=\"line\">0:      标准输入流</span><br><span class=\"line\">1:      标准输出流</span><br><span class=\"line\">2:      标准错误流</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 几种特殊的保留 fd</span></span><br><span class=\"line\">cwd:    current work directory, 应用程序启动的目录</span><br><span class=\"line\">txt:    二进制可执行文件或共享库</span><br><span class=\"line\">rtd:    root directory, 根目录</span><br><span class=\"line\">mem:    memory mapped file, 内存映射文件</span><br><span class=\"line\">mmap:   memory-mapped device, 内存映射设备</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整数后面跟着的字母</span></span><br><span class=\"line\">u:      可读可写模式</span><br><span class=\"line\">r:      只读模式</span><br><span class=\"line\">w:      只写模式</span><br></pre></td></tr></table></figure></p>\n<p>TYPE: 文件类型<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DIR:    目录文件</span><br><span class=\"line\">REG:    普通文件</span><br><span class=\"line\">CHR:    char, 字符设备文件</span><br><span class=\"line\">BLK:    block, 块设备文件</span><br><span class=\"line\">IPV4:   ipv4 socket 套接字文件</span><br><span class=\"line\">IPV6:   ipv6 socket 套接字文件</span><br></pre></td></tr></table></figure></p>\n<p>DEVICE:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todo</span><br></pre></td></tr></table></figure></p>\n<p>SIZE: 文件大小<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size</span></span><br><span class=\"line\">0t0:    套接字文件的默认占位</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h2 id=\"lsof-的日常应用\"><a href=\"#lsof-的日常应用\" class=\"headerlink\" title=\"lsof 的日常应用\"></a><strong>lsof 的日常应用</strong></h2><h3 id=\"lsof-网络-相关的应用\"><a href=\"#lsof-网络-相关的应用\" class=\"headerlink\" title=\"lsof 网络 相关的应用\"></a><strong>lsof 网络 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有网络连接</span></span><br><span class=\"line\">sudo lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 只显示 ipv6 的连接</span></span><br><span class=\"line\">sudo lsof -i 6</span><br><span class=\"line\"><span class=\"comment\"># 只显示 tcp 协议的连接</span></span><br><span class=\"line\">sudo lsof -i TCP</span><br><span class=\"line\"><span class=\"comment\"># 指定端口号</span></span><br><span class=\"line\">sudo lsof -i:port</span><br><span class=\"line\"><span class=\"comment\"># 指定主机(与端口)</span></span><br><span class=\"line\">sudo lsof -i@l-tracer15.tc.cn2.xx.com:9999</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-用户-相关的应用\"><a href=\"#lsof-用户-相关的应用\" class=\"headerlink\" title=\"lsof 用户 相关的应用\"></a><strong>lsof 用户 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某用户所打开的文件</span></span><br><span class=\"line\">sudo lsof -u zshell.zhang</span><br><span class=\"line\">sudo lsof -u ^zshell.zhang (排除此用户)</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-命令-进程-相关的应用\"><a href=\"#lsof-命令-进程-相关的应用\" class=\"headerlink\" title=\"lsof 命令/进程 相关的应用\"></a><strong>lsof 命令/进程 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只显示 pid</span></span><br><span class=\"line\">sudo lsof -t</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定的命令打开的文件</span></span><br><span class=\"line\">sudo lsof -c nginx</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定 pid 的进程打开的文件</span></span><br><span class=\"line\">sudo lsof -p pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-文件-目录-相关的应用\"><a href=\"#lsof-文件-目录-相关的应用\" class=\"headerlink\" title=\"lsof 文件/目录 相关的应用\"></a><strong>lsof 文件/目录 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索与指定路径相关的一切资源(user, process 等)</span></span><br><span class=\"line\">sudo lsof /target_path</span><br><span class=\"line\"><span class=\"comment\"># +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)</span></span><br><span class=\"line\">sudo lsof +d /target_path</span><br><span class=\"line\">sudo lsof +D /target_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-的选项组合及实践技巧\"><a href=\"#lsof-的选项组合及实践技巧\" class=\"headerlink\" title=\"lsof 的选项组合及实践技巧\"></a><strong>lsof 的选项组合及实践技巧</strong></h3><p>上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;<br>lsof 与(and) 的逻辑运算关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 -a 达到 与(and) 的效果</span></span><br><span class=\"line\"><span class=\"comment\"># 必须同时满足三个条件: </span></span><br><span class=\"line\"><span class=\"comment\">#   1. 是用户 zshell.zhang 启动的进程;</span></span><br><span class=\"line\"><span class=\"comment\">#   2. 是套接字文件, 且连接的主机是 10.64.4.11;</span></span><br><span class=\"line\"><span class=\"comment\">#   3. 该进程命令是 java;</span></span><br><span class=\"line\">sudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java</span><br></pre></td></tr></table></figure></p>\n<p>lsof 常用的组合及实践:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 寻找已删除但未释放文件句柄的幽灵文件</span></span><br><span class=\"line\">sudo lsof | grep deleted</span><br><span class=\"line\"><span class=\"comment\"># 杀死所有匹配一定文件打开条件的进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -c java` <span class=\"comment\"># 杀死所有 java 进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -u zshell.zhang` <span class=\"comment\"># 杀死所有 zshell.zhang 的用户进程</span></span><br><span class=\"line\"><span class=\"comment\"># 恢复删除的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 找到误删文件被什么进程持有, 获得 pid 和 fd</span></span><br><span class=\"line\">1. sudo lsof /target_deleted_file</span><br><span class=\"line\"><span class=\"comment\"># /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; 的内容即为误删内容, 重定向到误删文件中即可</span></span><br><span class=\"line\">2. cat /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; &gt; /target_deleted_file</span><br></pre></td></tr></table></figure></p>\n<p>另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: <a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\">du / df 使用及其区别</a>;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof详解</a></li>\n<li><a href=\"http://www.cnblogs.com/MenAngel/p/5575479.html\" target=\"_blank\" rel=\"noopener\">每天一个Linux命令（45）lsof命令</a></li>\n<li><a href=\"https://linux.cn/article-4099-1.html\" target=\"_blank\" rel=\"noopener\">Linux 命令神器: lsof 入门</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean\" target=\"_blank\" rel=\"noopener\">what-does-the-fd-column-of-pipes-listed-by-lsof-mean</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: <a href=\"\">netstat/ss 使用对比</a> );<br>使用之后, 发现 lsof 被人称为 <code>神器</code>, 还是有一定道理的; 在任何资源都被抽象为 <code>文件</code> 的 linux 中, 一个面向 <code>文件</code> 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;<br>本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"lsof-命令的输出结构\"><a href=\"#lsof-命令的输出结构\" class=\"headerlink\" title=\"lsof 命令的输出结构\"></a><strong>lsof 命令的输出结构</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># COMMAND   启动进程的命令</span></span><br><span class=\"line\"><span class=\"comment\"># PID       进程号</span></span><br><span class=\"line\"><span class=\"comment\"># TID       线程号</span></span><br><span class=\"line\"><span class=\"comment\"># USER      用户</span></span><br><span class=\"line\"><span class=\"comment\"># FD        文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"># TYPE      文件类型</span></span><br><span class=\"line\"><span class=\"comment\"># DEVICE    磁盘名称</span></span><br><span class=\"line\"><span class=\"comment\"># SIZE      文件大小</span></span><br><span class=\"line\"><span class=\"comment\"># NODE      inode 号</span></span><br><span class=\"line\"><span class=\"comment\"># NAME      文件资源的名称</span></span><br><span class=\"line\">&gt; sudo lsof | head -n 2</span><br><span class=\"line\">COMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class=\"line\">systemd       1            root  cwd       DIR              253,1        4096        128 /</span><br></pre></td></tr></table></figure>\n<h3 id=\"各字段的不同输出含义\"><a href=\"#各字段的不同输出含义\" class=\"headerlink\" title=\"各字段的不同输出含义\"></a><strong>各字段的不同输出含义</strong></h3><p>FD: 文件描述符 file description<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任何进程都必须有的</span></span><br><span class=\"line\">0:      标准输入流</span><br><span class=\"line\">1:      标准输出流</span><br><span class=\"line\">2:      标准错误流</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 几种特殊的保留 fd</span></span><br><span class=\"line\">cwd:    current work directory, 应用程序启动的目录</span><br><span class=\"line\">txt:    二进制可执行文件或共享库</span><br><span class=\"line\">rtd:    root directory, 根目录</span><br><span class=\"line\">mem:    memory mapped file, 内存映射文件</span><br><span class=\"line\">mmap:   memory-mapped device, 内存映射设备</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整数后面跟着的字母</span></span><br><span class=\"line\">u:      可读可写模式</span><br><span class=\"line\">r:      只读模式</span><br><span class=\"line\">w:      只写模式</span><br></pre></td></tr></table></figure></p>\n<p>TYPE: 文件类型<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DIR:    目录文件</span><br><span class=\"line\">REG:    普通文件</span><br><span class=\"line\">CHR:    char, 字符设备文件</span><br><span class=\"line\">BLK:    block, 块设备文件</span><br><span class=\"line\">IPV4:   ipv4 socket 套接字文件</span><br><span class=\"line\">IPV6:   ipv6 socket 套接字文件</span><br></pre></td></tr></table></figure></p>\n<p>DEVICE:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todo</span><br></pre></td></tr></table></figure></p>\n<p>SIZE: 文件大小<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size</span></span><br><span class=\"line\">0t0:    套接字文件的默认占位</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h2 id=\"lsof-的日常应用\"><a href=\"#lsof-的日常应用\" class=\"headerlink\" title=\"lsof 的日常应用\"></a><strong>lsof 的日常应用</strong></h2><h3 id=\"lsof-网络-相关的应用\"><a href=\"#lsof-网络-相关的应用\" class=\"headerlink\" title=\"lsof 网络 相关的应用\"></a><strong>lsof 网络 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有网络连接</span></span><br><span class=\"line\">sudo lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 只显示 ipv6 的连接</span></span><br><span class=\"line\">sudo lsof -i 6</span><br><span class=\"line\"><span class=\"comment\"># 只显示 tcp 协议的连接</span></span><br><span class=\"line\">sudo lsof -i TCP</span><br><span class=\"line\"><span class=\"comment\"># 指定端口号</span></span><br><span class=\"line\">sudo lsof -i:port</span><br><span class=\"line\"><span class=\"comment\"># 指定主机(与端口)</span></span><br><span class=\"line\">sudo lsof -i@l-tracer15.tc.cn2.xx.com:9999</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-用户-相关的应用\"><a href=\"#lsof-用户-相关的应用\" class=\"headerlink\" title=\"lsof 用户 相关的应用\"></a><strong>lsof 用户 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某用户所打开的文件</span></span><br><span class=\"line\">sudo lsof -u zshell.zhang</span><br><span class=\"line\">sudo lsof -u ^zshell.zhang (排除此用户)</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-命令-进程-相关的应用\"><a href=\"#lsof-命令-进程-相关的应用\" class=\"headerlink\" title=\"lsof 命令/进程 相关的应用\"></a><strong>lsof 命令/进程 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只显示 pid</span></span><br><span class=\"line\">sudo lsof -t</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定的命令打开的文件</span></span><br><span class=\"line\">sudo lsof -c nginx</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定 pid 的进程打开的文件</span></span><br><span class=\"line\">sudo lsof -p pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-文件-目录-相关的应用\"><a href=\"#lsof-文件-目录-相关的应用\" class=\"headerlink\" title=\"lsof 文件/目录 相关的应用\"></a><strong>lsof 文件/目录 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索与指定路径相关的一切资源(user, process 等)</span></span><br><span class=\"line\">sudo lsof /target_path</span><br><span class=\"line\"><span class=\"comment\"># +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)</span></span><br><span class=\"line\">sudo lsof +d /target_path</span><br><span class=\"line\">sudo lsof +D /target_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-的选项组合及实践技巧\"><a href=\"#lsof-的选项组合及实践技巧\" class=\"headerlink\" title=\"lsof 的选项组合及实践技巧\"></a><strong>lsof 的选项组合及实践技巧</strong></h3><p>上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;<br>lsof 与(and) 的逻辑运算关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 -a 达到 与(and) 的效果</span></span><br><span class=\"line\"><span class=\"comment\"># 必须同时满足三个条件: </span></span><br><span class=\"line\"><span class=\"comment\">#   1. 是用户 zshell.zhang 启动的进程;</span></span><br><span class=\"line\"><span class=\"comment\">#   2. 是套接字文件, 且连接的主机是 10.64.4.11;</span></span><br><span class=\"line\"><span class=\"comment\">#   3. 该进程命令是 java;</span></span><br><span class=\"line\">sudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java</span><br></pre></td></tr></table></figure></p>\n<p>lsof 常用的组合及实践:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 寻找已删除但未释放文件句柄的幽灵文件</span></span><br><span class=\"line\">sudo lsof | grep deleted</span><br><span class=\"line\"><span class=\"comment\"># 杀死所有匹配一定文件打开条件的进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -c java` <span class=\"comment\"># 杀死所有 java 进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -u zshell.zhang` <span class=\"comment\"># 杀死所有 zshell.zhang 的用户进程</span></span><br><span class=\"line\"><span class=\"comment\"># 恢复删除的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 找到误删文件被什么进程持有, 获得 pid 和 fd</span></span><br><span class=\"line\">1. sudo lsof /target_deleted_file</span><br><span class=\"line\"><span class=\"comment\"># /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; 的内容即为误删内容, 重定向到误删文件中即可</span></span><br><span class=\"line\">2. cat /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; &gt; /target_deleted_file</span><br></pre></td></tr></table></figure></p>\n<p>另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: <a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\">du / df 使用及其区别</a>;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof详解</a></li>\n<li><a href=\"http://www.cnblogs.com/MenAngel/p/5575479.html\" target=\"_blank\" rel=\"noopener\">每天一个Linux命令（45）lsof命令</a></li>\n<li><a href=\"https://linux.cn/article-4099-1.html\" target=\"_blank\" rel=\"noopener\">Linux 命令神器: lsof 入门</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean\" target=\"_blank\" rel=\"noopener\">what-does-the-fd-column-of-pipes-listed-by-lsof-mean</a></li>\n</ul>"},{"title":"linux signals 总体认识","date":"2017-04-05T15:24:22.000Z","_content":"\n> linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;\n不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;\n本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;\n\n<!--more-->\n\n## **linux signals 总览**\nlinux siginal 可分为如下几大类:\n\n1. 系统错误信号\n2. 进程终止信号\n3. 作业控制信号\n4. AIO 信号\n5. 定时器信号\n6. 操作错误信号\n7. 其他信号\n\n&nbsp;\n使用 kill -l 查看所有信号分布:\n``` bash\n> kill -l\n 1) SIGHUP\t     2) SIGINT\t     3) SIGQUIT\t     4) SIGILL\t     5) SIGTRAP\n 6) SIGABRT\t     7) SIGBUS\t     8) SIGFPE\t     9) SIGKILL\t    10) SIGUSR1\n11) SIGSEGV\t    12) SIGUSR2\t    13) SIGPIPE\t    14) SIGALRM\t    15) SIGTERM\n16) SIGSTKFLT\t    17) SIGCHLD\t    18) SIGCONT\t    19) SIGSTOP\t    20) SIGTSTP\n21) SIGTTIN\t    22) SIGTTOU\t    23) SIGURG\t    24) SIGXCPU\t    25) SIGXFSZ\n26) SIGVTALRM\t    27) SIGPROF\t    28) SIGWINCH    29) SIGIO\t    30) SIGPWR\n31) SIGSYS\t    34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\n38) SIGRTMIN+4\t    39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9\t    44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\n48) SIGRTMIN+14\t    49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\n53) SIGRTMAX-11\t    54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\n58) SIGRTMAX-6\t    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1\t    64) SIGRTMAX\n```\n\n## **各类别信号整理**\n\n### **进程终止信号**\n进程终止信号是我们日常操作中最常用的一类信号;\n进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;\n``` bash\n# terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;\nSIGTERM\n# interrupt, ctrl + c 发出的信号, 默认处理是终止进程;\nSIGINT\n# quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:\n# 1. 终止进程; 2. 产生进程 core dump 文件;\nSIGQUIT\n# kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理\n# 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用\nSIGKILL\n# hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session\n# session 接收该信号并将其发送给子进程\nSIGHUP\n```\n另外一篇详细梳理与 SIGHUP 相关知识点的链接: [SIGHUP 相关全梳理]();\n该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;\n\n### **任务控制信号**\n\n### **其他信号**\n其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;\n&nbsp;\n(1) 用户自定义信号: SIGUSR1 / SIGUSR2\n这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;\nSIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;\n以下是 SIGUSR1 / SIGUSR2 的具体使用场景:\n``` bash\n# 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志\nkill -USR1 `cat /var/run/nginx.pid`\n# 通知 nginx 平滑升级 二进制可执行程序\nkill -s SIGUSR2 `cat /var/run/nginx.pid`\n```\n&nbsp;\n(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;\n以下是 SIGWINCH 的具体使用场景:\n``` bash\n# 通知 nginx worker process 不再接受新 request, 并从容关闭\nkill -WINCH `cat /var/run/nginx.pid`\n```\n\n## **参考链接**\n- [24.2.2 Termination Signals](http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals)\n- [24.2.5 Job Control Signals](http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html)\n- [24.2.7 Miscellaneous Signals](http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals)\n- [Difference between SIGUSR1 and SIGUSR2](https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2)\n- [linux kill 命令 以及 USR1 信号 解释](http://blog.csdn.net/fuming0210sc/article/details/50906372)\n- [Linux 信号入门详解](http://blog.csdn.net/lisongjia123/article/details/50471854)\n- [文章3: Nginx中与信号有关的内容](http://blog.csdn.net/yankai0219/article/details/8453261)\n\n","source":"_posts/linux-process--linux_signals总体认识.md","raw":"---\ntitle: linux signals 总体认识\ndate: 2017-04-05 23:24:22\ncategories:\n  - linux\n  - process\ntags:\n  - linux:process\n---\n\n> linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;\n不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;\n本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;\n\n<!--more-->\n\n## **linux signals 总览**\nlinux siginal 可分为如下几大类:\n\n1. 系统错误信号\n2. 进程终止信号\n3. 作业控制信号\n4. AIO 信号\n5. 定时器信号\n6. 操作错误信号\n7. 其他信号\n\n&nbsp;\n使用 kill -l 查看所有信号分布:\n``` bash\n> kill -l\n 1) SIGHUP\t     2) SIGINT\t     3) SIGQUIT\t     4) SIGILL\t     5) SIGTRAP\n 6) SIGABRT\t     7) SIGBUS\t     8) SIGFPE\t     9) SIGKILL\t    10) SIGUSR1\n11) SIGSEGV\t    12) SIGUSR2\t    13) SIGPIPE\t    14) SIGALRM\t    15) SIGTERM\n16) SIGSTKFLT\t    17) SIGCHLD\t    18) SIGCONT\t    19) SIGSTOP\t    20) SIGTSTP\n21) SIGTTIN\t    22) SIGTTOU\t    23) SIGURG\t    24) SIGXCPU\t    25) SIGXFSZ\n26) SIGVTALRM\t    27) SIGPROF\t    28) SIGWINCH    29) SIGIO\t    30) SIGPWR\n31) SIGSYS\t    34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\n38) SIGRTMIN+4\t    39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9\t    44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\n48) SIGRTMIN+14\t    49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\n53) SIGRTMAX-11\t    54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\n58) SIGRTMAX-6\t    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1\t    64) SIGRTMAX\n```\n\n## **各类别信号整理**\n\n### **进程终止信号**\n进程终止信号是我们日常操作中最常用的一类信号;\n进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;\n``` bash\n# terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;\nSIGTERM\n# interrupt, ctrl + c 发出的信号, 默认处理是终止进程;\nSIGINT\n# quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:\n# 1. 终止进程; 2. 产生进程 core dump 文件;\nSIGQUIT\n# kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理\n# 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用\nSIGKILL\n# hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session\n# session 接收该信号并将其发送给子进程\nSIGHUP\n```\n另外一篇详细梳理与 SIGHUP 相关知识点的链接: [SIGHUP 相关全梳理]();\n该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;\n\n### **任务控制信号**\n\n### **其他信号**\n其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;\n&nbsp;\n(1) 用户自定义信号: SIGUSR1 / SIGUSR2\n这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;\nSIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;\n以下是 SIGUSR1 / SIGUSR2 的具体使用场景:\n``` bash\n# 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志\nkill -USR1 `cat /var/run/nginx.pid`\n# 通知 nginx 平滑升级 二进制可执行程序\nkill -s SIGUSR2 `cat /var/run/nginx.pid`\n```\n&nbsp;\n(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;\n以下是 SIGWINCH 的具体使用场景:\n``` bash\n# 通知 nginx worker process 不再接受新 request, 并从容关闭\nkill -WINCH `cat /var/run/nginx.pid`\n```\n\n## **参考链接**\n- [24.2.2 Termination Signals](http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals)\n- [24.2.5 Job Control Signals](http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html)\n- [24.2.7 Miscellaneous Signals](http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals)\n- [Difference between SIGUSR1 and SIGUSR2](https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2)\n- [linux kill 命令 以及 USR1 信号 解释](http://blog.csdn.net/fuming0210sc/article/details/50906372)\n- [Linux 信号入门详解](http://blog.csdn.net/lisongjia123/article/details/50471854)\n- [文章3: Nginx中与信号有关的内容](http://blog.csdn.net/yankai0219/article/details/8453261)\n\n","slug":"linux-process--linux_signals总体认识","published":1,"updated":"2018-01-05T15:30:03.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1c0008fejxy50kxv5x","content":"<blockquote>\n<p>linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;<br>不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;<br>本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"linux-signals-总览\"><a href=\"#linux-signals-总览\" class=\"headerlink\" title=\"linux signals 总览\"></a><strong>linux signals 总览</strong></h2><p>linux siginal 可分为如下几大类:</p>\n<ol>\n<li>系统错误信号</li>\n<li>进程终止信号</li>\n<li>作业控制信号</li>\n<li>AIO 信号</li>\n<li>定时器信号</li>\n<li>操作错误信号</li>\n<li>其他信号</li>\n</ol>\n<p>&nbsp;<br>使用 kill -l 查看所有信号分布:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">kill</span> -l</span><br><span class=\"line\"> 1) SIGHUP\t     2) SIGINT\t     3) SIGQUIT\t     4) SIGILL\t     5) SIGTRAP</span><br><span class=\"line\"> 6) SIGABRT\t     7) SIGBUS\t     8) SIGFPE\t     9) SIGKILL\t    10) SIGUSR1</span><br><span class=\"line\">11) SIGSEGV\t    12) SIGUSR2\t    13) SIGPIPE\t    14) SIGALRM\t    15) SIGTERM</span><br><span class=\"line\">16) SIGSTKFLT\t    17) SIGCHLD\t    18) SIGCONT\t    19) SIGSTOP\t    20) SIGTSTP</span><br><span class=\"line\">21) SIGTTIN\t    22) SIGTTOU\t    23) SIGURG\t    24) SIGXCPU\t    25) SIGXFSZ</span><br><span class=\"line\">26) SIGVTALRM\t    27) SIGPROF\t    28) SIGWINCH    29) SIGIO\t    30) SIGPWR</span><br><span class=\"line\">31) SIGSYS\t    34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class=\"line\">38) SIGRTMIN+4\t    39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class=\"line\">43) SIGRTMIN+9\t    44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class=\"line\">48) SIGRTMIN+14\t    49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class=\"line\">53) SIGRTMAX-11\t    54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class=\"line\">58) SIGRTMAX-6\t    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class=\"line\">63) SIGRTMAX-1\t    64) SIGRTMAX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"各类别信号整理\"><a href=\"#各类别信号整理\" class=\"headerlink\" title=\"各类别信号整理\"></a><strong>各类别信号整理</strong></h2><h3 id=\"进程终止信号\"><a href=\"#进程终止信号\" class=\"headerlink\" title=\"进程终止信号\"></a><strong>进程终止信号</strong></h3><p>进程终止信号是我们日常操作中最常用的一类信号;<br>进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGTERM</span><br><span class=\"line\"><span class=\"comment\"># interrupt, ctrl + c 发出的信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGINT</span><br><span class=\"line\"><span class=\"comment\"># quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 终止进程; 2. 产生进程 core dump 文件;</span></span><br><span class=\"line\">SIGQUIT</span><br><span class=\"line\"><span class=\"comment\"># kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理</span></span><br><span class=\"line\"><span class=\"comment\"># 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用</span></span><br><span class=\"line\">SIGKILL</span><br><span class=\"line\"><span class=\"comment\"># hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session</span></span><br><span class=\"line\"><span class=\"comment\"># session 接收该信号并将其发送给子进程</span></span><br><span class=\"line\">SIGHUP</span><br></pre></td></tr></table></figure></p>\n<p>另外一篇详细梳理与 SIGHUP 相关知识点的链接: <a href=\"\">SIGHUP 相关全梳理</a>;<br>该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &amp;,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;</p>\n<h3 id=\"任务控制信号\"><a href=\"#任务控制信号\" class=\"headerlink\" title=\"任务控制信号\"></a><strong>任务控制信号</strong></h3><h3 id=\"其他信号\"><a href=\"#其他信号\" class=\"headerlink\" title=\"其他信号\"></a><strong>其他信号</strong></h3><p>其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;<br>&nbsp;<br>(1) 用户自定义信号: SIGUSR1 / SIGUSR2<br>这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;<br>SIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;<br>以下是 SIGUSR1 / SIGUSR2 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat /var/run/nginx.pid`</span><br><span class=\"line\"><span class=\"comment\"># 通知 nginx 平滑升级 二进制可执行程序</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -s SIGUSR2 `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;<br>以下是 SIGWINCH 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx worker process 不再接受新 request, 并从容关闭</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -WINCH `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals\" target=\"_blank\" rel=\"noopener\">24.2.2 Termination Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html\" target=\"_blank\" rel=\"noopener\">24.2.5 Job Control Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals\" target=\"_blank\" rel=\"noopener\">24.2.7 Miscellaneous Signals</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2\" target=\"_blank\" rel=\"noopener\">Difference between SIGUSR1 and SIGUSR2</a></li>\n<li><a href=\"http://blog.csdn.net/fuming0210sc/article/details/50906372\" target=\"_blank\" rel=\"noopener\">linux kill 命令 以及 USR1 信号 解释</a></li>\n<li><a href=\"http://blog.csdn.net/lisongjia123/article/details/50471854\" target=\"_blank\" rel=\"noopener\">Linux 信号入门详解</a></li>\n<li><a href=\"http://blog.csdn.net/yankai0219/article/details/8453261\" target=\"_blank\" rel=\"noopener\">文章3: Nginx中与信号有关的内容</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;<br>不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;<br>本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;</p>\n</blockquote>","more":"<h2 id=\"linux-signals-总览\"><a href=\"#linux-signals-总览\" class=\"headerlink\" title=\"linux signals 总览\"></a><strong>linux signals 总览</strong></h2><p>linux siginal 可分为如下几大类:</p>\n<ol>\n<li>系统错误信号</li>\n<li>进程终止信号</li>\n<li>作业控制信号</li>\n<li>AIO 信号</li>\n<li>定时器信号</li>\n<li>操作错误信号</li>\n<li>其他信号</li>\n</ol>\n<p>&nbsp;<br>使用 kill -l 查看所有信号分布:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">kill</span> -l</span><br><span class=\"line\"> 1) SIGHUP\t     2) SIGINT\t     3) SIGQUIT\t     4) SIGILL\t     5) SIGTRAP</span><br><span class=\"line\"> 6) SIGABRT\t     7) SIGBUS\t     8) SIGFPE\t     9) SIGKILL\t    10) SIGUSR1</span><br><span class=\"line\">11) SIGSEGV\t    12) SIGUSR2\t    13) SIGPIPE\t    14) SIGALRM\t    15) SIGTERM</span><br><span class=\"line\">16) SIGSTKFLT\t    17) SIGCHLD\t    18) SIGCONT\t    19) SIGSTOP\t    20) SIGTSTP</span><br><span class=\"line\">21) SIGTTIN\t    22) SIGTTOU\t    23) SIGURG\t    24) SIGXCPU\t    25) SIGXFSZ</span><br><span class=\"line\">26) SIGVTALRM\t    27) SIGPROF\t    28) SIGWINCH    29) SIGIO\t    30) SIGPWR</span><br><span class=\"line\">31) SIGSYS\t    34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class=\"line\">38) SIGRTMIN+4\t    39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class=\"line\">43) SIGRTMIN+9\t    44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class=\"line\">48) SIGRTMIN+14\t    49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class=\"line\">53) SIGRTMAX-11\t    54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class=\"line\">58) SIGRTMAX-6\t    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class=\"line\">63) SIGRTMAX-1\t    64) SIGRTMAX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"各类别信号整理\"><a href=\"#各类别信号整理\" class=\"headerlink\" title=\"各类别信号整理\"></a><strong>各类别信号整理</strong></h2><h3 id=\"进程终止信号\"><a href=\"#进程终止信号\" class=\"headerlink\" title=\"进程终止信号\"></a><strong>进程终止信号</strong></h3><p>进程终止信号是我们日常操作中最常用的一类信号;<br>进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGTERM</span><br><span class=\"line\"><span class=\"comment\"># interrupt, ctrl + c 发出的信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGINT</span><br><span class=\"line\"><span class=\"comment\"># quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 终止进程; 2. 产生进程 core dump 文件;</span></span><br><span class=\"line\">SIGQUIT</span><br><span class=\"line\"><span class=\"comment\"># kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理</span></span><br><span class=\"line\"><span class=\"comment\"># 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用</span></span><br><span class=\"line\">SIGKILL</span><br><span class=\"line\"><span class=\"comment\"># hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session</span></span><br><span class=\"line\"><span class=\"comment\"># session 接收该信号并将其发送给子进程</span></span><br><span class=\"line\">SIGHUP</span><br></pre></td></tr></table></figure></p>\n<p>另外一篇详细梳理与 SIGHUP 相关知识点的链接: <a href=\"\">SIGHUP 相关全梳理</a>;<br>该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &amp;,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;</p>\n<h3 id=\"任务控制信号\"><a href=\"#任务控制信号\" class=\"headerlink\" title=\"任务控制信号\"></a><strong>任务控制信号</strong></h3><h3 id=\"其他信号\"><a href=\"#其他信号\" class=\"headerlink\" title=\"其他信号\"></a><strong>其他信号</strong></h3><p>其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;<br>&nbsp;<br>(1) 用户自定义信号: SIGUSR1 / SIGUSR2<br>这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;<br>SIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;<br>以下是 SIGUSR1 / SIGUSR2 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat /var/run/nginx.pid`</span><br><span class=\"line\"><span class=\"comment\"># 通知 nginx 平滑升级 二进制可执行程序</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -s SIGUSR2 `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;<br>以下是 SIGWINCH 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx worker process 不再接受新 request, 并从容关闭</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -WINCH `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals\" target=\"_blank\" rel=\"noopener\">24.2.2 Termination Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html\" target=\"_blank\" rel=\"noopener\">24.2.5 Job Control Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals\" target=\"_blank\" rel=\"noopener\">24.2.7 Miscellaneous Signals</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2\" target=\"_blank\" rel=\"noopener\">Difference between SIGUSR1 and SIGUSR2</a></li>\n<li><a href=\"http://blog.csdn.net/fuming0210sc/article/details/50906372\" target=\"_blank\" rel=\"noopener\">linux kill 命令 以及 USR1 信号 解释</a></li>\n<li><a href=\"http://blog.csdn.net/lisongjia123/article/details/50471854\" target=\"_blank\" rel=\"noopener\">Linux 信号入门详解</a></li>\n<li><a href=\"http://blog.csdn.net/yankai0219/article/details/8453261\" target=\"_blank\" rel=\"noopener\">文章3: Nginx中与信号有关的内容</a></li>\n</ul>"},{"title":"bash 数组与映射","date":"2017-10-22T15:32:19.000Z","_content":"\n> 注: bash 映射 (map) 在文档里叫做 `关联数组 (associated array)`, 使用关联数组的最低 bash 版本是 4.1.2;\n\n<!--more-->\n\n## **数组/关联数组 的创建**\n### **静态创建**\n使用类型限定 declare 定义:\n``` bash\n# 数组\ndeclare -a array1=('a' 'b' 'c')\ndeclare -a array2=(a b c)\n# 关联数组\ndeclare -A map1=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\ndeclare -A map2=([a]=aa [b]=bb [c]=cc)\n```\n如果不带类型限定, bash 不会自动推断 关联数组 类型:\n``` bash\nobject1=(a b c)\nobject2=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\n```\n对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [\"a\"]=\"aa\", [\"b\"]=\"bb\" 与 [\"c\"]=\"cc\";\n\n### **动态创建**\n以上展示了 数组/动态数组 的静态创建方式;\n更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:\n``` bash\npair_array=(`sed -n -e '6,/}/p' -e '$d' ${formatted_curl_response_file} | awk -F ':' '{\n    log_length = length($1);\n    app_code_length = length($2);\n    log_path = substr($1, 2, log_length - 2);\n    app_code = substr($2, 2, app_code_length - 2);\n    map[log_path] = app_code\n} END {\n    for (key in map) {\n        printf (\"%10s=%10s \", key, map[key])\n    }\n}'`)\n```\n以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;\n但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;\n&nbsp;\n另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:\n``` bash\n> declare -A map=(`last -n 1 | head -n 1 | awk '{map[$1]=$3} END{for (key in map) {printf (\"[%10s]=%10s \", key, map[key])}}'`)\n# 以上语句会报如下错误:\n-bash: map: [: must use subscript when assigning associative array\n-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array\n```\n因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;\n显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;\n\n## **数组/关联数组 的使用**\n单独赋值:\n``` bash\nmap['a']='aaa'\narray[0]=aaa\n```\n获取数据:\n``` bash\n# 获得所有 values\necho ${map[@]}\necho ${array[@]}\n# 获得某个单独的值\nvar=${map['a']}\nvar=${array[0]}\n# 获得所有 keys (对于数组而言, 就是获得所有的索引下标)\nfor key in ${!map[@]}; do\n    ...\ndone\nfor key in ${!array[@]}; do\n    ...\ndone\n```\n\n## **参考链接**\n- [shell中的map使用](http://blog.csdn.net/adermxl/article/details/41145019)\n\n","source":"_posts/linux-shell--bash数组与映射.md","raw":"---\ntitle: bash 数组与映射\ndate: 2017-10-22 23:32:19\ncategories:\n  - linux\n  - shell\ntags:\n  - linux:shell\n---\n\n> 注: bash 映射 (map) 在文档里叫做 `关联数组 (associated array)`, 使用关联数组的最低 bash 版本是 4.1.2;\n\n<!--more-->\n\n## **数组/关联数组 的创建**\n### **静态创建**\n使用类型限定 declare 定义:\n``` bash\n# 数组\ndeclare -a array1=('a' 'b' 'c')\ndeclare -a array2=(a b c)\n# 关联数组\ndeclare -A map1=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\ndeclare -A map2=([a]=aa [b]=bb [c]=cc)\n```\n如果不带类型限定, bash 不会自动推断 关联数组 类型:\n``` bash\nobject1=(a b c)\nobject2=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\n```\n对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [\"a\"]=\"aa\", [\"b\"]=\"bb\" 与 [\"c\"]=\"cc\";\n\n### **动态创建**\n以上展示了 数组/动态数组 的静态创建方式;\n更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:\n``` bash\npair_array=(`sed -n -e '6,/}/p' -e '$d' ${formatted_curl_response_file} | awk -F ':' '{\n    log_length = length($1);\n    app_code_length = length($2);\n    log_path = substr($1, 2, log_length - 2);\n    app_code = substr($2, 2, app_code_length - 2);\n    map[log_path] = app_code\n} END {\n    for (key in map) {\n        printf (\"%10s=%10s \", key, map[key])\n    }\n}'`)\n```\n以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;\n但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;\n&nbsp;\n另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:\n``` bash\n> declare -A map=(`last -n 1 | head -n 1 | awk '{map[$1]=$3} END{for (key in map) {printf (\"[%10s]=%10s \", key, map[key])}}'`)\n# 以上语句会报如下错误:\n-bash: map: [: must use subscript when assigning associative array\n-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array\n```\n因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;\n显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;\n\n## **数组/关联数组 的使用**\n单独赋值:\n``` bash\nmap['a']='aaa'\narray[0]=aaa\n```\n获取数据:\n``` bash\n# 获得所有 values\necho ${map[@]}\necho ${array[@]}\n# 获得某个单独的值\nvar=${map['a']}\nvar=${array[0]}\n# 获得所有 keys (对于数组而言, 就是获得所有的索引下标)\nfor key in ${!map[@]}; do\n    ...\ndone\nfor key in ${!array[@]}; do\n    ...\ndone\n```\n\n## **参考链接**\n- [shell中的map使用](http://blog.csdn.net/adermxl/article/details/41145019)\n\n","slug":"linux-shell--bash数组与映射","published":1,"updated":"2018-01-03T15:18:11.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1g000cfejxzeg1dqai","content":"<blockquote>\n<p>注: bash 映射 (map) 在文档里叫做 <code>关联数组 (associated array)</code>, 使用关联数组的最低 bash 版本是 4.1.2;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"数组-关联数组-的创建\"><a href=\"#数组-关联数组-的创建\" class=\"headerlink\" title=\"数组/关联数组 的创建\"></a><strong>数组/关联数组 的创建</strong></h2><h3 id=\"静态创建\"><a href=\"#静态创建\" class=\"headerlink\" title=\"静态创建\"></a><strong>静态创建</strong></h3><p>使用类型限定 declare 定义:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array1=(<span class=\"string\">'a'</span> <span class=\"string\">'b'</span> <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array2=(a b c)</span><br><span class=\"line\"><span class=\"comment\"># 关联数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map1=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map2=([a]=aa [b]=bb [c]=cc)</span><br></pre></td></tr></table></figure></p>\n<p>如果不带类型限定, bash 不会自动推断 关联数组 类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object1=(a b c)</span><br><span class=\"line\">object2=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [“a”]=”aa”, [“b”]=”bb” 与 [“c”]=”cc”;</p>\n<h3 id=\"动态创建\"><a href=\"#动态创建\" class=\"headerlink\" title=\"动态创建\"></a><strong>动态创建</strong></h3><p>以上展示了 数组/动态数组 的静态创建方式;<br>更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_array=(`sed -n -e <span class=\"string\">'6,/&#125;/p'</span> -e <span class=\"string\">'$d'</span> <span class=\"variable\">$&#123;formatted_curl_response_file&#125;</span> | awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_length = length($1);</span></span><br><span class=\"line\"><span class=\"string\">    app_code_length = length($2);</span></span><br><span class=\"line\"><span class=\"string\">    log_path = substr($1, 2, log_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    app_code = substr($2, 2, app_code_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    map[log_path] = app_code</span></span><br><span class=\"line\"><span class=\"string\">&#125; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">    for (key in map) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf (\"%10s=%10s \", key, map[key])</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span>`)</span><br></pre></td></tr></table></figure></p>\n<p>以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;<br>但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;<br>&nbsp;<br>另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">declare</span> -A map=(`last -n 1 | head -n 1 | awk <span class=\"string\">'&#123;map[$1]=$3&#125; END&#123;for (key in map) &#123;printf (\"[%10s]=%10s \", key, map[key])&#125;&#125;'</span>`)</span><br><span class=\"line\"><span class=\"comment\"># 以上语句会报如下错误:</span></span><br><span class=\"line\">-bash: map: [: must use subscript when assigning associative array</span><br><span class=\"line\">-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array</span><br></pre></td></tr></table></figure></p>\n<p>因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;<br>显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;</p>\n<h2 id=\"数组-关联数组-的使用\"><a href=\"#数组-关联数组-的使用\" class=\"headerlink\" title=\"数组/关联数组 的使用\"></a><strong>数组/关联数组 的使用</strong></h2><p>单独赋值:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[<span class=\"string\">'a'</span>]=<span class=\"string\">'aaa'</span></span><br><span class=\"line\">array[0]=aaa</span><br></pre></td></tr></table></figure></p>\n<p>获取数据:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获得所有 values</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;map[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[@]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得某个单独的值</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;map['a']&#125;</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得所有 keys (对于数组而言, 就是获得所有的索引下标)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!map[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!array[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/adermxl/article/details/41145019\" target=\"_blank\" rel=\"noopener\">shell中的map使用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>注: bash 映射 (map) 在文档里叫做 <code>关联数组 (associated array)</code>, 使用关联数组的最低 bash 版本是 4.1.2;</p>\n</blockquote>","more":"<h2 id=\"数组-关联数组-的创建\"><a href=\"#数组-关联数组-的创建\" class=\"headerlink\" title=\"数组/关联数组 的创建\"></a><strong>数组/关联数组 的创建</strong></h2><h3 id=\"静态创建\"><a href=\"#静态创建\" class=\"headerlink\" title=\"静态创建\"></a><strong>静态创建</strong></h3><p>使用类型限定 declare 定义:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array1=(<span class=\"string\">'a'</span> <span class=\"string\">'b'</span> <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array2=(a b c)</span><br><span class=\"line\"><span class=\"comment\"># 关联数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map1=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map2=([a]=aa [b]=bb [c]=cc)</span><br></pre></td></tr></table></figure></p>\n<p>如果不带类型限定, bash 不会自动推断 关联数组 类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object1=(a b c)</span><br><span class=\"line\">object2=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [“a”]=”aa”, [“b”]=”bb” 与 [“c”]=”cc”;</p>\n<h3 id=\"动态创建\"><a href=\"#动态创建\" class=\"headerlink\" title=\"动态创建\"></a><strong>动态创建</strong></h3><p>以上展示了 数组/动态数组 的静态创建方式;<br>更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_array=(`sed -n -e <span class=\"string\">'6,/&#125;/p'</span> -e <span class=\"string\">'$d'</span> <span class=\"variable\">$&#123;formatted_curl_response_file&#125;</span> | awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_length = length($1);</span></span><br><span class=\"line\"><span class=\"string\">    app_code_length = length($2);</span></span><br><span class=\"line\"><span class=\"string\">    log_path = substr($1, 2, log_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    app_code = substr($2, 2, app_code_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    map[log_path] = app_code</span></span><br><span class=\"line\"><span class=\"string\">&#125; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">    for (key in map) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf (\"%10s=%10s \", key, map[key])</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span>`)</span><br></pre></td></tr></table></figure></p>\n<p>以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;<br>但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;<br>&nbsp;<br>另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">declare</span> -A map=(`last -n 1 | head -n 1 | awk <span class=\"string\">'&#123;map[$1]=$3&#125; END&#123;for (key in map) &#123;printf (\"[%10s]=%10s \", key, map[key])&#125;&#125;'</span>`)</span><br><span class=\"line\"><span class=\"comment\"># 以上语句会报如下错误:</span></span><br><span class=\"line\">-bash: map: [: must use subscript when assigning associative array</span><br><span class=\"line\">-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array</span><br></pre></td></tr></table></figure></p>\n<p>因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;<br>显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;</p>\n<h2 id=\"数组-关联数组-的使用\"><a href=\"#数组-关联数组-的使用\" class=\"headerlink\" title=\"数组/关联数组 的使用\"></a><strong>数组/关联数组 的使用</strong></h2><p>单独赋值:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[<span class=\"string\">'a'</span>]=<span class=\"string\">'aaa'</span></span><br><span class=\"line\">array[0]=aaa</span><br></pre></td></tr></table></figure></p>\n<p>获取数据:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获得所有 values</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;map[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[@]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得某个单独的值</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;map['a']&#125;</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得所有 keys (对于数组而言, 就是获得所有的索引下标)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!map[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!array[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/adermxl/article/details/41145019\" target=\"_blank\" rel=\"noopener\">shell中的map使用</a></li>\n</ul>"},{"title":"bash 条件判断全梳理","date":"2016-09-01T09:52:36.000Z","_content":"\n> 本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)\n\n<!--more-->\n\n## **bash 条件判断 的类型与逻辑运算符**\n\n### **字符串比较**\n1. `=`同`==`, 相同为真;\n2. `!=`, 不相同为真;\n3. `-z`, 长度为0(空)为真;\n4. `-n`, 长度不为0(非空)为真;\n5. `<`, 按字典序小于为真;\n6. `>`, 按字典序大于为真;\n\n### **整数比较**\n1. `-eq`, equals, 相等为真;\n2. `-ne`, not equals, 不相等为真;\n3. `-gt`, greater than, 大于为真;\n4. `-ge`, greater equals, 大于等于为真;\n5. `-lt`, less than, 小于为真;\n6. `-le`, less equals, 小于等于为真;\n7. `>`, 大于;\n8. `>=`, 大于等于;\n9. `<`, 小于;\n10. `<=`, 小于等于;\n11. `==`, 等于;\n12. `!=`, 不等于;\n\n### **文件比较**\n1. `-e`, exists, 文件存在为真\n2. `-r`, read, 用户可读为真 \n3. `-w`, write, 用户可写为真 \n4. `-x`, execute, 用户可执行为真 \n5. `-f`, file, 文件为正规文件为真 \n6. `-d`, directory, 文件为目录为真\n7. `-L`, link, 文件为链接文件为真\n8. `-c`, char, 文件为字符特殊文件为真 \n9. `-b`, block, 文件为块特殊文件为真 \n10. `-s`, 文件大小非0时为真 \n11. `-t`, 当文件描述符(默认为1)指定的设备为终端时为真\n12. `-nt`, newer than, 更新时间更晚为真;\n13. `-ot`, older than, 更新时间更早为真;\n\n### **逻辑比较**\n1. `-a`, and, 逻辑与;\n2. `-o`, or, 逻辑或;\n3. `!`, 逻辑非;\n4. `&&`, 逻辑与( 支持短路 );\n5. `||`, 逻辑或( 支持短路 );\n\n&nbsp;\n## **bash 条件判断 的命令(关键字)与语法**\n\n### **test 与 [ ]**\n`test` 与 `[` 是 shell 的内置命令;\n`test` 和 `[]` 可以用于比较字符串, 整数, 文件, `test expr `与`[ expr ]`有等价的效果;\n\n#### **字符串比较**\n`test`可以使用`=`, `==`, `!=`比较, bash 4.1版本下也能使用`-n`, `-z`比较字符串( 旧版本可能不支持该方式 );\n`[]`可以使用上述全部的比较符号;\n```\nif !test $str1 == $str2; then ... ; fi\nif ! [ $str1 == $str2 ]; then ... ; fi\n```\n`test` 与 `[]` 也可以使用 `<` 和 `>` 作字符串比较; 但是有一点要注意, `test`和`[`是 shell 的内置命令, 使用 `<` 和 `>` 需要转义, 否则会被当成重定向; \n#### **整数比较**\n`test`和`[]`均可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符;\n使用`<`,`>`,`==`,`!=`虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;\n```\nif test $1 -le 0; then ... ; fi\nif [ $1 -le 0 ]; then ... ; fi\n```\n#### **文件比较**\n`test`和`[]`均可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n```\nif test -e /usr/local/localtime; then ... ; fi\nif [ -e /usr/local/localtime ]; then ... ; fi\n```\n#### **逻辑比较**\n`test`和`[]`只能使用`-a`, `-o`和`!`运算符, 但`-a`和`-o` 不支持逻辑短路;\n```\nif !test $str1 == $str2 -a -n $str3; then ... ; fi\nif [ $str1 == $str2 -a -n $str3 ]; then ... ; fi\n```\n#### **test的返回值**\n`test`可以独立于`if`使用, 其执行结果( 0为真, 1为假 )可以使用`$?`来接收;\n```\ntest -z \"$1\"; echo \"$?\"\n```\n\n### **bash关键字 [[ ]] ( 推荐使用 )**\n`[[` 是 bash 的关键字, 而不是命令;\n`[[ ]]` 比 `[]` 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 `[[ ]]`;\n\n#### **字符串比较**\n`[[ ]]` 除了可以使用基本的 `=`, `==`, `!=`, `-n`, `-z` 之外, 其 `=`,`==` 和 `!=`还有通配符模式匹配的功能:\n```\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" == t* ]]; then ... ; fi\n```\n`[[ ]]` 还可以使用支持正则表达式的 `=~` 运算符:\n```\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" =~ ^t[a-z].t$ ]]; then ... ; fi\n```\n`[[ ]]`也可以使用`<`和`>`作字符串比较; 由于`[[`是bash内置的关键字, `<`和`>`并不会被当成重定向, 所以可以不需要转义;\n#### **整数比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);\n#### **算术拓展**\n`[[]]`支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:\n```\nif [[ 1+1 -eq 2 ]]; then ... ; fi\n```\n此功能不推荐使用;\n#### **文件比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n#### **逻辑比较**\n`[[ ]]`只能使用`&&`, `||`, `!`运算符, 且`&&`和`||`支持逻辑短路;\n\n### **(( ))的使用场景**\n无论是`test`, `[]`还是`[[ ]]`, 都不能很好地使用`<`和`>`处理整数的比较运算;\n所以通常使用`(())`来处理整数的比较运算;\n`(())`可以使用`>`, `>=`, `<`, `<=`,`==`,`!=`运算符;\n```\nif (( 1 + 1 == 2 )); then ... ; fi\n```\n使用`(())`的时候, 如果使用到了变量, 可以不需要加上`$`符号;\n\n&nbsp;\n## **总结**\n\n|-           | test 与 [ ]                                           | [[ ]]                                               | (( ))                 |\n|:----------:|:----------------------------------------------------:|:----------------------------------------------------:|:---------------------:|\n| 字符串比较 | =, ==, !=, -n, -z, \\\\<, \\\\>                          | =, ==, !=, -n, -z, <, >                              | 不支持                |\n| 整数比较   | -eq, -gt, -ge, -lt, -le, -ne                         | -eq, -gt, -ge, -lt, -le, -ne                         | \\>, >=, <, <=, ==, != |\n| 文件比较   | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | 不支持                |\n| 逻辑比较   | -a, -o, !                                            | &&, \\|\\|, !                                          | &&, \\|\\|, !           |\n\n&nbsp;\n## **参考链接**\n","source":"_posts/linux-shell--bash条件判断全梳理.md","raw":"---\ntitle: bash 条件判断全梳理\ndate: 2016-09-01 17:52:36\ntags: \n  - linux:shell\ncategories:\n  - linux\n  - shell\n---\n\n> 本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)\n\n<!--more-->\n\n## **bash 条件判断 的类型与逻辑运算符**\n\n### **字符串比较**\n1. `=`同`==`, 相同为真;\n2. `!=`, 不相同为真;\n3. `-z`, 长度为0(空)为真;\n4. `-n`, 长度不为0(非空)为真;\n5. `<`, 按字典序小于为真;\n6. `>`, 按字典序大于为真;\n\n### **整数比较**\n1. `-eq`, equals, 相等为真;\n2. `-ne`, not equals, 不相等为真;\n3. `-gt`, greater than, 大于为真;\n4. `-ge`, greater equals, 大于等于为真;\n5. `-lt`, less than, 小于为真;\n6. `-le`, less equals, 小于等于为真;\n7. `>`, 大于;\n8. `>=`, 大于等于;\n9. `<`, 小于;\n10. `<=`, 小于等于;\n11. `==`, 等于;\n12. `!=`, 不等于;\n\n### **文件比较**\n1. `-e`, exists, 文件存在为真\n2. `-r`, read, 用户可读为真 \n3. `-w`, write, 用户可写为真 \n4. `-x`, execute, 用户可执行为真 \n5. `-f`, file, 文件为正规文件为真 \n6. `-d`, directory, 文件为目录为真\n7. `-L`, link, 文件为链接文件为真\n8. `-c`, char, 文件为字符特殊文件为真 \n9. `-b`, block, 文件为块特殊文件为真 \n10. `-s`, 文件大小非0时为真 \n11. `-t`, 当文件描述符(默认为1)指定的设备为终端时为真\n12. `-nt`, newer than, 更新时间更晚为真;\n13. `-ot`, older than, 更新时间更早为真;\n\n### **逻辑比较**\n1. `-a`, and, 逻辑与;\n2. `-o`, or, 逻辑或;\n3. `!`, 逻辑非;\n4. `&&`, 逻辑与( 支持短路 );\n5. `||`, 逻辑或( 支持短路 );\n\n&nbsp;\n## **bash 条件判断 的命令(关键字)与语法**\n\n### **test 与 [ ]**\n`test` 与 `[` 是 shell 的内置命令;\n`test` 和 `[]` 可以用于比较字符串, 整数, 文件, `test expr `与`[ expr ]`有等价的效果;\n\n#### **字符串比较**\n`test`可以使用`=`, `==`, `!=`比较, bash 4.1版本下也能使用`-n`, `-z`比较字符串( 旧版本可能不支持该方式 );\n`[]`可以使用上述全部的比较符号;\n```\nif !test $str1 == $str2; then ... ; fi\nif ! [ $str1 == $str2 ]; then ... ; fi\n```\n`test` 与 `[]` 也可以使用 `<` 和 `>` 作字符串比较; 但是有一点要注意, `test`和`[`是 shell 的内置命令, 使用 `<` 和 `>` 需要转义, 否则会被当成重定向; \n#### **整数比较**\n`test`和`[]`均可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符;\n使用`<`,`>`,`==`,`!=`虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;\n```\nif test $1 -le 0; then ... ; fi\nif [ $1 -le 0 ]; then ... ; fi\n```\n#### **文件比较**\n`test`和`[]`均可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n```\nif test -e /usr/local/localtime; then ... ; fi\nif [ -e /usr/local/localtime ]; then ... ; fi\n```\n#### **逻辑比较**\n`test`和`[]`只能使用`-a`, `-o`和`!`运算符, 但`-a`和`-o` 不支持逻辑短路;\n```\nif !test $str1 == $str2 -a -n $str3; then ... ; fi\nif [ $str1 == $str2 -a -n $str3 ]; then ... ; fi\n```\n#### **test的返回值**\n`test`可以独立于`if`使用, 其执行结果( 0为真, 1为假 )可以使用`$?`来接收;\n```\ntest -z \"$1\"; echo \"$?\"\n```\n\n### **bash关键字 [[ ]] ( 推荐使用 )**\n`[[` 是 bash 的关键字, 而不是命令;\n`[[ ]]` 比 `[]` 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 `[[ ]]`;\n\n#### **字符串比较**\n`[[ ]]` 除了可以使用基本的 `=`, `==`, `!=`, `-n`, `-z` 之外, 其 `=`,`==` 和 `!=`还有通配符模式匹配的功能:\n```\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" == t* ]]; then ... ; fi\n```\n`[[ ]]` 还可以使用支持正则表达式的 `=~` 运算符:\n```\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" =~ ^t[a-z].t$ ]]; then ... ; fi\n```\n`[[ ]]`也可以使用`<`和`>`作字符串比较; 由于`[[`是bash内置的关键字, `<`和`>`并不会被当成重定向, 所以可以不需要转义;\n#### **整数比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);\n#### **算术拓展**\n`[[]]`支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:\n```\nif [[ 1+1 -eq 2 ]]; then ... ; fi\n```\n此功能不推荐使用;\n#### **文件比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n#### **逻辑比较**\n`[[ ]]`只能使用`&&`, `||`, `!`运算符, 且`&&`和`||`支持逻辑短路;\n\n### **(( ))的使用场景**\n无论是`test`, `[]`还是`[[ ]]`, 都不能很好地使用`<`和`>`处理整数的比较运算;\n所以通常使用`(())`来处理整数的比较运算;\n`(())`可以使用`>`, `>=`, `<`, `<=`,`==`,`!=`运算符;\n```\nif (( 1 + 1 == 2 )); then ... ; fi\n```\n使用`(())`的时候, 如果使用到了变量, 可以不需要加上`$`符号;\n\n&nbsp;\n## **总结**\n\n|-           | test 与 [ ]                                           | [[ ]]                                               | (( ))                 |\n|:----------:|:----------------------------------------------------:|:----------------------------------------------------:|:---------------------:|\n| 字符串比较 | =, ==, !=, -n, -z, \\\\<, \\\\>                          | =, ==, !=, -n, -z, <, >                              | 不支持                |\n| 整数比较   | -eq, -gt, -ge, -lt, -le, -ne                         | -eq, -gt, -ge, -lt, -le, -ne                         | \\>, >=, <, <=, ==, != |\n| 文件比较   | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | 不支持                |\n| 逻辑比较   | -a, -o, !                                            | &&, \\|\\|, !                                          | &&, \\|\\|, !           |\n\n&nbsp;\n## **参考链接**\n","slug":"linux-shell--bash条件判断全梳理","published":1,"updated":"2018-01-02T15:40:57.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1i000dfejxsl708nfc","content":"<blockquote>\n<p>本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"bash-条件判断-的类型与逻辑运算符\"><a href=\"#bash-条件判断-的类型与逻辑运算符\" class=\"headerlink\" title=\"bash 条件判断 的类型与逻辑运算符\"></a><strong>bash 条件判断 的类型与逻辑运算符</strong></h2><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h3><ol>\n<li><code>=</code>同<code>==</code>, 相同为真;</li>\n<li><code>!=</code>, 不相同为真;</li>\n<li><code>-z</code>, 长度为0(空)为真;</li>\n<li><code>-n</code>, 长度不为0(非空)为真;</li>\n<li><code>&lt;</code>, 按字典序小于为真;</li>\n<li><code>&gt;</code>, 按字典序大于为真;</li>\n</ol>\n<h3 id=\"整数比较\"><a href=\"#整数比较\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h3><ol>\n<li><code>-eq</code>, equals, 相等为真;</li>\n<li><code>-ne</code>, not equals, 不相等为真;</li>\n<li><code>-gt</code>, greater than, 大于为真;</li>\n<li><code>-ge</code>, greater equals, 大于等于为真;</li>\n<li><code>-lt</code>, less than, 小于为真;</li>\n<li><code>-le</code>, less equals, 小于等于为真;</li>\n<li><code>&gt;</code>, 大于;</li>\n<li><code>&gt;=</code>, 大于等于;</li>\n<li><code>&lt;</code>, 小于;</li>\n<li><code>&lt;=</code>, 小于等于;</li>\n<li><code>==</code>, 等于;</li>\n<li><code>!=</code>, 不等于;</li>\n</ol>\n<h3 id=\"文件比较\"><a href=\"#文件比较\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h3><ol>\n<li><code>-e</code>, exists, 文件存在为真</li>\n<li><code>-r</code>, read, 用户可读为真 </li>\n<li><code>-w</code>, write, 用户可写为真 </li>\n<li><code>-x</code>, execute, 用户可执行为真 </li>\n<li><code>-f</code>, file, 文件为正规文件为真 </li>\n<li><code>-d</code>, directory, 文件为目录为真</li>\n<li><code>-L</code>, link, 文件为链接文件为真</li>\n<li><code>-c</code>, char, 文件为字符特殊文件为真 </li>\n<li><code>-b</code>, block, 文件为块特殊文件为真 </li>\n<li><code>-s</code>, 文件大小非0时为真 </li>\n<li><code>-t</code>, 当文件描述符(默认为1)指定的设备为终端时为真</li>\n<li><code>-nt</code>, newer than, 更新时间更晚为真;</li>\n<li><code>-ot</code>, older than, 更新时间更早为真;</li>\n</ol>\n<h3 id=\"逻辑比较\"><a href=\"#逻辑比较\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h3><ol>\n<li><code>-a</code>, and, 逻辑与;</li>\n<li><code>-o</code>, or, 逻辑或;</li>\n<li><code>!</code>, 逻辑非;</li>\n<li><code>&amp;&amp;</code>, 逻辑与( 支持短路 );</li>\n<li><code>||</code>, 逻辑或( 支持短路 );</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"bash-条件判断-的命令-关键字-与语法\"><a href=\"#bash-条件判断-的命令-关键字-与语法\" class=\"headerlink\" title=\"bash 条件判断 的命令(关键字)与语法\"></a><strong>bash 条件判断 的命令(关键字)与语法</strong></h2><h3 id=\"test-与\"><a href=\"#test-与\" class=\"headerlink\" title=\"test 与 [ ]\"></a><strong>test 与 [ ]</strong></h3><p><code>test</code> 与 <code>[</code> 是 shell 的内置命令;<br><code>test</code> 和 <code>[]</code> 可以用于比较字符串, 整数, 文件, <code>test expr</code>与<code>[ expr ]</code>有等价的效果;</p>\n<h4 id=\"字符串比较-1\"><a href=\"#字符串比较-1\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>test</code>可以使用<code>=</code>, <code>==</code>, <code>!=</code>比较, bash 4.1版本下也能使用<code>-n</code>, <code>-z</code>比较字符串( 旧版本可能不支持该方式 );<br><code>[]</code>可以使用上述全部的比较符号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if !test $str1 == $str2; then ... ; fi</span><br><span class=\"line\">if ! [ $str1 == $str2 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>test</code> 与 <code>[]</code> 也可以使用 <code>&lt;</code> 和 <code>&gt;</code> 作字符串比较; 但是有一点要注意, <code>test</code>和<code>[</code>是 shell 的内置命令, 使用 <code>&lt;</code> 和 <code>&gt;</code> 需要转义, 否则会被当成重定向; </p>\n<h4 id=\"整数比较-1\"><a href=\"#整数比较-1\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符;<br>使用<code>&lt;</code>,<code>&gt;</code>,<code>==</code>,<code>!=</code>虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if test $1 -le 0; then ... ; fi</span><br><span class=\"line\">if [ $1 -le 0 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件比较-1\"><a href=\"#文件比较-1\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if test -e /usr/local/localtime; then ... ; fi</span><br><span class=\"line\">if [ -e /usr/local/localtime ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"逻辑比较-1\"><a href=\"#逻辑比较-1\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>test</code>和<code>[]</code>只能使用<code>-a</code>, <code>-o</code>和<code>!</code>运算符, 但<code>-a</code>和<code>-o</code> 不支持逻辑短路;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if !test $str1 == $str2 -a -n $str3; then ... ; fi</span><br><span class=\"line\">if [ $str1 == $str2 -a -n $str3 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"test的返回值\"><a href=\"#test的返回值\" class=\"headerlink\" title=\"test的返回值\"></a><strong>test的返回值</strong></h4><p><code>test</code>可以独立于<code>if</code>使用, 其执行结果( 0为真, 1为假 )可以使用<code>$?</code>来接收;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test -z &quot;$1&quot;; echo &quot;$?&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash关键字-推荐使用\"><a href=\"#bash关键字-推荐使用\" class=\"headerlink\" title=\"bash关键字 [[ ]] ( 推荐使用 )\"></a><strong>bash关键字 [[ ]] ( 推荐使用 )</strong></h3><p><code>[[</code> 是 bash 的关键字, 而不是命令;<br><code>[[ ]]</code> 比 <code>[]</code> 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 <code>[[ ]]</code>;</p>\n<h4 id=\"字符串比较-2\"><a href=\"#字符串比较-2\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>[[ ]]</code> 除了可以使用基本的 <code>=</code>, <code>==</code>, <code>!=</code>, <code>-n</code>, <code>-z</code> 之外, 其 <code>=</code>,<code>==</code> 和 <code>!=</code>还有通配符模式匹配的功能:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 模式串不能加双引号, 否则会被当作普通串</span><br><span class=\"line\">if [[ &quot;test&quot; == t* ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code> 还可以使用支持正则表达式的 <code>=~</code> 运算符:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 模式串不能加双引号, 否则会被当作普通串</span><br><span class=\"line\">if [[ &quot;test&quot; =~ ^t[a-z].t$ ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code>也可以使用<code>&lt;</code>和<code>&gt;</code>作字符串比较; 由于<code>[[</code>是bash内置的关键字, <code>&lt;</code>和<code>&gt;</code>并不会被当成重定向, 所以可以不需要转义;</p>\n<h4 id=\"整数比较-2\"><a href=\"#整数比较-2\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);</p>\n<h4 id=\"算术拓展\"><a href=\"#算术拓展\" class=\"headerlink\" title=\"算术拓展\"></a><strong>算术拓展</strong></h4><p><code>[[]]</code>支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [[ 1+1 -eq 2 ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p>此功能不推荐使用;</p>\n<h4 id=\"文件比较-2\"><a href=\"#文件比较-2\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;</p>\n<h4 id=\"逻辑比较-2\"><a href=\"#逻辑比较-2\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>[[ ]]</code>只能使用<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>运算符, 且<code>&amp;&amp;</code>和<code>||</code>支持逻辑短路;</p>\n<h3 id=\"的使用场景\"><a href=\"#的使用场景\" class=\"headerlink\" title=\"(( ))的使用场景\"></a><strong>(( ))的使用场景</strong></h3><p>无论是<code>test</code>, <code>[]</code>还是<code>[[ ]]</code>, 都不能很好地使用<code>&lt;</code>和<code>&gt;</code>处理整数的比较运算;<br>所以通常使用<code>(())</code>来处理整数的比较运算;<br><code>(())</code>可以使用<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code>运算符;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (( 1 + 1 == 2 )); then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>(())</code>的时候, 如果使用到了变量, 可以不需要加上<code>$</code>符号;</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">-</th>\n<th style=\"text-align:center\">test 与 [ ]</th>\n<th style=\"text-align:center\">[[ ]]</th>\n<th style=\"text-align:center\">(( ))</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">字符串比较</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, \\&lt;, \\&gt;</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, &lt;, &gt;</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">整数比较</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">>, &gt;=, &lt;, &lt;=, ==, !=</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文件比较</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">逻辑比较</td>\n<td style=\"text-align:center\">-a, -o, !</td>\n<td style=\"text-align:center\">&amp;&amp;, \\</td>\n<td style=\"text-align:center\">\\</td>\n<td>, !</td>\n<td>&amp;&amp;, \\</td>\n<td>\\</td>\n<td>, !</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2>","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)</p>\n</blockquote>","more":"<h2 id=\"bash-条件判断-的类型与逻辑运算符\"><a href=\"#bash-条件判断-的类型与逻辑运算符\" class=\"headerlink\" title=\"bash 条件判断 的类型与逻辑运算符\"></a><strong>bash 条件判断 的类型与逻辑运算符</strong></h2><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h3><ol>\n<li><code>=</code>同<code>==</code>, 相同为真;</li>\n<li><code>!=</code>, 不相同为真;</li>\n<li><code>-z</code>, 长度为0(空)为真;</li>\n<li><code>-n</code>, 长度不为0(非空)为真;</li>\n<li><code>&lt;</code>, 按字典序小于为真;</li>\n<li><code>&gt;</code>, 按字典序大于为真;</li>\n</ol>\n<h3 id=\"整数比较\"><a href=\"#整数比较\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h3><ol>\n<li><code>-eq</code>, equals, 相等为真;</li>\n<li><code>-ne</code>, not equals, 不相等为真;</li>\n<li><code>-gt</code>, greater than, 大于为真;</li>\n<li><code>-ge</code>, greater equals, 大于等于为真;</li>\n<li><code>-lt</code>, less than, 小于为真;</li>\n<li><code>-le</code>, less equals, 小于等于为真;</li>\n<li><code>&gt;</code>, 大于;</li>\n<li><code>&gt;=</code>, 大于等于;</li>\n<li><code>&lt;</code>, 小于;</li>\n<li><code>&lt;=</code>, 小于等于;</li>\n<li><code>==</code>, 等于;</li>\n<li><code>!=</code>, 不等于;</li>\n</ol>\n<h3 id=\"文件比较\"><a href=\"#文件比较\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h3><ol>\n<li><code>-e</code>, exists, 文件存在为真</li>\n<li><code>-r</code>, read, 用户可读为真 </li>\n<li><code>-w</code>, write, 用户可写为真 </li>\n<li><code>-x</code>, execute, 用户可执行为真 </li>\n<li><code>-f</code>, file, 文件为正规文件为真 </li>\n<li><code>-d</code>, directory, 文件为目录为真</li>\n<li><code>-L</code>, link, 文件为链接文件为真</li>\n<li><code>-c</code>, char, 文件为字符特殊文件为真 </li>\n<li><code>-b</code>, block, 文件为块特殊文件为真 </li>\n<li><code>-s</code>, 文件大小非0时为真 </li>\n<li><code>-t</code>, 当文件描述符(默认为1)指定的设备为终端时为真</li>\n<li><code>-nt</code>, newer than, 更新时间更晚为真;</li>\n<li><code>-ot</code>, older than, 更新时间更早为真;</li>\n</ol>\n<h3 id=\"逻辑比较\"><a href=\"#逻辑比较\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h3><ol>\n<li><code>-a</code>, and, 逻辑与;</li>\n<li><code>-o</code>, or, 逻辑或;</li>\n<li><code>!</code>, 逻辑非;</li>\n<li><code>&amp;&amp;</code>, 逻辑与( 支持短路 );</li>\n<li><code>||</code>, 逻辑或( 支持短路 );</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"bash-条件判断-的命令-关键字-与语法\"><a href=\"#bash-条件判断-的命令-关键字-与语法\" class=\"headerlink\" title=\"bash 条件判断 的命令(关键字)与语法\"></a><strong>bash 条件判断 的命令(关键字)与语法</strong></h2><h3 id=\"test-与\"><a href=\"#test-与\" class=\"headerlink\" title=\"test 与 [ ]\"></a><strong>test 与 [ ]</strong></h3><p><code>test</code> 与 <code>[</code> 是 shell 的内置命令;<br><code>test</code> 和 <code>[]</code> 可以用于比较字符串, 整数, 文件, <code>test expr</code>与<code>[ expr ]</code>有等价的效果;</p>\n<h4 id=\"字符串比较-1\"><a href=\"#字符串比较-1\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>test</code>可以使用<code>=</code>, <code>==</code>, <code>!=</code>比较, bash 4.1版本下也能使用<code>-n</code>, <code>-z</code>比较字符串( 旧版本可能不支持该方式 );<br><code>[]</code>可以使用上述全部的比较符号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if !test $str1 == $str2; then ... ; fi</span><br><span class=\"line\">if ! [ $str1 == $str2 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>test</code> 与 <code>[]</code> 也可以使用 <code>&lt;</code> 和 <code>&gt;</code> 作字符串比较; 但是有一点要注意, <code>test</code>和<code>[</code>是 shell 的内置命令, 使用 <code>&lt;</code> 和 <code>&gt;</code> 需要转义, 否则会被当成重定向; </p>\n<h4 id=\"整数比较-1\"><a href=\"#整数比较-1\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符;<br>使用<code>&lt;</code>,<code>&gt;</code>,<code>==</code>,<code>!=</code>虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if test $1 -le 0; then ... ; fi</span><br><span class=\"line\">if [ $1 -le 0 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件比较-1\"><a href=\"#文件比较-1\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if test -e /usr/local/localtime; then ... ; fi</span><br><span class=\"line\">if [ -e /usr/local/localtime ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"逻辑比较-1\"><a href=\"#逻辑比较-1\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>test</code>和<code>[]</code>只能使用<code>-a</code>, <code>-o</code>和<code>!</code>运算符, 但<code>-a</code>和<code>-o</code> 不支持逻辑短路;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if !test $str1 == $str2 -a -n $str3; then ... ; fi</span><br><span class=\"line\">if [ $str1 == $str2 -a -n $str3 ]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"test的返回值\"><a href=\"#test的返回值\" class=\"headerlink\" title=\"test的返回值\"></a><strong>test的返回值</strong></h4><p><code>test</code>可以独立于<code>if</code>使用, 其执行结果( 0为真, 1为假 )可以使用<code>$?</code>来接收;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test -z &quot;$1&quot;; echo &quot;$?&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash关键字-推荐使用\"><a href=\"#bash关键字-推荐使用\" class=\"headerlink\" title=\"bash关键字 [[ ]] ( 推荐使用 )\"></a><strong>bash关键字 [[ ]] ( 推荐使用 )</strong></h3><p><code>[[</code> 是 bash 的关键字, 而不是命令;<br><code>[[ ]]</code> 比 <code>[]</code> 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 <code>[[ ]]</code>;</p>\n<h4 id=\"字符串比较-2\"><a href=\"#字符串比较-2\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>[[ ]]</code> 除了可以使用基本的 <code>=</code>, <code>==</code>, <code>!=</code>, <code>-n</code>, <code>-z</code> 之外, 其 <code>=</code>,<code>==</code> 和 <code>!=</code>还有通配符模式匹配的功能:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 模式串不能加双引号, 否则会被当作普通串</span><br><span class=\"line\">if [[ &quot;test&quot; == t* ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code> 还可以使用支持正则表达式的 <code>=~</code> 运算符:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 模式串不能加双引号, 否则会被当作普通串</span><br><span class=\"line\">if [[ &quot;test&quot; =~ ^t[a-z].t$ ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code>也可以使用<code>&lt;</code>和<code>&gt;</code>作字符串比较; 由于<code>[[</code>是bash内置的关键字, <code>&lt;</code>和<code>&gt;</code>并不会被当成重定向, 所以可以不需要转义;</p>\n<h4 id=\"整数比较-2\"><a href=\"#整数比较-2\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);</p>\n<h4 id=\"算术拓展\"><a href=\"#算术拓展\" class=\"headerlink\" title=\"算术拓展\"></a><strong>算术拓展</strong></h4><p><code>[[]]</code>支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [[ 1+1 -eq 2 ]]; then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p>此功能不推荐使用;</p>\n<h4 id=\"文件比较-2\"><a href=\"#文件比较-2\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;</p>\n<h4 id=\"逻辑比较-2\"><a href=\"#逻辑比较-2\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>[[ ]]</code>只能使用<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>运算符, 且<code>&amp;&amp;</code>和<code>||</code>支持逻辑短路;</p>\n<h3 id=\"的使用场景\"><a href=\"#的使用场景\" class=\"headerlink\" title=\"(( ))的使用场景\"></a><strong>(( ))的使用场景</strong></h3><p>无论是<code>test</code>, <code>[]</code>还是<code>[[ ]]</code>, 都不能很好地使用<code>&lt;</code>和<code>&gt;</code>处理整数的比较运算;<br>所以通常使用<code>(())</code>来处理整数的比较运算;<br><code>(())</code>可以使用<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code>运算符;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (( 1 + 1 == 2 )); then ... ; fi</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>(())</code>的时候, 如果使用到了变量, 可以不需要加上<code>$</code>符号;</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">-</th>\n<th style=\"text-align:center\">test 与 [ ]</th>\n<th style=\"text-align:center\">[[ ]]</th>\n<th style=\"text-align:center\">(( ))</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">字符串比较</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, \\&lt;, \\&gt;</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, &lt;, &gt;</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">整数比较</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">>, &gt;=, &lt;, &lt;=, ==, !=</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文件比较</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">逻辑比较</td>\n<td style=\"text-align:center\">-a, -o, !</td>\n<td style=\"text-align:center\">&amp;&amp;, \\</td>\n<td style=\"text-align:center\">\\</td>\n<td>, !</td>\n<td>&amp;&amp;, \\</td>\n<td>\\</td>\n<td>, !</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2>"},{"title":"bash 结束死循环的方法","date":"2017-11-04T16:00:00.000Z","_content":"\n> linux 中有很多实用的工具, 采用了这样一种工作方式:\n定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;\n类似的工具包括 ioutil, jmap 等;\n本文整理了实现上述逻辑的一些典型方法;\n\n<!--more-->\n\n### **方法1: 监听命令返回值**\n根据 [GNU 相关规范](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status), 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;\n那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;\n```\nwhile [ 1 ]; do\n    COMMAND\n    test $? -gt 128 && break\ndone\n```\n更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:\n```\n# SIGINT = 2, 128 + SIGINT = 130\ntest $? -eq 130 && break\n```\n特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:\n```\nwhile [ 1 ]; do\n    COMMAND -e\n    test $? -gt 128 && break\ndone\n```\n\n### **方法2: 命令返回值短路**\n方法2 是方法1 的简化版本:\n```\nwhile [ 1 ]; do\n    COMMAND -e || break\ndone\n```\n其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;\n这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;\n这是方法2 相比 方法1 略显不精准的地方;\n\n### **方法3: 使用 trap 捕获信号**\n\n```\n# 捕获到 SIGINT 即 exit 0 正常退出\ntrap \"exit 0\" SIGINT\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n### **方法4: 使用 ctrl + z 配合 SIGTERM 信号**\n当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:\n``` bash\n# ^Z\n[1]+  Stopped                 COMMAND\n\n# 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号\nkill %1\n# 发送 SIGTERM 信号给最近一次被挂起的进程\nkill %%\n\n# 执行的结果\n[1]+ Terminated               COMMAND\n```\n\n### **方法5: 使用 -e 选项**\n使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;\n```\n#!/bin/bash\nset -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n或者作为 bash 的参数:\n```\n#!/bin/bash -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n\n### **参考链接**\n- [Terminating an infinite loop](https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop)\n- [3.7.5 Exit Status](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status)\n- [How to stop the loop bash script in terminal](https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465)\n- [Unix/Linux 脚本中 “set -e” 的作用](http://blog.csdn.net/todd911/article/details/9954961)\n\n","source":"_posts/linux-shell--bash结束死循环的方法.md","raw":"---\ntitle: bash 结束死循环的方法\ndate: 2017-11-05\ntags:\n  - linux:shell\ncategories:\n  - linux\n  - shell\n---\n\n> linux 中有很多实用的工具, 采用了这样一种工作方式:\n定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;\n类似的工具包括 ioutil, jmap 等;\n本文整理了实现上述逻辑的一些典型方法;\n\n<!--more-->\n\n### **方法1: 监听命令返回值**\n根据 [GNU 相关规范](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status), 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;\n那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;\n```\nwhile [ 1 ]; do\n    COMMAND\n    test $? -gt 128 && break\ndone\n```\n更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:\n```\n# SIGINT = 2, 128 + SIGINT = 130\ntest $? -eq 130 && break\n```\n特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:\n```\nwhile [ 1 ]; do\n    COMMAND -e\n    test $? -gt 128 && break\ndone\n```\n\n### **方法2: 命令返回值短路**\n方法2 是方法1 的简化版本:\n```\nwhile [ 1 ]; do\n    COMMAND -e || break\ndone\n```\n其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;\n这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;\n这是方法2 相比 方法1 略显不精准的地方;\n\n### **方法3: 使用 trap 捕获信号**\n\n```\n# 捕获到 SIGINT 即 exit 0 正常退出\ntrap \"exit 0\" SIGINT\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n### **方法4: 使用 ctrl + z 配合 SIGTERM 信号**\n当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:\n``` bash\n# ^Z\n[1]+  Stopped                 COMMAND\n\n# 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号\nkill %1\n# 发送 SIGTERM 信号给最近一次被挂起的进程\nkill %%\n\n# 执行的结果\n[1]+ Terminated               COMMAND\n```\n\n### **方法5: 使用 -e 选项**\n使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;\n```\n#!/bin/bash\nset -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n或者作为 bash 的参数:\n```\n#!/bin/bash -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n\n### **参考链接**\n- [Terminating an infinite loop](https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop)\n- [3.7.5 Exit Status](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status)\n- [How to stop the loop bash script in terminal](https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465)\n- [Unix/Linux 脚本中 “set -e” 的作用](http://blog.csdn.net/todd911/article/details/9954961)\n\n","slug":"linux-shell--bash结束死循环的方法","published":1,"updated":"2018-01-02T15:41:21.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1n000gfejxuhhi7ywt","content":"<blockquote>\n<p>linux 中有很多实用的工具, 采用了这样一种工作方式:<br>定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;<br>类似的工具包括 ioutil, jmap 等;<br>本文整理了实现上述逻辑的一些典型方法;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"方法1-监听命令返回值\"><a href=\"#方法1-监听命令返回值\" class=\"headerlink\" title=\"方法1: 监听命令返回值\"></a><strong>方法1: 监听命令返回值</strong></h3><p>根据 <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">GNU 相关规范</a>, 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;<br>那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIGINT = 2, 128 + SIGINT = 130</span><br><span class=\"line\">test $? -eq 130 &amp;&amp; break</span><br></pre></td></tr></table></figure></p>\n<p>特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2-命令返回值短路\"><a href=\"#方法2-命令返回值短路\" class=\"headerlink\" title=\"方法2: 命令返回值短路\"></a><strong>方法2: 命令返回值短路</strong></h3><p>方法2 是方法1 的简化版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e || break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;<br>这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;<br>这是方法2 相比 方法1 略显不精准的地方;</p>\n<h3 id=\"方法3-使用-trap-捕获信号\"><a href=\"#方法3-使用-trap-捕获信号\" class=\"headerlink\" title=\"方法3: 使用 trap 捕获信号\"></a><strong>方法3: 使用 trap 捕获信号</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 捕获到 SIGINT 即 exit 0 正常退出</span><br><span class=\"line\">trap &quot;exit 0&quot; SIGINT</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法4-使用-ctrl-z-配合-SIGTERM-信号\"><a href=\"#方法4-使用-ctrl-z-配合-SIGTERM-信号\" class=\"headerlink\" title=\"方法4: 使用 ctrl + z 配合 SIGTERM 信号\"></a><strong>方法4: 使用 ctrl + z 配合 SIGTERM 信号</strong></h3><p>当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ^Z</span></span><br><span class=\"line\">[1]+  Stopped                 COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGTERM 信号给最近一次被挂起的进程</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行的结果</span></span><br><span class=\"line\">[1]+ Terminated               COMMAND</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法5-使用-e-选项\"><a href=\"#方法5-使用-e-选项\" class=\"headerlink\" title=\"方法5: 使用 -e 选项\"></a><strong>方法5: 使用 -e 选项</strong></h3><p>使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">set -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>或者作为 bash 的参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Terminating an infinite loop</a></li>\n<li><a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">3.7.5 Exit Status</a></li>\n<li><a href=\"https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465\" target=\"_blank\" rel=\"noopener\">How to stop the loop bash script in terminal</a></li>\n<li><a href=\"http://blog.csdn.net/todd911/article/details/9954961\" target=\"_blank\" rel=\"noopener\">Unix/Linux 脚本中 “set -e” 的作用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>linux 中有很多实用的工具, 采用了这样一种工作方式:<br>定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;<br>类似的工具包括 ioutil, jmap 等;<br>本文整理了实现上述逻辑的一些典型方法;</p>\n</blockquote>","more":"<h3 id=\"方法1-监听命令返回值\"><a href=\"#方法1-监听命令返回值\" class=\"headerlink\" title=\"方法1: 监听命令返回值\"></a><strong>方法1: 监听命令返回值</strong></h3><p>根据 <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">GNU 相关规范</a>, 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;<br>那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIGINT = 2, 128 + SIGINT = 130</span><br><span class=\"line\">test $? -eq 130 &amp;&amp; break</span><br></pre></td></tr></table></figure></p>\n<p>特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2-命令返回值短路\"><a href=\"#方法2-命令返回值短路\" class=\"headerlink\" title=\"方法2: 命令返回值短路\"></a><strong>方法2: 命令返回值短路</strong></h3><p>方法2 是方法1 的简化版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e || break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;<br>这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;<br>这是方法2 相比 方法1 略显不精准的地方;</p>\n<h3 id=\"方法3-使用-trap-捕获信号\"><a href=\"#方法3-使用-trap-捕获信号\" class=\"headerlink\" title=\"方法3: 使用 trap 捕获信号\"></a><strong>方法3: 使用 trap 捕获信号</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 捕获到 SIGINT 即 exit 0 正常退出</span><br><span class=\"line\">trap &quot;exit 0&quot; SIGINT</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法4-使用-ctrl-z-配合-SIGTERM-信号\"><a href=\"#方法4-使用-ctrl-z-配合-SIGTERM-信号\" class=\"headerlink\" title=\"方法4: 使用 ctrl + z 配合 SIGTERM 信号\"></a><strong>方法4: 使用 ctrl + z 配合 SIGTERM 信号</strong></h3><p>当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ^Z</span></span><br><span class=\"line\">[1]+  Stopped                 COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGTERM 信号给最近一次被挂起的进程</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行的结果</span></span><br><span class=\"line\">[1]+ Terminated               COMMAND</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法5-使用-e-选项\"><a href=\"#方法5-使用-e-选项\" class=\"headerlink\" title=\"方法5: 使用 -e 选项\"></a><strong>方法5: 使用 -e 选项</strong></h3><p>使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">set -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>或者作为 bash 的参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Terminating an infinite loop</a></li>\n<li><a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">3.7.5 Exit Status</a></li>\n<li><a href=\"https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465\" target=\"_blank\" rel=\"noopener\">How to stop the loop bash script in terminal</a></li>\n<li><a href=\"http://blog.csdn.net/todd911/article/details/9954961\" target=\"_blank\" rel=\"noopener\">Unix/Linux 脚本中 “set -e” 的作用</a></li>\n</ul>"},{"title":"sed 命令整理","date":"2016-11-04T14:56:47.000Z","_content":"\n> stream editor: 流式文本编辑器;\nsed 命令的侧重点在于对文本的编辑;\n\n<!--more-->\n\n### **sed 的基本模式**\n``` bash\n# 标准模式: 选项, 目标行范围, 命令\nsed  [-nefri] '[target line]command' $file_path\n# 正则模式: 选项, 正则匹配式, 命令\nsed  [-nefri] '/regex/command' $file_path\n# 混合模式: 选项, 目标行与正则式组合范围, 命令\nsed [-nefri] 'line,/regex/command' $file_path\n```\n### **sed 的常用选项**\n``` bash\n1. -n:  silent 静默模式, 只输出被 sed 处理过的行;\n2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:\n        sed -e '$d' -e '/regex/p' $file_path\n3. -f:  执行给定文件里的命令;\n4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:\n        +, ?, |, ()\n        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;\n5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;\n```\n### **sed 的 command**\n``` bash\n1. i:   insert 到 目标行的上一行\n2. a:   append 到 目标行的下一行 \n3. c:   replace, 不能使用正则表达式\n4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:\n        s/regex/new_str/g, 替换文件中所有的 regex;\n        s/regex/new_str, 只替换每行第一个被匹配上的 regex;\n        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;\n5. d:   delete\n6. p:   print, 一般需要与 -n 选项一同使用, 否则看不出打印效果\n7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/\n```\n### **典型示例**\n``` bash\n# 打印最后一行\nsed -n '$p' $file_path\n# 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串\nsed -i -e '9,$d' -e '1,3a append' $file_path\n# 正则表达式替换(替换全部 regex)\nsed -ri 's/^(test|ping)[a-z]+.$/kill/g' $file_path\n# 打印从第9行开始到以 test 结尾的行之间的每一行\nsed -n '9,/test$/p' $file_path\n```\n``` bash\n# 结合变量, 往最后一行添加一行内容\n# 需使用\"\", 同时表示最后一行的 $ 需要转义\ncron_str='5 * * * *  sh /home/q/tools/bin/log_collect.sh 1>/dev/null'\nsed \"\\$a ${cron_str}\" /var/spool/cron/root\n```\n\n### **参考链接**\n- [linux之sed用法](http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html)\n- [linux sed命令详解](http://www.iteye.com/topic/587673)\n\n","source":"_posts/linux-text-sed命令整理.md","raw":"---\ntitle: sed 命令整理\ndate: 2016-11-04 22:56:47\ncategories:\n  - linux\n  - text\ntags:\n  - linux:text\n---\n\n> stream editor: 流式文本编辑器;\nsed 命令的侧重点在于对文本的编辑;\n\n<!--more-->\n\n### **sed 的基本模式**\n``` bash\n# 标准模式: 选项, 目标行范围, 命令\nsed  [-nefri] '[target line]command' $file_path\n# 正则模式: 选项, 正则匹配式, 命令\nsed  [-nefri] '/regex/command' $file_path\n# 混合模式: 选项, 目标行与正则式组合范围, 命令\nsed [-nefri] 'line,/regex/command' $file_path\n```\n### **sed 的常用选项**\n``` bash\n1. -n:  silent 静默模式, 只输出被 sed 处理过的行;\n2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:\n        sed -e '$d' -e '/regex/p' $file_path\n3. -f:  执行给定文件里的命令;\n4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:\n        +, ?, |, ()\n        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;\n5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;\n```\n### **sed 的 command**\n``` bash\n1. i:   insert 到 目标行的上一行\n2. a:   append 到 目标行的下一行 \n3. c:   replace, 不能使用正则表达式\n4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:\n        s/regex/new_str/g, 替换文件中所有的 regex;\n        s/regex/new_str, 只替换每行第一个被匹配上的 regex;\n        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;\n5. d:   delete\n6. p:   print, 一般需要与 -n 选项一同使用, 否则看不出打印效果\n7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/\n```\n### **典型示例**\n``` bash\n# 打印最后一行\nsed -n '$p' $file_path\n# 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串\nsed -i -e '9,$d' -e '1,3a append' $file_path\n# 正则表达式替换(替换全部 regex)\nsed -ri 's/^(test|ping)[a-z]+.$/kill/g' $file_path\n# 打印从第9行开始到以 test 结尾的行之间的每一行\nsed -n '9,/test$/p' $file_path\n```\n``` bash\n# 结合变量, 往最后一行添加一行内容\n# 需使用\"\", 同时表示最后一行的 $ 需要转义\ncron_str='5 * * * *  sh /home/q/tools/bin/log_collect.sh 1>/dev/null'\nsed \"\\$a ${cron_str}\" /var/spool/cron/root\n```\n\n### **参考链接**\n- [linux之sed用法](http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html)\n- [linux sed命令详解](http://www.iteye.com/topic/587673)\n\n","slug":"linux-text-sed命令整理","published":1,"updated":"2018-01-04T14:58:47.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1p000ifejxl0f172a5","content":"<blockquote>\n<p>stream editor: 流式文本编辑器;<br>sed 命令的侧重点在于对文本的编辑;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"sed-的基本模式\"><a href=\"#sed-的基本模式\" class=\"headerlink\" title=\"sed 的基本模式\"></a><strong>sed 的基本模式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标准模式: 选项, 目标行范围, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'[target line]command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则模式: 选项, 正则匹配式, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'/regex/command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 混合模式: 选项, 目标行与正则式组合范围, 命令</span></span><br><span class=\"line\">sed [-nefri] <span class=\"string\">'line,/regex/command'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的常用选项\"><a href=\"#sed-的常用选项\" class=\"headerlink\" title=\"sed 的常用选项\"></a><strong>sed 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. -n:  silent 静默模式, 只输出被 sed 处理过的行;</span><br><span class=\"line\">2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:</span><br><span class=\"line\">        sed -e <span class=\"string\">'$d'</span> -e <span class=\"string\">'/regex/p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\">3. -f:  执行给定文件里的命令;</span><br><span class=\"line\">4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:</span><br><span class=\"line\">        +, ?, |, ()</span><br><span class=\"line\">        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;</span><br><span class=\"line\">5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的-command\"><a href=\"#sed-的-command\" class=\"headerlink\" title=\"sed 的 command\"></a><strong>sed 的 command</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. i:   insert 到 目标行的上一行</span><br><span class=\"line\">2. a:   append 到 目标行的下一行 </span><br><span class=\"line\">3. c:   replace, 不能使用正则表达式</span><br><span class=\"line\">4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:</span><br><span class=\"line\">        s/regex/new_str/g, 替换文件中所有的 regex;</span><br><span class=\"line\">        s/regex/new_str, 只替换每行第一个被匹配上的 regex;</span><br><span class=\"line\">        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;</span><br><span class=\"line\">5. d:   delete</span><br><span class=\"line\">6. p:   <span class=\"built_in\">print</span>, 一般需要与 -n 选项一同使用, 否则看不出打印效果</span><br><span class=\"line\">7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/</span><br></pre></td></tr></table></figure>\n<h3 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a><strong>典型示例</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印最后一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'$p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串</span></span><br><span class=\"line\">sed -i -e <span class=\"string\">'9,$d'</span> -e <span class=\"string\">'1,3a append'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则表达式替换(替换全部 regex)</span></span><br><span class=\"line\">sed -ri <span class=\"string\">'s/^(test|ping)[a-z]+.$/kill/g'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 打印从第9行开始到以 test 结尾的行之间的每一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'9,/test$/p'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 结合变量, 往最后一行添加一行内容</span></span><br><span class=\"line\"><span class=\"comment\"># 需使用\"\", 同时表示最后一行的 $ 需要转义</span></span><br><span class=\"line\">cron_str=<span class=\"string\">'5 * * * *  sh /home/q/tools/bin/log_collect.sh 1&gt;/dev/null'</span></span><br><span class=\"line\">sed <span class=\"string\">\"\\$a <span class=\"variable\">$&#123;cron_str&#125;</span>\"</span> /var/spool/cron/root</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html\" target=\"_blank\" rel=\"noopener\">linux之sed用法</a></li>\n<li><a href=\"http://www.iteye.com/topic/587673\" target=\"_blank\" rel=\"noopener\">linux sed命令详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>stream editor: 流式文本编辑器;<br>sed 命令的侧重点在于对文本的编辑;</p>\n</blockquote>","more":"<h3 id=\"sed-的基本模式\"><a href=\"#sed-的基本模式\" class=\"headerlink\" title=\"sed 的基本模式\"></a><strong>sed 的基本模式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标准模式: 选项, 目标行范围, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'[target line]command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则模式: 选项, 正则匹配式, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'/regex/command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 混合模式: 选项, 目标行与正则式组合范围, 命令</span></span><br><span class=\"line\">sed [-nefri] <span class=\"string\">'line,/regex/command'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的常用选项\"><a href=\"#sed-的常用选项\" class=\"headerlink\" title=\"sed 的常用选项\"></a><strong>sed 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. -n:  silent 静默模式, 只输出被 sed 处理过的行;</span><br><span class=\"line\">2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:</span><br><span class=\"line\">        sed -e <span class=\"string\">'$d'</span> -e <span class=\"string\">'/regex/p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\">3. -f:  执行给定文件里的命令;</span><br><span class=\"line\">4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:</span><br><span class=\"line\">        +, ?, |, ()</span><br><span class=\"line\">        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;</span><br><span class=\"line\">5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的-command\"><a href=\"#sed-的-command\" class=\"headerlink\" title=\"sed 的 command\"></a><strong>sed 的 command</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. i:   insert 到 目标行的上一行</span><br><span class=\"line\">2. a:   append 到 目标行的下一行 </span><br><span class=\"line\">3. c:   replace, 不能使用正则表达式</span><br><span class=\"line\">4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:</span><br><span class=\"line\">        s/regex/new_str/g, 替换文件中所有的 regex;</span><br><span class=\"line\">        s/regex/new_str, 只替换每行第一个被匹配上的 regex;</span><br><span class=\"line\">        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;</span><br><span class=\"line\">5. d:   delete</span><br><span class=\"line\">6. p:   <span class=\"built_in\">print</span>, 一般需要与 -n 选项一同使用, 否则看不出打印效果</span><br><span class=\"line\">7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/</span><br></pre></td></tr></table></figure>\n<h3 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a><strong>典型示例</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印最后一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'$p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串</span></span><br><span class=\"line\">sed -i -e <span class=\"string\">'9,$d'</span> -e <span class=\"string\">'1,3a append'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则表达式替换(替换全部 regex)</span></span><br><span class=\"line\">sed -ri <span class=\"string\">'s/^(test|ping)[a-z]+.$/kill/g'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 打印从第9行开始到以 test 结尾的行之间的每一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'9,/test$/p'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 结合变量, 往最后一行添加一行内容</span></span><br><span class=\"line\"><span class=\"comment\"># 需使用\"\", 同时表示最后一行的 $ 需要转义</span></span><br><span class=\"line\">cron_str=<span class=\"string\">'5 * * * *  sh /home/q/tools/bin/log_collect.sh 1&gt;/dev/null'</span></span><br><span class=\"line\">sed <span class=\"string\">\"\\$a <span class=\"variable\">$&#123;cron_str&#125;</span>\"</span> /var/spool/cron/root</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html\" target=\"_blank\" rel=\"noopener\">linux之sed用法</a></li>\n<li><a href=\"http://www.iteye.com/topic/587673\" target=\"_blank\" rel=\"noopener\">linux sed命令详解</a></li>\n</ul>"},{"title":"r<!---->syncd 配置与运维","date":"2017-10-14T15:20:21.000Z","_content":"\n> 本文主要梳理 rsync server 的基本配置与使用方式;\n\n<!--more-->\n\n### **rsync server 的几个关键配置文件**\n1. /etc/rsyncd.conf: 主配置文件;\n2. /etc/rsyncd.password/rsyncd.secrets: 秘钥文件;\n3. /etc/rsyncd.motd: rysnc 服务器元信息, 非必须;\n\n其中, rsyncd.password 秘钥文件的掩码必须是 600:\n``` bash\n> ll /etc/ | grep rsyncd\n-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf\n-rw-------   1 root root     24 Apr  6  2017 rsyncd.password\n```\n\n### **rsyncd.conf 配置说明**\n一个典型的 rsyncd.conf 文件如下:\n``` bash\n# rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置\nuid=nobody\ngid=nobody\n\n# 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下\nuser chroot = no\n\nmax connections = 200\ntimeout = 600\n\npid file = /data1/trans_file/rsyncd.pid\nlock file = /data1/trans_file/rsyncd.lock\nlog file = /data1/trans_file/rsyncd.log\n# 用户秘钥文件, 可在具体的模块中配置\nsecrets file = /etc/rsyncd.password\n# 服务器元信息, 非必选\n# motd file = /etc/rsyncd/rsyncd.motd\n# 指定不需要压缩就可以直接传输的文件类型\ndont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2\n\n# 模块配置\n[wireless_log]\n# 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输\nauth users = sync\npath = /data1/trans_file/files/wireless_log\nignore errors\n# 是否只读\nread only = no\n# 是否允许列出模块里的内容\nlist = no\n```\n\n### **rsyncd.password / rsyncd.secrets 配置说明**\n以 `:` 分隔, 用户名和密码, 每行一个:\n```\nuser1:password1\nuser2:password2\n```\n\n### **rsyncd 启动方式**\n``` bash\n# 当负载高时, 以守护进程的方式运行 rsyncd\nsudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf\n```\n\n### **参考链接**\n- [centos下配置rsyncd服务器](https://segmentfault.com/a/1190000000444614)\n- [RSync实现文件备份同步](http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html)\n\n","source":"_posts/rsync--rsyncd配置与运行.md","raw":"---\ntitle: r<!---->syncd 配置与运维\ndate: 2017-10-14 23:20:21\ntags:\n  - rsync\ncategories:\n  - rsync\n---\n\n> 本文主要梳理 rsync server 的基本配置与使用方式;\n\n<!--more-->\n\n### **rsync server 的几个关键配置文件**\n1. /etc/rsyncd.conf: 主配置文件;\n2. /etc/rsyncd.password/rsyncd.secrets: 秘钥文件;\n3. /etc/rsyncd.motd: rysnc 服务器元信息, 非必须;\n\n其中, rsyncd.password 秘钥文件的掩码必须是 600:\n``` bash\n> ll /etc/ | grep rsyncd\n-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf\n-rw-------   1 root root     24 Apr  6  2017 rsyncd.password\n```\n\n### **rsyncd.conf 配置说明**\n一个典型的 rsyncd.conf 文件如下:\n``` bash\n# rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置\nuid=nobody\ngid=nobody\n\n# 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下\nuser chroot = no\n\nmax connections = 200\ntimeout = 600\n\npid file = /data1/trans_file/rsyncd.pid\nlock file = /data1/trans_file/rsyncd.lock\nlog file = /data1/trans_file/rsyncd.log\n# 用户秘钥文件, 可在具体的模块中配置\nsecrets file = /etc/rsyncd.password\n# 服务器元信息, 非必选\n# motd file = /etc/rsyncd/rsyncd.motd\n# 指定不需要压缩就可以直接传输的文件类型\ndont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2\n\n# 模块配置\n[wireless_log]\n# 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输\nauth users = sync\npath = /data1/trans_file/files/wireless_log\nignore errors\n# 是否只读\nread only = no\n# 是否允许列出模块里的内容\nlist = no\n```\n\n### **rsyncd.password / rsyncd.secrets 配置说明**\n以 `:` 分隔, 用户名和密码, 每行一个:\n```\nuser1:password1\nuser2:password2\n```\n\n### **rsyncd 启动方式**\n``` bash\n# 当负载高时, 以守护进程的方式运行 rsyncd\nsudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf\n```\n\n### **参考链接**\n- [centos下配置rsyncd服务器](https://segmentfault.com/a/1190000000444614)\n- [RSync实现文件备份同步](http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html)\n\n","slug":"rsync--rsyncd配置与运行","published":1,"updated":"2018-01-03T16:00:35.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1s000lfejxnaq5d081","content":"<blockquote>\n<p>本文主要梳理 rsync server 的基本配置与使用方式;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"rsync-server-的几个关键配置文件\"><a href=\"#rsync-server-的几个关键配置文件\" class=\"headerlink\" title=\"rsync server 的几个关键配置文件\"></a><strong>rsync server 的几个关键配置文件</strong></h3><ol>\n<li>/etc/rsyncd.conf: 主配置文件;</li>\n<li>/etc/rsyncd.password/rsyncd.secrets: 秘钥文件;</li>\n<li>/etc/rsyncd.motd: rysnc 服务器元信息, 非必须;</li>\n</ol>\n<p>其中, rsyncd.password 秘钥文件的掩码必须是 600:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ll /etc/ | grep rsyncd</span><br><span class=\"line\">-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf</span><br><span class=\"line\">-rw-------   1 root root     24 Apr  6  2017 rsyncd.password</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-conf-配置说明\"><a href=\"#rsyncd-conf-配置说明\" class=\"headerlink\" title=\"rsyncd.conf 配置说明\"></a><strong>rsyncd.conf 配置说明</strong></h3><p>一个典型的 rsyncd.conf 文件如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置</span></span><br><span class=\"line\">uid=nobody</span><br><span class=\"line\">gid=nobody</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下</span></span><br><span class=\"line\">user chroot = no</span><br><span class=\"line\"></span><br><span class=\"line\">max connections = 200</span><br><span class=\"line\">timeout = 600</span><br><span class=\"line\"></span><br><span class=\"line\">pid file = /data1/trans_file/rsyncd.pid</span><br><span class=\"line\">lock file = /data1/trans_file/rsyncd.lock</span><br><span class=\"line\"><span class=\"built_in\">log</span> file = /data1/trans_file/rsyncd.log</span><br><span class=\"line\"><span class=\"comment\"># 用户秘钥文件, 可在具体的模块中配置</span></span><br><span class=\"line\">secrets file = /etc/rsyncd.password</span><br><span class=\"line\"><span class=\"comment\"># 服务器元信息, 非必选</span></span><br><span class=\"line\"><span class=\"comment\"># motd file = /etc/rsyncd/rsyncd.motd</span></span><br><span class=\"line\"><span class=\"comment\"># 指定不需要压缩就可以直接传输的文件类型</span></span><br><span class=\"line\">dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模块配置</span></span><br><span class=\"line\">[wireless_log]</span><br><span class=\"line\"><span class=\"comment\"># 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输</span></span><br><span class=\"line\">auth users = sync</span><br><span class=\"line\">path = /data1/trans_file/files/wireless_log</span><br><span class=\"line\">ignore errors</span><br><span class=\"line\"><span class=\"comment\"># 是否只读</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> only = no</span><br><span class=\"line\"><span class=\"comment\"># 是否允许列出模块里的内容</span></span><br><span class=\"line\">list = no</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-password-rsyncd-secrets-配置说明\"><a href=\"#rsyncd-password-rsyncd-secrets-配置说明\" class=\"headerlink\" title=\"rsyncd.password / rsyncd.secrets 配置说明\"></a><strong>rsyncd.password / rsyncd.secrets 配置说明</strong></h3><p>以 <code>:</code> 分隔, 用户名和密码, 每行一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user1:password1</span><br><span class=\"line\">user2:password2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-启动方式\"><a href=\"#rsyncd-启动方式\" class=\"headerlink\" title=\"rsyncd 启动方式\"></a><strong>rsyncd 启动方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当负载高时, 以守护进程的方式运行 rsyncd</span></span><br><span class=\"line\">sudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000000444614\" target=\"_blank\" rel=\"noopener\">centos下配置rsyncd服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html\" target=\"_blank\" rel=\"noopener\">RSync实现文件备份同步</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要梳理 rsync server 的基本配置与使用方式;</p>\n</blockquote>","more":"<h3 id=\"rsync-server-的几个关键配置文件\"><a href=\"#rsync-server-的几个关键配置文件\" class=\"headerlink\" title=\"rsync server 的几个关键配置文件\"></a><strong>rsync server 的几个关键配置文件</strong></h3><ol>\n<li>/etc/rsyncd.conf: 主配置文件;</li>\n<li>/etc/rsyncd.password/rsyncd.secrets: 秘钥文件;</li>\n<li>/etc/rsyncd.motd: rysnc 服务器元信息, 非必须;</li>\n</ol>\n<p>其中, rsyncd.password 秘钥文件的掩码必须是 600:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ll /etc/ | grep rsyncd</span><br><span class=\"line\">-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf</span><br><span class=\"line\">-rw-------   1 root root     24 Apr  6  2017 rsyncd.password</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-conf-配置说明\"><a href=\"#rsyncd-conf-配置说明\" class=\"headerlink\" title=\"rsyncd.conf 配置说明\"></a><strong>rsyncd.conf 配置说明</strong></h3><p>一个典型的 rsyncd.conf 文件如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置</span></span><br><span class=\"line\">uid=nobody</span><br><span class=\"line\">gid=nobody</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下</span></span><br><span class=\"line\">user chroot = no</span><br><span class=\"line\"></span><br><span class=\"line\">max connections = 200</span><br><span class=\"line\">timeout = 600</span><br><span class=\"line\"></span><br><span class=\"line\">pid file = /data1/trans_file/rsyncd.pid</span><br><span class=\"line\">lock file = /data1/trans_file/rsyncd.lock</span><br><span class=\"line\"><span class=\"built_in\">log</span> file = /data1/trans_file/rsyncd.log</span><br><span class=\"line\"><span class=\"comment\"># 用户秘钥文件, 可在具体的模块中配置</span></span><br><span class=\"line\">secrets file = /etc/rsyncd.password</span><br><span class=\"line\"><span class=\"comment\"># 服务器元信息, 非必选</span></span><br><span class=\"line\"><span class=\"comment\"># motd file = /etc/rsyncd/rsyncd.motd</span></span><br><span class=\"line\"><span class=\"comment\"># 指定不需要压缩就可以直接传输的文件类型</span></span><br><span class=\"line\">dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模块配置</span></span><br><span class=\"line\">[wireless_log]</span><br><span class=\"line\"><span class=\"comment\"># 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输</span></span><br><span class=\"line\">auth users = sync</span><br><span class=\"line\">path = /data1/trans_file/files/wireless_log</span><br><span class=\"line\">ignore errors</span><br><span class=\"line\"><span class=\"comment\"># 是否只读</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> only = no</span><br><span class=\"line\"><span class=\"comment\"># 是否允许列出模块里的内容</span></span><br><span class=\"line\">list = no</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-password-rsyncd-secrets-配置说明\"><a href=\"#rsyncd-password-rsyncd-secrets-配置说明\" class=\"headerlink\" title=\"rsyncd.password / rsyncd.secrets 配置说明\"></a><strong>rsyncd.password / rsyncd.secrets 配置说明</strong></h3><p>以 <code>:</code> 分隔, 用户名和密码, 每行一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user1:password1</span><br><span class=\"line\">user2:password2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-启动方式\"><a href=\"#rsyncd-启动方式\" class=\"headerlink\" title=\"rsyncd 启动方式\"></a><strong>rsyncd 启动方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当负载高时, 以守护进程的方式运行 rsyncd</span></span><br><span class=\"line\">sudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000000444614\" target=\"_blank\" rel=\"noopener\">centos下配置rsyncd服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html\" target=\"_blank\" rel=\"noopener\">RSync实现文件备份同步</a></li>\n</ul>"},{"title":"git 忽略文件的特殊场景","date":"2016-07-14T15:17:24.000Z","_content":"\n> git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;\n使用 `.gitignore` 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:\n1.一时疏忽, 将本该忽略的文件提交追踪了;\n2.需要临时忽略某指定文件, 一段时间后再继续追踪;\n本文将讨论以上两种情况下的 git 处理;\n\n<!--more-->\n\n------\n\n### **永远忽略已被跟踪的文件**\n适用于手误上传了不必要的文件;\n``` bash\n# first step\ngit rm --cached file_path/\n# second step\nupdate .gitignore to exclude target file\n```\n&nbsp;\n### **临时忽略已被跟踪的文件**\n适用场景:\n目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;\n所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;\n``` bash\n# first step\ngit update-index --assume-unchanged file_path/\n# 编辑文件...\n# seconde step\ngit update-index --no-assume-unchanged file_path/\n```\n&nbsp;\n### **参考链接**\n- [git忽略已经被提交的文件](https://segmentfault.com/q/1010000000430426)\n\n","source":"_posts/tools-git--git忽略文件的特殊场景.md","raw":"---\ntitle: git 忽略文件的特殊场景\ndate: 2016-07-14 23:17:24\ncategories:\n - tools\n - git\ntags:\n - tools:git\n---\n\n> git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;\n使用 `.gitignore` 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:\n1.一时疏忽, 将本该忽略的文件提交追踪了;\n2.需要临时忽略某指定文件, 一段时间后再继续追踪;\n本文将讨论以上两种情况下的 git 处理;\n\n<!--more-->\n\n------\n\n### **永远忽略已被跟踪的文件**\n适用于手误上传了不必要的文件;\n``` bash\n# first step\ngit rm --cached file_path/\n# second step\nupdate .gitignore to exclude target file\n```\n&nbsp;\n### **临时忽略已被跟踪的文件**\n适用场景:\n目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;\n所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;\n``` bash\n# first step\ngit update-index --assume-unchanged file_path/\n# 编辑文件...\n# seconde step\ngit update-index --no-assume-unchanged file_path/\n```\n&nbsp;\n### **参考链接**\n- [git忽略已经被提交的文件](https://segmentfault.com/q/1010000000430426)\n\n","slug":"tools-git--git忽略文件的特殊场景","published":1,"updated":"2018-01-13T07:20:00.322Z","_id":"cjcd0cb1u000nfejxzxz5puoe","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;<br>使用 <code>.gitignore</code> 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:<br>1.一时疏忽, 将本该忽略的文件提交追踪了;<br>2.需要临时忽略某指定文件, 一段时间后再继续追踪;<br>本文将讨论以上两种情况下的 git 处理;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"永远忽略已被跟踪的文件\"><a href=\"#永远忽略已被跟踪的文件\" class=\"headerlink\" title=\"永远忽略已被跟踪的文件\"></a><strong>永远忽略已被跟踪的文件</strong></h3><p>适用于手误上传了不必要的文件;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git rm --cached file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">update .gitignore to exclude target file</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"临时忽略已被跟踪的文件\"><a href=\"#临时忽略已被跟踪的文件\" class=\"headerlink\" title=\"临时忽略已被跟踪的文件\"></a><strong>临时忽略已被跟踪的文件</strong></h3><p>适用场景:<br>目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;<br>所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git update-index --assume-unchanged file_path/</span><br><span class=\"line\"><span class=\"comment\"># 编辑文件...</span></span><br><span class=\"line\"><span class=\"comment\"># seconde step</span></span><br><span class=\"line\">git update-index --no-assume-unchanged file_path/</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/q/1010000000430426\" target=\"_blank\" rel=\"noopener\">git忽略已经被提交的文件</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;<br>使用 <code>.gitignore</code> 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:<br>1.一时疏忽, 将本该忽略的文件提交追踪了;<br>2.需要临时忽略某指定文件, 一段时间后再继续追踪;<br>本文将讨论以上两种情况下的 git 处理;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"永远忽略已被跟踪的文件\"><a href=\"#永远忽略已被跟踪的文件\" class=\"headerlink\" title=\"永远忽略已被跟踪的文件\"></a><strong>永远忽略已被跟踪的文件</strong></h3><p>适用于手误上传了不必要的文件;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git rm --cached file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">update .gitignore to exclude target file</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"临时忽略已被跟踪的文件\"><a href=\"#临时忽略已被跟踪的文件\" class=\"headerlink\" title=\"临时忽略已被跟踪的文件\"></a><strong>临时忽略已被跟踪的文件</strong></h3><p>适用场景:<br>目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;<br>所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git update-index --assume-unchanged file_path/</span><br><span class=\"line\"><span class=\"comment\"># 编辑文件...</span></span><br><span class=\"line\"><span class=\"comment\"># seconde step</span></span><br><span class=\"line\">git update-index --no-assume-unchanged file_path/</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/q/1010000000430426\" target=\"_blank\" rel=\"noopener\">git忽略已经被提交的文件</a></li>\n</ul>"},{"title":"maven-assembly-plugin 使用总结","date":"2016-11-19T15:42:40.000Z","_content":"\n> 本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: [在 Apache Spark 中使用 springframework 的一次总结](), 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;\n另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 '丰富而典型' 的配置文件 case 上, 以注释的形式作为每个配置项的释义;\n\n<!--more-->\n\n------\n\n### **pom.xml 中的配置项**\n一段典型的 assembly 插件的 mvn 配置:\n``` xml\n<plugin>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>${assembly.plugin.version}</version>\n    \n    <configuration>\n        <!-- 打包后的包名是否需要追加 assembly 配置文件的 id -->\n        <appendAssemblyId>false</appendAssemblyId>\n        <!-- 最终生成的打包文件输出的路径 -->\n        <outputDirectory>${project.build.directory}/target</outputDirectory>\n        <!-- 定义核心配置文件的访问路径 -->\n        <descriptors>\n            <descriptor>${basedir}/src/main/assembly/client.xml</descriptor>\n            <descriptor>${basedir}/src/main/assembly/server.xml</descriptor>\n        </descriptors>\n    </configuration>\n    \n    <executions>\n        <execution>\n            <!-- 一般运行在 package phase -->\n            <phase>package</phase>\n            <goals>\n                <!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help -->\n                <goal>single</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n&nbsp;\n### **核心配置文件**\n以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 `${basedir}/src/main/assembly/` 目录里, 并如上一节所示, 在 `configuration -> descriptors` 路径下定义加载:\n``` xml\n<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n          \n    <!-- assembly 配置文件id -->\n    <id>deploy</id>\n    <!-- \n        目标打包文件的格式, 支持格式如下:\n            jar, war, zip, tar, tar.gz, tar.bz2 等 \n    -->\n    <formats>\n        <format>jar</format>\n    </formats>\n    \n    <!-- 是否以 ${project.build.finalName}, 作为所有被打包文件的基目录, 默认 true -->\n    <includeBaseDirectory>false</includeBaseDirectory>\n    <!-- 显式定义 所有被打包文件的基目录 -->\n    <baseDirectory>${project.build.finalName}</baseDirectory>\n    \n    <!-- 独立文件的收集 -->\n    <files>\n        <file>\n            <!-- 待收集的文件名 -->\n            <source>LICENSE.txt</source>\n            <!-- 收集到目标文件的相对路径 -->\n            <outputDirectory>/</outputDirectory>\n        </file>\n        <file>\n            <source>NOTICE.txt</source>\n            <outputDirectory>/</outputDirectory>\n            <!-- 将 ${...} 占位符 替换为实际的内容, 默认 false -->\n            <filtered>true</filtered>\n        </file>\n    </files>\n    \n    <!-- 目录的收集 -->\n    <fileSets>\n        <fileSet>\n            <!-- 目录名 -->\n            <directory>${project.basedir}/src/main/resources</directory>\n            <outputDirectory>/</outputDirectory>\n        </fileSet>\n        <fileSet>\n            <directory>${project.basedir}/src/doc</directory>\n            <!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true -->\n            <useDefaultExcludes>true</useDefaultExcludes>\n            <outputDirectory>/doc</outputDirectory>\n        </fileSet>\n    </fileSets>\n    \n    <!-- 依赖的收集 -->\n    <dependencySets>\n        <dependencySet>\n            <outputDirectory>/lib</outputDirectory>\n            <!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true -->\n            <useProjectArtifact>true</useProjectArtifact>\n            <!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false -->\n            <useProjectAttachments>false</useProjectAttachments>\n            <!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false -->\n            <unpack>false</unpack>\n            <!--  -->\n            <scope>runtime</scope>\n            <!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true -->\n            <useTransitiveDependencies>true</useTransitiveDependencies>\n            <!-- \n                includes/excludes 的格式:\n                    groupId:artifactId:type:classifier\n                    groupId:artifactId\n                    groupId:artifactId:type:classifier:version\n                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;\n            -->\n            <excludes>\n                <exclude>org.apache.commons:commons-logging:jar</exclude>\n                <exclude>*:war</exclude>\n            </excludes>\n            <!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false -->\n            <useTransitiveFiltering>true</useTransitiveFiltering>\n        </dependencySet>\n    </dependencySets>\n    \n</assembly>\n```\n\n&nbsp;\n### **使用 assembly 的一些注意事项**\n* 使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 `baseDirectory`, 并将 `includeBaseDirectory` 置为 `false`;\n因为 assembly 生成的 jar 包在 `/META-INF/MANIFEST.MF` 文件中默认不会定义 `Class-Path`, 即 CLASSPATH 默认就是 jar 中的基目录;  \n```\n# assembly 生成的 /META-INF/MANIFEST.MF\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nCreated-By: 25.151-b12 (Oracle Corporation)\n```\n* 核心配置文件中的 `outputDirectory` 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 `/`, 都不会有影响;\n* assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:\nassembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: [When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies](http://jira.codehaus.org/browse/MASSEMBLY-360) );\n当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;\n\n&nbsp;\n### **关于 assembly 命令**\n除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:\n```\nmvn clean assembly:single\nmvn assembly:help\n```\n由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: [assembly:single](http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html)\n\n&nbsp;\n### **参考链接**\n- [Apache Maven Assembly Plugin: Assembly](http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html)\n- [Filtering Some Distribution Files](https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html)\n- [8.5. Controlling the Contents of an Assembly](http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html)\n- [Quick Note on All includes and excludes Patterns](https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html)\n\n","source":"_posts/tools-maven--assembly_plugin.md","raw":"---\ntitle: maven-assembly-plugin 使用总结\ndate: 2016-11-19 23:42:40\ncategories:\n - tools\n - maven\ntags:\n - mvn:plugins\n---\n\n> 本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: [在 Apache Spark 中使用 springframework 的一次总结](), 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;\n另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 '丰富而典型' 的配置文件 case 上, 以注释的形式作为每个配置项的释义;\n\n<!--more-->\n\n------\n\n### **pom.xml 中的配置项**\n一段典型的 assembly 插件的 mvn 配置:\n``` xml\n<plugin>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>${assembly.plugin.version}</version>\n    \n    <configuration>\n        <!-- 打包后的包名是否需要追加 assembly 配置文件的 id -->\n        <appendAssemblyId>false</appendAssemblyId>\n        <!-- 最终生成的打包文件输出的路径 -->\n        <outputDirectory>${project.build.directory}/target</outputDirectory>\n        <!-- 定义核心配置文件的访问路径 -->\n        <descriptors>\n            <descriptor>${basedir}/src/main/assembly/client.xml</descriptor>\n            <descriptor>${basedir}/src/main/assembly/server.xml</descriptor>\n        </descriptors>\n    </configuration>\n    \n    <executions>\n        <execution>\n            <!-- 一般运行在 package phase -->\n            <phase>package</phase>\n            <goals>\n                <!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help -->\n                <goal>single</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n&nbsp;\n### **核心配置文件**\n以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 `${basedir}/src/main/assembly/` 目录里, 并如上一节所示, 在 `configuration -> descriptors` 路径下定义加载:\n``` xml\n<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n          \n    <!-- assembly 配置文件id -->\n    <id>deploy</id>\n    <!-- \n        目标打包文件的格式, 支持格式如下:\n            jar, war, zip, tar, tar.gz, tar.bz2 等 \n    -->\n    <formats>\n        <format>jar</format>\n    </formats>\n    \n    <!-- 是否以 ${project.build.finalName}, 作为所有被打包文件的基目录, 默认 true -->\n    <includeBaseDirectory>false</includeBaseDirectory>\n    <!-- 显式定义 所有被打包文件的基目录 -->\n    <baseDirectory>${project.build.finalName}</baseDirectory>\n    \n    <!-- 独立文件的收集 -->\n    <files>\n        <file>\n            <!-- 待收集的文件名 -->\n            <source>LICENSE.txt</source>\n            <!-- 收集到目标文件的相对路径 -->\n            <outputDirectory>/</outputDirectory>\n        </file>\n        <file>\n            <source>NOTICE.txt</source>\n            <outputDirectory>/</outputDirectory>\n            <!-- 将 ${...} 占位符 替换为实际的内容, 默认 false -->\n            <filtered>true</filtered>\n        </file>\n    </files>\n    \n    <!-- 目录的收集 -->\n    <fileSets>\n        <fileSet>\n            <!-- 目录名 -->\n            <directory>${project.basedir}/src/main/resources</directory>\n            <outputDirectory>/</outputDirectory>\n        </fileSet>\n        <fileSet>\n            <directory>${project.basedir}/src/doc</directory>\n            <!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true -->\n            <useDefaultExcludes>true</useDefaultExcludes>\n            <outputDirectory>/doc</outputDirectory>\n        </fileSet>\n    </fileSets>\n    \n    <!-- 依赖的收集 -->\n    <dependencySets>\n        <dependencySet>\n            <outputDirectory>/lib</outputDirectory>\n            <!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true -->\n            <useProjectArtifact>true</useProjectArtifact>\n            <!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false -->\n            <useProjectAttachments>false</useProjectAttachments>\n            <!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false -->\n            <unpack>false</unpack>\n            <!--  -->\n            <scope>runtime</scope>\n            <!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true -->\n            <useTransitiveDependencies>true</useTransitiveDependencies>\n            <!-- \n                includes/excludes 的格式:\n                    groupId:artifactId:type:classifier\n                    groupId:artifactId\n                    groupId:artifactId:type:classifier:version\n                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;\n            -->\n            <excludes>\n                <exclude>org.apache.commons:commons-logging:jar</exclude>\n                <exclude>*:war</exclude>\n            </excludes>\n            <!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false -->\n            <useTransitiveFiltering>true</useTransitiveFiltering>\n        </dependencySet>\n    </dependencySets>\n    \n</assembly>\n```\n\n&nbsp;\n### **使用 assembly 的一些注意事项**\n* 使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 `baseDirectory`, 并将 `includeBaseDirectory` 置为 `false`;\n因为 assembly 生成的 jar 包在 `/META-INF/MANIFEST.MF` 文件中默认不会定义 `Class-Path`, 即 CLASSPATH 默认就是 jar 中的基目录;  \n```\n# assembly 生成的 /META-INF/MANIFEST.MF\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nCreated-By: 25.151-b12 (Oracle Corporation)\n```\n* 核心配置文件中的 `outputDirectory` 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 `/`, 都不会有影响;\n* assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:\nassembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: [When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies](http://jira.codehaus.org/browse/MASSEMBLY-360) );\n当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;\n\n&nbsp;\n### **关于 assembly 命令**\n除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:\n```\nmvn clean assembly:single\nmvn assembly:help\n```\n由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: [assembly:single](http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html)\n\n&nbsp;\n### **参考链接**\n- [Apache Maven Assembly Plugin: Assembly](http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html)\n- [Filtering Some Distribution Files](https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html)\n- [8.5. Controlling the Contents of an Assembly](http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html)\n- [Quick Note on All includes and excludes Patterns](https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html)\n\n","slug":"tools-maven--assembly_plugin","published":1,"updated":"2018-01-09T15:46:26.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb1z000qfejxiz5m51su","content":"<blockquote>\n<p>本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: <a href=\"\">在 Apache Spark 中使用 springframework 的一次总结</a>, 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;<br>另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 ‘丰富而典型’ 的配置文件 case 上, 以注释的形式作为每个配置项的释义;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"pom-xml-中的配置项\"><a href=\"#pom-xml-中的配置项\" class=\"headerlink\" title=\"pom.xml 中的配置项\"></a><strong>pom.xml 中的配置项</strong></h3><p>一段典型的 assembly 插件的 mvn 配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-assembly-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;assembly.plugin.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 打包后的包名是否需要追加 assembly 配置文件的 id --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appendAssemblyId</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">appendAssemblyId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 最终生成的打包文件输出的路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 定义核心配置文件的访问路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/client.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/server.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 一般运行在 package phase --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help --&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>single<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a><strong>核心配置文件</strong></h3><p>以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 <code>${basedir}/src/main/assembly/</code> 目录里, 并如上一节所示, 在 <code>configuration -&gt; descriptors</code> 路径下定义加载:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">assembly</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- assembly 配置文件id --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>deploy<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        目标打包文件的格式, 支持格式如下:</span></span><br><span class=\"line\"><span class=\"comment\">            jar, war, zip, tar, tar.gz, tar.bz2 等 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">format</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">format</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是否以 $&#123;project.build.finalName&#125;, 作为所有被打包文件的基目录, 默认 true --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeBaseDirectory</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">includeBaseDirectory</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 显式定义 所有被打包文件的基目录 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">baseDirectory</span>&gt;</span>$&#123;project.build.finalName&#125;<span class=\"tag\">&lt;/<span class=\"name\">baseDirectory</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独立文件的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 待收集的文件名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>LICENSE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 收集到目标文件的相对路径 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>NOTICE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 将 $&#123;...&#125; 占位符 替换为实际的内容, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtered</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtered</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目录的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 目录名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/doc<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useDefaultExcludes</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useDefaultExcludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/doc<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/lib<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectArtifact</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useProjectArtifact</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectAttachments</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">useProjectAttachments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">unpack</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">unpack</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--  --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveDependencies</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveDependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">                includes/excludes 的格式:</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier:version</span></span><br><span class=\"line\"><span class=\"comment\">                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;</span></span><br><span class=\"line\"><span class=\"comment\">            --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>org.apache.commons:commons-logging:jar<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>*:war<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveFiltering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveFiltering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"使用-assembly-的一些注意事项\"><a href=\"#使用-assembly-的一些注意事项\" class=\"headerlink\" title=\"使用 assembly 的一些注意事项\"></a><strong>使用 assembly 的一些注意事项</strong></h3><ul>\n<li><p>使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 <code>baseDirectory</code>, 并将 <code>includeBaseDirectory</code> 置为 <code>false</code>;<br>因为 assembly 生成的 jar 包在 <code>/META-INF/MANIFEST.MF</code> 文件中默认不会定义 <code>Class-Path</code>, 即 CLASSPATH 默认就是 jar 中的基目录;  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># assembly 生成的 /META-INF/MANIFEST.MF</span><br><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Archiver-Version: Plexus Archiver</span><br><span class=\"line\">Created-By: 25.151-b12 (Oracle Corporation)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>核心配置文件中的 <code>outputDirectory</code> 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 <code>/</code>, 都不会有影响;</p>\n</li>\n<li>assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:<br>assembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: <a href=\"http://jira.codehaus.org/browse/MASSEMBLY-360\" target=\"_blank\" rel=\"noopener\">When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies</a> );<br>当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;</li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"关于-assembly-命令\"><a href=\"#关于-assembly-命令\" class=\"headerlink\" title=\"关于 assembly 命令\"></a><strong>关于 assembly 命令</strong></h3><p>除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean assembly:single</span><br><span class=\"line\">mvn assembly:help</span><br></pre></td></tr></table></figure></p>\n<p>由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: <a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html\" target=\"_blank\" rel=\"noopener\">assembly:single</a></p>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html\" target=\"_blank\" rel=\"noopener\">Apache Maven Assembly Plugin: Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html\" target=\"_blank\" rel=\"noopener\">Filtering Some Distribution Files</a></li>\n<li><a href=\"http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html\" target=\"_blank\" rel=\"noopener\">8.5. Controlling the Contents of an Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html\" target=\"_blank\" rel=\"noopener\">Quick Note on All includes and excludes Patterns</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: <a href=\"\">在 Apache Spark 中使用 springframework 的一次总结</a>, 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;<br>另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 ‘丰富而典型’ 的配置文件 case 上, 以注释的形式作为每个配置项的释义;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"pom-xml-中的配置项\"><a href=\"#pom-xml-中的配置项\" class=\"headerlink\" title=\"pom.xml 中的配置项\"></a><strong>pom.xml 中的配置项</strong></h3><p>一段典型的 assembly 插件的 mvn 配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-assembly-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;assembly.plugin.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 打包后的包名是否需要追加 assembly 配置文件的 id --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appendAssemblyId</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">appendAssemblyId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 最终生成的打包文件输出的路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 定义核心配置文件的访问路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/client.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/server.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 一般运行在 package phase --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help --&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>single<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a><strong>核心配置文件</strong></h3><p>以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 <code>${basedir}/src/main/assembly/</code> 目录里, 并如上一节所示, 在 <code>configuration -&gt; descriptors</code> 路径下定义加载:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">assembly</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- assembly 配置文件id --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>deploy<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        目标打包文件的格式, 支持格式如下:</span></span><br><span class=\"line\"><span class=\"comment\">            jar, war, zip, tar, tar.gz, tar.bz2 等 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">format</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">format</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是否以 $&#123;project.build.finalName&#125;, 作为所有被打包文件的基目录, 默认 true --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeBaseDirectory</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">includeBaseDirectory</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 显式定义 所有被打包文件的基目录 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">baseDirectory</span>&gt;</span>$&#123;project.build.finalName&#125;<span class=\"tag\">&lt;/<span class=\"name\">baseDirectory</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独立文件的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 待收集的文件名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>LICENSE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 收集到目标文件的相对路径 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>NOTICE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 将 $&#123;...&#125; 占位符 替换为实际的内容, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtered</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtered</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目录的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 目录名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/doc<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useDefaultExcludes</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useDefaultExcludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/doc<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/lib<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectArtifact</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useProjectArtifact</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectAttachments</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">useProjectAttachments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">unpack</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">unpack</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--  --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveDependencies</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveDependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">                includes/excludes 的格式:</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier:version</span></span><br><span class=\"line\"><span class=\"comment\">                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;</span></span><br><span class=\"line\"><span class=\"comment\">            --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>org.apache.commons:commons-logging:jar<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>*:war<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveFiltering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveFiltering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"使用-assembly-的一些注意事项\"><a href=\"#使用-assembly-的一些注意事项\" class=\"headerlink\" title=\"使用 assembly 的一些注意事项\"></a><strong>使用 assembly 的一些注意事项</strong></h3><ul>\n<li><p>使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 <code>baseDirectory</code>, 并将 <code>includeBaseDirectory</code> 置为 <code>false</code>;<br>因为 assembly 生成的 jar 包在 <code>/META-INF/MANIFEST.MF</code> 文件中默认不会定义 <code>Class-Path</code>, 即 CLASSPATH 默认就是 jar 中的基目录;  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># assembly 生成的 /META-INF/MANIFEST.MF</span><br><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Archiver-Version: Plexus Archiver</span><br><span class=\"line\">Created-By: 25.151-b12 (Oracle Corporation)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>核心配置文件中的 <code>outputDirectory</code> 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 <code>/</code>, 都不会有影响;</p>\n</li>\n<li>assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:<br>assembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: <a href=\"http://jira.codehaus.org/browse/MASSEMBLY-360\" target=\"_blank\" rel=\"noopener\">When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies</a> );<br>当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;</li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"关于-assembly-命令\"><a href=\"#关于-assembly-命令\" class=\"headerlink\" title=\"关于 assembly 命令\"></a><strong>关于 assembly 命令</strong></h3><p>除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean assembly:single</span><br><span class=\"line\">mvn assembly:help</span><br></pre></td></tr></table></figure></p>\n<p>由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: <a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html\" target=\"_blank\" rel=\"noopener\">assembly:single</a></p>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html\" target=\"_blank\" rel=\"noopener\">Apache Maven Assembly Plugin: Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html\" target=\"_blank\" rel=\"noopener\">Filtering Some Distribution Files</a></li>\n<li><a href=\"http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html\" target=\"_blank\" rel=\"noopener\">8.5. Controlling the Contents of an Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html\" target=\"_blank\" rel=\"noopener\">Quick Note on All includes and excludes Patterns</a></li>\n</ul>"},{"title":"财富先锋 2017 年各股池成绩单","date":"2017-12-31T14:00:00.000Z","_content":"\n> 综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;\n'热点轮动', '股东增持' 两个股池系统的收益率达到了 200%, '支撑压力' 股池系统的收益率超过 150%;\n不过 '多头趋势' 股池系统的表现比较糟糕, 2017 年净收益为负;\n另外还有 '深一度' 股池系统的收益率未显示相关指标, 暂无法统计;\n各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;\n\n<!--more-->\n\n### **支撑压力**\n![2017 支撑压力 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png)\n\n### **热点轮动**\n![2017 热点轮动 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png)\n\n### **股东增持**\n![2017 股东增持 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png)\n\n### **多头趋势**\n![2017 多头趋势 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png)\n","source":"_posts/证券-财富先锋--财富先锋2017年各股池成绩单.md","raw":"---\ntitle: 财富先锋 2017 年各股池成绩单\ndate: 2017-12-31 22:00:00\ntags:\n  - 证券:财富先锋\ncategories:\n  - 证券\n  - 财富先锋\n---\n\n> 综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;\n'热点轮动', '股东增持' 两个股池系统的收益率达到了 200%, '支撑压力' 股池系统的收益率超过 150%;\n不过 '多头趋势' 股池系统的表现比较糟糕, 2017 年净收益为负;\n另外还有 '深一度' 股池系统的收益率未显示相关指标, 暂无法统计;\n各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;\n\n<!--more-->\n\n### **支撑压力**\n![2017 支撑压力 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png)\n\n### **热点轮动**\n![2017 热点轮动 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png)\n\n### **股东增持**\n![2017 股东增持 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png)\n\n### **多头趋势**\n![2017 多头趋势 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png)\n","slug":"证券-财富先锋--财富先锋2017年各股池成绩单","published":1,"updated":"2018-01-02T16:07:44.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcd0cb24000rfejxaasogo0l","content":"<blockquote>\n<p>综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;<br>‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;<br>不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;<br>另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;<br>各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"支撑压力\"><a href=\"#支撑压力\" class=\"headerlink\" title=\"支撑压力\"></a><strong>支撑压力</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png\" alt=\"2017 支撑压力 final review\"></p>\n<h3 id=\"热点轮动\"><a href=\"#热点轮动\" class=\"headerlink\" title=\"热点轮动\"></a><strong>热点轮动</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png\" alt=\"2017 热点轮动 final review\"></p>\n<h3 id=\"股东增持\"><a href=\"#股东增持\" class=\"headerlink\" title=\"股东增持\"></a><strong>股东增持</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png\" alt=\"2017 股东增持 final review\"></p>\n<h3 id=\"多头趋势\"><a href=\"#多头趋势\" class=\"headerlink\" title=\"多头趋势\"></a><strong>多头趋势</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png\" alt=\"2017 多头趋势 final review\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;<br>‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;<br>不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;<br>另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;<br>各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;</p>\n</blockquote>","more":"<h3 id=\"支撑压力\"><a href=\"#支撑压力\" class=\"headerlink\" title=\"支撑压力\"></a><strong>支撑压力</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png\" alt=\"2017 支撑压力 final review\"></p>\n<h3 id=\"热点轮动\"><a href=\"#热点轮动\" class=\"headerlink\" title=\"热点轮动\"></a><strong>热点轮动</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png\" alt=\"2017 热点轮动 final review\"></p>\n<h3 id=\"股东增持\"><a href=\"#股东增持\" class=\"headerlink\" title=\"股东增持\"></a><strong>股东增持</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png\" alt=\"2017 股东增持 final review\"></p>\n<h3 id=\"多头趋势\"><a href=\"#多头趋势\" class=\"headerlink\" title=\"多头趋势\"></a><strong>多头趋势</strong></h3><p><img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png\" alt=\"2017 多头趋势 final review\"></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjcd0cb1a0007fejxcee04ed0","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb25000sfejxdegeuu0q"},{"post_id":"cjcd0cb1a0007fejxcee04ed0","category_id":"cjcd0cb1r000jfejxlnrk5gk4","_id":"cjcd0cb26000vfejxmgfx1r26"},{"post_id":"cjcd0cb0i0000fejxz00jg6g3","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb26000xfejxdqjzd8g3"},{"post_id":"cjcd0cb0i0000fejxz00jg6g3","category_id":"cjcd0cb1z000ofejxs5vl490r","_id":"cjcd0cb270011fejxkakqm6au"},{"post_id":"cjcd0cb1c0008fejxy50kxv5x","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb280013fejx4qpm1gsm"},{"post_id":"cjcd0cb1c0008fejxy50kxv5x","category_id":"cjcd0cb25000tfejxmx7rjsju","_id":"cjcd0cb290016fejx8jht0949"},{"post_id":"cjcd0cb1g000cfejxzeg1dqai","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb290019fejxmu43a14q"},{"post_id":"cjcd0cb1g000cfejxzeg1dqai","category_id":"cjcd0cb26000zfejxw07zqtv5","_id":"cjcd0cb2a001bfejx3nrw7lls"},{"post_id":"cjcd0cb0u0002fejxza9dysx8","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2b001efejxnucyn8ao"},{"post_id":"cjcd0cb0u0002fejxza9dysx8","category_id":"cjcd0cb1r000jfejxlnrk5gk4","_id":"cjcd0cb2c001gfejxut0kqq4k"},{"post_id":"cjcd0cb1i000dfejxsl708nfc","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2d001jfejx1121fhie"},{"post_id":"cjcd0cb1i000dfejxsl708nfc","category_id":"cjcd0cb26000zfejxw07zqtv5","_id":"cjcd0cb2e001lfejxc7v8nrro"},{"post_id":"cjcd0cb1n000gfejxuhhi7ywt","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2f001ofejxl0kpnb1r"},{"post_id":"cjcd0cb1n000gfejxuhhi7ywt","category_id":"cjcd0cb26000zfejxw07zqtv5","_id":"cjcd0cb2g001qfejxafb3c8la"},{"post_id":"cjcd0cb180006fejxffysqrq6","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2g001sfejxp7i1c6me"},{"post_id":"cjcd0cb180006fejxffysqrq6","category_id":"cjcd0cb1r000jfejxlnrk5gk4","_id":"cjcd0cb2h001ufejx579vebmt"},{"post_id":"cjcd0cb1p000ifejxl0f172a5","category_id":"cjcd0cb100004fejxklbpae5d","_id":"cjcd0cb2i001xfejx55h8isqt"},{"post_id":"cjcd0cb1p000ifejxl0f172a5","category_id":"cjcd0cb2f001nfejx408wy4bz","_id":"cjcd0cb2j001zfejxeyilqzts"},{"post_id":"cjcd0cb1s000lfejxnaq5d081","category_id":"cjcd0cb2g001tfejx9j6i6hwp","_id":"cjcd0cb2j0022fejxkmw548w4"},{"post_id":"cjcd0cb1u000nfejxzxz5puoe","category_id":"cjcd0cb2j001yfejxs6ln8ri8","_id":"cjcd0cb2l0028fejx8zm74edy"},{"post_id":"cjcd0cb1u000nfejxzxz5puoe","category_id":"cjcd0cb2k0026fejxxp7q7yeq","_id":"cjcd0cb2l002afejx9dm6z8wc"},{"post_id":"cjcd0cb1z000qfejxiz5m51su","category_id":"cjcd0cb2j001yfejxs6ln8ri8","_id":"cjcd0cb2l002bfejxvyf7v5tz"},{"post_id":"cjcd0cb1z000qfejxiz5m51su","category_id":"cjcd0cb2l0027fejxrfo3gam9","_id":"cjcd0cb2l002cfejx0tigplor"},{"post_id":"cjcd0cb24000rfejxaasogo0l","category_id":"cjcd0cb2k0025fejxa1y7h7r8","_id":"cjcd0cb2m002dfejxc3mdg7f6"},{"post_id":"cjcd0cb24000rfejxaasogo0l","category_id":"cjcd0cb2l0029fejxh0c7q2uo","_id":"cjcd0cb2m002efejxkala0aj3"}],"PostTag":[{"post_id":"cjcd0cb0i0000fejxz00jg6g3","tag_id":"cjcd0cb180005fejx2qy1hg2c","_id":"cjcd0cb1g000bfejx1honxqhw"},{"post_id":"cjcd0cb0u0002fejxza9dysx8","tag_id":"cjcd0cb1e000afejxvpt8zn1y","_id":"cjcd0cb1o000hfejxm5l41dcr"},{"post_id":"cjcd0cb180006fejxffysqrq6","tag_id":"cjcd0cb1m000ffejx28r3egwo","_id":"cjcd0cb1u000mfejx3k0y77fi"},{"post_id":"cjcd0cb1a0007fejxcee04ed0","tag_id":"cjcd0cb1s000kfejxjjw1ip7b","_id":"cjcd0cb26000wfejx8orlz08g"},{"post_id":"cjcd0cb1a0007fejxcee04ed0","tag_id":"cjcd0cb1m000ffejx28r3egwo","_id":"cjcd0cb26000yfejx75pxeui5"},{"post_id":"cjcd0cb1c0008fejxy50kxv5x","tag_id":"cjcd0cb26000ufejx5j6t4al2","_id":"cjcd0cb270012fejx1b7pvd6r"},{"post_id":"cjcd0cb1g000cfejxzeg1dqai","tag_id":"cjcd0cb270010fejx6luf0w3q","_id":"cjcd0cb290017fejxw6ar3e99"},{"post_id":"cjcd0cb1i000dfejxsl708nfc","tag_id":"cjcd0cb270010fejx6luf0w3q","_id":"cjcd0cb2a001cfejx99k3ft2m"},{"post_id":"cjcd0cb1n000gfejxuhhi7ywt","tag_id":"cjcd0cb270010fejx6luf0w3q","_id":"cjcd0cb2c001hfejx6dy793im"},{"post_id":"cjcd0cb1p000ifejxl0f172a5","tag_id":"cjcd0cb2b001ffejxk7hjv9pe","_id":"cjcd0cb2e001mfejxgmefwyr8"},{"post_id":"cjcd0cb1s000lfejxnaq5d081","tag_id":"cjcd0cb2e001kfejx2s29xhb8","_id":"cjcd0cb2g001rfejxdz8jywit"},{"post_id":"cjcd0cb1u000nfejxzxz5puoe","tag_id":"cjcd0cb2g001pfejxs3z8oqyl","_id":"cjcd0cb2i001wfejxdrnyrezp"},{"post_id":"cjcd0cb1z000qfejxiz5m51su","tag_id":"cjcd0cb2h001vfejxevv9xd4y","_id":"cjcd0cb2j0021fejxby11elkb"},{"post_id":"cjcd0cb24000rfejxaasogo0l","tag_id":"cjcd0cb2j0020fejx4z7815kp","_id":"cjcd0cb2j0024fejxe1tn40fe"}],"Tag":[{"name":"linux:conf","_id":"cjcd0cb180005fejx2qy1hg2c"},{"name":"cheat sheet","_id":"cjcd0cb1e000afejxvpt8zn1y"},{"name":"linux:disk","_id":"cjcd0cb1m000ffejx28r3egwo"},{"name":"linux:net","_id":"cjcd0cb1s000kfejxjjw1ip7b"},{"name":"linux:process","_id":"cjcd0cb26000ufejx5j6t4al2"},{"name":"linux:shell","_id":"cjcd0cb270010fejx6luf0w3q"},{"name":"linux:text","_id":"cjcd0cb2b001ffejxk7hjv9pe"},{"name":"rsync","_id":"cjcd0cb2e001kfejx2s29xhb8"},{"name":"tools:git","_id":"cjcd0cb2g001pfejxs3z8oqyl"},{"name":"mvn:plugins","_id":"cjcd0cb2h001vfejxevv9xd4y"},{"name":"证券:财富先锋","_id":"cjcd0cb2j0020fejx4z7815kp"}]}}