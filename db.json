{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/leancloud-revision.js","path":"js/leancloud-revision.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1516452688398},{"_id":"themes/indigo/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1516452688398},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1516452688398},{"_id":"themes/indigo/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1516452688398},{"_id":"themes/indigo/_config.yml","hash":"be22a3dbc7a00cdac58599228a6b3e32ea695f45","modified":1524390442914},{"_id":"source/_posts/linux-conf--ulimit调参与优化.md","hash":"820bbb1e6797c0ecf0724df759c03b9929d5f6b3","modified":1517064787553},{"_id":"source/_posts/linux-init--sysvinit_systemd命令使用与对比.md","hash":"3bbb5517325ac0f8f79db5054e56c5d6b4c92985","modified":1524497684269},{"_id":"source/_posts/linux-disk--du_df使用及其区别.md","hash":"caee913770d48119679ec1506721de396773803a","modified":1523020925098},{"_id":"source/_posts/linux-disk--chattr_lsattr使用总结.md","hash":"f070b8c65aed13857961e7732e5468f479fbf0df","modified":1523095736222},{"_id":"source/_posts/elasticsearch--elasticsearch6.x升级调研报告.md","hash":"ba0569ff9dbc4a2b73d69ae1a48efc60000e4b0c","modified":1523095300155},{"_id":"source/_posts/linux-shell--bash数组与映射.md","hash":"06daf749bafbff6851b24ceaca542243c22706ed","modified":1514992691226},{"_id":"source/_posts/linux-other--lsof札记.md","hash":"7295032168dfdaac5e85b7ba9b3ed77f0be2ce9b","modified":1516454802069},{"_id":"source/_posts/linux-other--cli控制字符.md","hash":"d7141a567e9c505e7f0ee4147ea7e3020fa9549d","modified":1515330801679},{"_id":"source/_posts/linux-process--linux_signals总体认识.md","hash":"1d5be86de92f3b506f927af7a1ea3675f9c5baa6","modified":1516450214216},{"_id":"source/_posts/linux-text-sed命令整理.md","hash":"e08002174fcd8da5f0fbb7142a5f43e78a54eb43","modified":1515077927480},{"_id":"source/_posts/linux-shell--bash条件判断全梳理.md","hash":"9a193b2a70534b97dd2b2cc5cda2ea45f6bbc521","modified":1516453827025},{"_id":"source/_posts/python--python模块导入_相关基础知识梳理.md","hash":"349249cf65a80d2e2d71c3eb1a0f7c4e9aabbd41","modified":1519523277445},{"_id":"source/_posts/linux-varlog--logrotate配置与运维.md","hash":"a39a616f00080cc05c633330ae95e44a0c6f9713","modified":1517064787577},{"_id":"source/_posts/linux-shell--bash结束死循环的方法.md","hash":"0387df780421ea28436ae0f1284da10d37c57258","modified":1514907681515},{"_id":"source/_posts/rsync--rsyncd配置与运行.md","hash":"26d45c6f6eeb94849062f11e5f957982674aa9cd","modified":1517064787577},{"_id":"source/_posts/nginx-module--nginx_module_使用总结_ngx_http_gzip_module.md","hash":"313ee1cb2af838338fe5da5679699b56e35d4cb3","modified":1522035828842},{"_id":"source/_posts/python-module--python_module_使用总结_定时调度器.md","hash":"e4def94857fa76dc59afa6b49d1df286c916df0c","modified":1521875314770},{"_id":"source/_posts/ser_deser-jackson--jackson_常用配置选项梳理.md","hash":"0b70afb012b1495ea55db8e532c5994a21c88199","modified":1525161910186},{"_id":"source/_posts/python-module--python_module_使用总结_MySQLdb.md","hash":"64f27a1087237fb140f036ffc8b00eb8e3c33157","modified":1521875283418},{"_id":"source/_posts/ser_deser-jackson--JsonUtil类cheat_sheet.md","hash":"504b7c3d03019ca9a897231b60f325650392f058","modified":1525162218477},{"_id":"source/_posts/tools-git--git忽略文件的特殊场景.md","hash":"edd55249d881d55b8eda5d3f8a140d5634ab6029","modified":1518432703855},{"_id":"source/_posts/saltstack--saltstack_cheat_sheet.md","hash":"226d29e54a2e73fef7045f59ba4544a2a8b7df28","modified":1517064787577},{"_id":"source/_posts/证券-财富先锋--财富先锋2017年各股池成绩单.md","hash":"209d9a3d0632da8d03bb6071455553d449f956d8","modified":1517064787581},{"_id":"source/_posts/tools-maven--assembly_plugin.md","hash":"e2a4c39976fcadcf1b995b8f7d7c73c16cf9f85c","modified":1516454430547},{"_id":"themes/indigo/.git/HEAD","hash":"da237e0de55301608e7c572e119ab5c4e43c0e85","modified":1516452688394},{"_id":"themes/indigo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1516452681642},{"_id":"source/_posts/web--http_status_code_典型问题总结.md","hash":"4ef0e48d6bda3c830909d17ba3a0e37a86c42b7e","modified":1522078825706},{"_id":"themes/indigo/.git/index","hash":"7234e75fa319774a6c6ea8222b68c29197bc7f31","modified":1524498630249},{"_id":"themes/indigo/.git/config","hash":"10fa4a5734b512eb6bd7f2b1124b74fa407ed59d","modified":1516587720297},{"_id":"themes/indigo/.git/packed-refs","hash":"0eaf9e3da58a7d631e569353c932468e1e276bdf","modified":1516587720297},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1516452688398},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1516452688398},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1516452688398},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1516452688398},{"_id":"source/about/index.md","hash":"bbba47ce76bb6ba9db9ee6378c2d93f9ec981273","modified":1520781777328},{"_id":"themes/indigo/layout/layout.ejs","hash":"fd3bea15e410b3d597c36098c98a2128589b9de5","modified":1520949454138},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1516452688398},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1516452688398},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1516452688398},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1516452688398},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1516452688398},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1516452688398},{"_id":"source/categories/index.md","hash":"06e5f5699a70ddfe688f62b37428a4a61d331d5f","modified":1517064787585},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1516452688398},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1516452688398},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1516452688398},{"_id":"themes/indigo/layout/page.ejs","hash":"4720ec62a1f0deae27da4aa17b2b4e3ae5e028c0","modified":1516546648294},{"_id":"themes/indigo/.git/COMMIT_EDITMSG","hash":"11ac0b1ee48727f39331e33f64607df42ae777f9","modified":1524498630313},{"_id":"source/_posts/web--一个dev的拙劣前端笔记_使用jQuery_ajax上传文件.md","hash":"c00cd13e4c2c72f89195abab6605236f11bc3d75","modified":1518018209215},{"_id":"themes/indigo/.git/logs/HEAD","hash":"fc17fad673b134f68f6cc6d1b78dbfb2ac207924","modified":1524498630313},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"b197b87b120b09b68aa3d79954ed039816a88664","modified":1516452688398},{"_id":"themes/indigo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1516452681634},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1516452688398},{"_id":"source/tags/index.md","hash":"fa5259fdd512bf68a3efe41b3a2e1bd5563f7b9c","modified":1517064787593},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1516452688414},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1516452688414},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1516452688414},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1516452688414},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1516452688414},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1516452688414},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1516452688414},{"_id":"themes/indigo/source/js/leancloud-revision.js","hash":"1dc53a0e1a174708a4eee3bb60d7dc7fb84d17b8","modified":1520946544542},{"_id":"themes/indigo/source/img/wechat.jpg","hash":"c5026de0bbbc018288c9ccea674b7eca763c813e","modified":1520595805612},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1516452688414},{"_id":"themes/indigo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1516452681658},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1516452688414},{"_id":"themes/indigo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1516452681670},{"_id":"themes/indigo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1516452681658},{"_id":"themes/indigo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1516452681658},{"_id":"themes/indigo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1516452681670},{"_id":"themes/indigo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1516452681650},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1516452688414},{"_id":"themes/indigo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1516452681658},{"_id":"themes/indigo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1516452681670},{"_id":"themes/indigo/source/img/alipay.jpg","hash":"69af0023be740221c3324c041ccc3dcbffa6326d","modified":1520753918073},{"_id":"themes/indigo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1516452681650},{"_id":"themes/indigo/.git/objects/01/198878792455f5618b7865557488b79d37c3a4","hash":"a850c25edb86849611d24c32dab9657881c0099f","modified":1510388162745},{"_id":"themes/indigo/.git/objects/0c/118b0a6671ebeb9c193574038acb5af02591bf","hash":"c413807bccae1feaa41a11234f4590ead5fac200","modified":1516587696533},{"_id":"themes/indigo/.git/objects/1b/ca4ce0ce3a45563597f4dbe2e67a9d45117051","hash":"6c4fe7cd8fe457f6d33d58a181e28402ad1c144f","modified":1516587696533},{"_id":"themes/indigo/.git/objects/21/bb7c81976f6b344ba0c673d85cbc5187335255","hash":"dbc6934313cd6df7f05e42604f0be1e1563ea9f8","modified":1520950840495},{"_id":"themes/indigo/.git/objects/10/d86079fda8db494d80111d5576004d26b44129","hash":"8b11ed2753a5c0debd937f45aa9915895471fd1c","modified":1520950840515},{"_id":"themes/indigo/.git/objects/15/d200815d483b1272674c4074ada23c2d00f799","hash":"cf97abce3d785ca2f07a99c4bb1e5cad4c3be112","modified":1516587696533},{"_id":"themes/indigo/.git/objects/31/69b39c0b9772dce73ceb22e4c36a7e55b0155e","hash":"5e7d7bb9116569a90ef7b3a243de4608f20c3356","modified":1516635964051},{"_id":"themes/indigo/.git/objects/5e/2646eb443ee3cf101ea03c47416ccdcf3ef8e1","hash":"d07508f77f8fa03d4952be74495cc40af7708ba4","modified":1510388162757},{"_id":"themes/indigo/.git/objects/47/dbd92ce25de9c219af96740f121e441cca4d38","hash":"83a8ea8f0fad4a9e3839232700e936e8e1bc2bfa","modified":1510388162821},{"_id":"themes/indigo/.git/objects/16/b6879fc68b8ff55b6d8c7da448a77e395f02c4","hash":"1f6fa4151ef1e7ac78dc790cbba8ee534214ba31","modified":1516587696533},{"_id":"themes/indigo/.git/objects/63/b2fe4587df4f71a81d4b8d1715c4e150ee4182","hash":"42731b6c593075f584fc0f3b0c618bdbfa946e64","modified":1520950840515},{"_id":"themes/indigo/.git/objects/74/1aae1e9ad48b0e2d7381d4a742385cd0e79f4a","hash":"36c3f4dd5eba40fe1c763e79404f5e158414dae3","modified":1516587696533},{"_id":"themes/indigo/.git/objects/43/ba5cadc486138f64f729b49d3f0f507b9ac27f","hash":"d72df1670f544dfa43032947ce88b956d8c95ddf","modified":1516587696533},{"_id":"themes/indigo/.git/objects/18/5d12e0066b0982f9e2a7f234e348d9fbaf7c93","hash":"196c48b137c67065bc6e1fbd53651720e7bbfddf","modified":1520950840495},{"_id":"themes/indigo/.git/objects/58/5d1098207f8f9e18441b3f85137733afac8c06","hash":"2b236bad33ab6b1d680765e924051bb5cb288a90","modified":1516635964059},{"_id":"themes/indigo/.git/objects/7b/a51b67b16929681adb658e54067313d4d58f27","hash":"8abeff3479c73c42e7090cce3b850dd13192cdc5","modified":1516587696537},{"_id":"themes/indigo/.git/objects/69/0a7a3d1b9c8363abcd03d2533e19b2f8795d5a","hash":"894f32298ada29adc532213e53afb95cc8430fcd","modified":1524498630313},{"_id":"themes/indigo/.git/objects/58/5688d765691384d18037b827fa826597f9da14","hash":"1f9ebdafee56d79c22c2d3492dc60fdb171a53ab","modified":1520950828015},{"_id":"themes/indigo/.git/objects/85/9ca314f19cc9974a564c54989f21922b9c4f8d","hash":"e77d6c206344e5a6745670d580e9451b9b9ceb38","modified":1520950840495},{"_id":"themes/indigo/.git/objects/6d/28ffc1473171bec692613512e1e4254b55d806","hash":"6e19ba35844b1014fccb7484c6219f4299f06435","modified":1516587696533},{"_id":"themes/indigo/.git/objects/82/64f001a9777ef103cacfb7e0724d4e4527be6f","hash":"0b4c321c0aaba03c7eb613d3471dd0339fe04168","modified":1520950827983},{"_id":"themes/indigo/.git/objects/77/b21eda72426e9f448e7a782bc16052dd779385","hash":"38bd72001c418f98439ccb887b7b3a0a6ed419e2","modified":1524498630249},{"_id":"themes/indigo/.git/objects/96/4db42225c65c07b09500b5442cfad8fd5e8977","hash":"bda185a0ac9d2239977b8262f0558014b9182a31","modified":1516587696533},{"_id":"themes/indigo/.git/objects/a5/730cf1aa530075be1b606bc3b57f162c46ba9b","hash":"63c58d22a213f0649212ddfc95fe221a2a9d76dc","modified":1510388162785},{"_id":"themes/indigo/.git/objects/af/668b89d831c625499b69a195cd9842b83dd00d","hash":"11d0456da3e13c63b22d21425e46f49fc60333ac","modified":1516587696533},{"_id":"themes/indigo/.git/objects/d9/2f8ed1da4b240fa5e80aeefac2413c2ca7e113","hash":"4b77baf9e0fcedffa5619e151b454aba137bce93","modified":1516587696533},{"_id":"themes/indigo/.git/objects/7e/a47fe416b4c363361239964ab6d0cfa9167cd7","hash":"b776364f31480f415a6f397941bb78fa472af070","modified":1520950828015},{"_id":"themes/indigo/.git/objects/fb/192d53aabda35d3db96b6666157f29adb09d13","hash":"09debb5e827a4b6e35cde32d634ebf9f7648a1c5","modified":1520950828027},{"_id":"themes/indigo/.git/objects/8b/5a04281219b5c2142b83aa688454b67d70bedf","hash":"368d92a4487514338f8f9d0d27d4f6f5605e4b12","modified":1520950840495},{"_id":"themes/indigo/.git/objects/88/6354662296309ee37686b948ec84dff3342bd6","hash":"498ed61c67b10b2891cc2bf262ccca5f335d1b9c","modified":1524498630249},{"_id":"themes/indigo/.git/objects/bf/dd2b6c83f39e5afe51144006db271e527b7273","hash":"198b41ffc2a71ba7dc9f673afd5dc197c3de48f0","modified":1510388162785},{"_id":"themes/indigo/.git/objects/f3/dac09b70386b1669556cf461a3847199528bd0","hash":"76ea8ed48708406b497827e9379a29a8933cc83a","modified":1510388162785},{"_id":"themes/indigo/.git/objects/91/291320cd476bda679dc9888be5d3177c717811","hash":"dc42f8766623391f6ae3a04c87049c350e37fb56","modified":1516635964015},{"_id":"themes/indigo/.git/objects/pack/pack-2b82070313f1532f0e9c29725cefa112a1170904.idx","hash":"50bce8f81b677122dc574384f6fd86ae033da2d2","modified":1516452688014},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1516452688398},{"_id":"themes/indigo/.git/refs/heads/card","hash":"7da87b51a071c3927a8d33e0a37b344b5b2b986f","modified":1524498630313},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"f2c6a55a88ce694b44c46c8322293172afc00255","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"2a2d5c70804260421a71ecaefd554420f456ac8a","modified":1516548317059},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"c7ec6aa9f04839b9dfe66a500b1da11afbddbbdf","modified":1520949325859},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1516452688398},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1516452688398},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1516452688398},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1516452688398},{"_id":"themes/indigo/.git/objects/fe/065f9b0f42f94323b64d71102c1929fe270c8b","hash":"099740cc36ce9b3476cb557f435e4b98d0b41d8f","modified":1520950840515},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"5400df4c7a1cbe127280827bc2638e98898f2a03","modified":1516464844372},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1516452688414},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1516452688410},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1516452688414},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516452688406},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516452688402},{"_id":"themes/indigo/.git/logs/refs/heads/card","hash":"fc17fad673b134f68f6cc6d1b78dbfb2ac207924","modified":1524498630313},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516452688402},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1516452688414},{"_id":"themes/indigo/.git/logs/refs/remotes/origin/HEAD","hash":"b1fe6008f9e344bce371feed9c33b2b2bd7da195","modified":1516452688394},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1516452688406},{"_id":"themes/indigo/.git/objects/pack/pack-2b82070313f1532f0e9c29725cefa112a1170904.pack","hash":"02118906e88641860f0144ef671bb94e5d13718c","modified":1516452688014}],"Category":[{"name":"linux","_id":"cjgndpd5c0003j1jxbwm9vvql"},{"name":"disk","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd5r000hj1jx5404acux"},{"name":"conf","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd5u000mj1jx6j6ooii7"},{"name":"elasticsearch","_id":"cjgndpd5x000tj1jxp2y1ot2e"},{"name":"shell","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd60000zj1jxa739azjz"},{"name":"init","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd660018j1jx63ur2y9f"},{"name":"other","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd69001dj1jxjxttf53z"},{"name":"process","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6m001wj1jxtiivyikm"},{"name":"text","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6o0022j1jxefe112il"},{"name":"python","_id":"cjgndpd6r002cj1jxv6kbfrs2"},{"name":"varlog","parent":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6s002ij1jxjyxdyojt"},{"name":"rsync","_id":"cjgndpd6w002qj1jx413r9g8n"},{"name":"nginx","_id":"cjgndpd6y002wj1jxnlr31fio"},{"name":"ser/deser","_id":"cjgndpd710034j1jxqkhw1edt"},{"name":"tools","_id":"cjgndpd75003cj1jxyu3n9gyt"},{"name":"saltstack","_id":"cjgndpd77003fj1jxy8rvnmit"},{"name":"证券","_id":"cjgndpd78003ij1jxxeh2gss3"},{"name":"web","_id":"cjgndpd7a003pj1jxbhvvobnx"},{"name":"module","parent":"cjgndpd6y002wj1jxnlr31fio","_id":"cjgndpd7c003sj1jxl640yknq"},{"name":"module","parent":"cjgndpd6r002cj1jxv6kbfrs2","_id":"cjgndpd7e003wj1jx4pqe1sth"},{"name":"jackson","parent":"cjgndpd710034j1jxqkhw1edt","_id":"cjgndpd7g003zj1jx8v2ylg34"},{"name":"git","parent":"cjgndpd75003cj1jxyu3n9gyt","_id":"cjgndpd7n004ej1jxui3z6a3b"},{"name":"财富先锋","parent":"cjgndpd78003ij1jxxeh2gss3","_id":"cjgndpd7o004jj1jx131pxmuw"},{"name":"maven","parent":"cjgndpd75003cj1jxyu3n9gyt","_id":"cjgndpd7p004pj1jx86o946nd"}],"Data":[],"Page":[{"title":"about me","date":"2016-07-05T13:11:04.000Z","_content":"\n> 路漫漫其修远兮，吾将上下而求索。\n\n## **建设本站的初心**\n\nDonald Knuth 年轻时曾有一个目标, 要将计算机的前世今生全部写进书里; 今天, 他的著作《The Art of Computer Programming》为我们所熟知;\n\n## **我的联系方式**\n\n**微信** : &nbsp;XaaService\n\n**手机** : 18513585440\n\n**邮箱** : zshell.zhang@qunar.com  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com\n\n## **我的职业状态**\n\n**2016.06**: 毕业;\n**2016.07 - 2018.04**: 去哪儿网 dev;\n\n","source":"about/index.md","raw":"---\ntitle: about me\ndate: 2016-07-05 21:11:04\n---\n\n> 路漫漫其修远兮，吾将上下而求索。\n\n## **建设本站的初心**\n\nDonald Knuth 年轻时曾有一个目标, 要将计算机的前世今生全部写进书里; 今天, 他的著作《The Art of Computer Programming》为我们所熟知;\n\n## **我的联系方式**\n\n**微信** : &nbsp;XaaService\n\n**手机** : 18513585440\n\n**邮箱** : zshell.zhang@qunar.com  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com\n\n## **我的职业状态**\n\n**2016.06**: 毕业;\n**2016.07 - 2018.04**: 去哪儿网 dev;\n\n","updated":"2018-03-11T15:22:57.328Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjgndpd590001j1jx29c4wxzt","content":"<blockquote>\n<p>路漫漫其修远兮，吾将上下而求索。</p>\n</blockquote>\n<h2 id=\"建设本站的初心\"><a href=\"#建设本站的初心\" class=\"headerlink\" title=\"建设本站的初心\"></a><strong>建设本站的初心</strong></h2><p>Donald Knuth 年轻时曾有一个目标, 要将计算机的前世今生全部写进书里; 今天, 他的著作《The Art of Computer Programming》为我们所熟知;</p>\n<h2 id=\"我的联系方式\"><a href=\"#我的联系方式\" class=\"headerlink\" title=\"我的联系方式\"></a><strong>我的联系方式</strong></h2><p><strong>微信</strong> : &nbsp;XaaService</p>\n<p><strong>手机</strong> : 18513585440</p>\n<p><strong>邮箱</strong> : zshell.zhang@qunar.com<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com</p>\n<h2 id=\"我的职业状态\"><a href=\"#我的职业状态\" class=\"headerlink\" title=\"我的职业状态\"></a><strong>我的职业状态</strong></h2><p><strong>2016.06</strong>: 毕业;<br><strong>2016.07 - 2018.04</strong>: 去哪儿网 dev;</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>路漫漫其修远兮，吾将上下而求索。</p>\n</blockquote>\n<h2 id=\"建设本站的初心\"><a href=\"#建设本站的初心\" class=\"headerlink\" title=\"建设本站的初心\"></a><strong>建设本站的初心</strong></h2><p>Donald Knuth 年轻时曾有一个目标, 要将计算机的前世今生全部写进书里; 今天, 他的著作《The Art of Computer Programming》为我们所熟知;</p>\n<h2 id=\"我的联系方式\"><a href=\"#我的联系方式\" class=\"headerlink\" title=\"我的联系方式\"></a><strong>我的联系方式</strong></h2><p><strong>微信</strong> : &nbsp;XaaService</p>\n<p><strong>手机</strong> : 18513585440</p>\n<p><strong>邮箱</strong> : zshell.zhang@qunar.com<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xaaservice@gmail.com</p>\n<h2 id=\"我的职业状态\"><a href=\"#我的职业状态\" class=\"headerlink\" title=\"我的职业状态\"></a><strong>我的职业状态</strong></h2><p><strong>2016.06</strong>: 毕业;<br><strong>2016.07 - 2018.04</strong>: 去哪儿网 dev;</p>\n"},{"title":"categories","date":"2016-08-01T11:40:08.000Z","layout":"categories","comments":0,"_content":"\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-01 19:40:08\nlayout: categories\ncomments: false\n---\n\n","updated":"2018-01-27T14:53:07.585Z","path":"categories/index.html","_id":"cjgndpd800057j1jxbuhlu7ds","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-07-05T13:58:26.000Z","layout":"tags","comment":false,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-05 21:58:26\nlayout: tags\ncomment: false\n---\n","updated":"2018-01-27T14:53:07.593Z","path":"tags/index.html","comments":1,"_id":"cjgndpd8n005gj1jxm1nseikl","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ulimit 调参与优化","date":"2017-10-28T15:23:05.000Z","_content":"\n> ulimit 未正确设置是很多线上故障的根源: \n`Too many open files`;\n`java.lang.OutOfMemoryError: unable to create new native thread`;\n对于生产环境来说, ulimit 的调参优化至关重要;\n本文详细介绍并梳理一下与 ulimit 相关的林林总总;\n\n<!--more-->\n\n------\n\nulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;\n注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;\n在 `/etc/security/limits.conf` 文件中的第一段注释如下:\n> This file sets the resource limits for the users logged in via PAM.\nIt does not affect resource limits of the system services.\n\n关于 linux PAM 相关的内容, 可以前往另外一篇文章: [pam 认证与配置]();\n\n## **ulimit 基本信息**\n``` bash\n# 查看所有 ulimit 设置\n> ulimit -a\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 15018\nmax locked memory       (kbytes, -l) 64             # 每个进程可以锁住而不被 swap 出去的内存\nmax memory size         (kbytes, -m) unlimited      # 每个进程可使用的最大内存大小\nopen files                      (-n) 1024           # 每个进程可打开的文件数\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192           # 每个进程可使用的最大堆栈大小\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 4096           # 每个用户的最大进程数\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n## **ulimit 需要优化的场景及待优化参数**\nlinux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;\n### **场景1: tomcat web 容器 **\n一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;\n如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;\n所以, 可以对该机器的 ulimit 作出如下调整:\n``` bash\n1. max memory size -> unlimit\n2. open files -> 65536\n3. stack size -> unlimit\n```\n另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 `java.lang.OutOfMemoryError: unable to create new native thread` 的异常;\n最后确定问题的原因是 `ulimit -u` max user processes 的数量配置过低, 增大后解决问题:\n``` bash\n4. max user processes -> 65535\n```\n具体的情况可以参见这篇文章: [dubbo 服务治理系统设计]();\n\n### **场景2: elasticsearch data node**\n32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: '-Xmx30g -Xms30g', 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;\n所以, 可以对该机器的 ulimit 作出如下调整:\n```\n1. max locked memory -> unlimit\n2. max memory size -> unlimit\n3. open files -> 65536\n4. stack size -> unlimit\n```\n对于 max locked memory, elasticsearch.yml 本身有一个配置项 `bootstrap.mlockall`/`bootstrap.memory_lock` = true, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的; 只是, elasticsearch 试图自己主动改变该配置能生效的前提, 是 ulimit 配置文件里要允许其这样设置, 具体的逻辑请看本文下下节: [ulimit 的永久修改](#ulimit-的永久修改);\n\n&nbsp;\n另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;\n以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;\n\n## **ulimit 当前 session 下的临时修改**\nulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;\n其调整方法也已经在 `ulimit -a` 中被注明了:\n``` bash\n# max locked mem\nulimit -l unlimit\n# max mem size\nulimit -m unlimit\n# open files\nulimit -n 65536\n# max user processes\nulimit -u 65536\n...\n```\n\n## **ulimit 的永久修改**\n上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:\n\n1. `/etc/security/limits.conf`;\n2. `/etc/security/limits.d 目录`;\n\n这些文件用于持久化每个用户的资源限制设置;\n其中, `/etc/security/limits.conf` 自不必说, 这是配置 ulimit 的主要文件:\n``` bash\ndomain  限制的目标:\n        username    用户名;\n        @groupname  组名, 需加 '@' 前缀;\n        *           通配所有用户/组;\n        %groupname  这种写法只能用于限制 某个 group 的 maxlogin limit, 即最大登陆用户数限制;\n        \ntype    限制的属性:\n        `soft` 对 domain 给出的用户设置默认值; \n        `hard` 限制 domain 给出的用户自己所能设置的最大值; \n        `-` 将 soft 与 hard 都设为相同的值;\n        \nitem    限制的资源类型, 与 ulimit 所限制的资源类型大致相同:\n        - core - limits the core file size (KB)\n        - data - max data size (KB)\n        - fsize - maximum filesize (KB)\n        - memlock - max locked-in-memory address space (KB)\n        - nofile - max number of open file descriptors\n        - rss - max resident set size (KB)\n        - stack - max stack size (KB)\n        - cpu - max CPU time (MIN)\n        - nproc - max number of processes\n        - as - address space limit (KB)\n        - maxlogins - max number of logins for this user\n        - maxsyslogins - max number of logins on the system\n        - priority - the priority to run user process with\n        - locks - max number of file locks the user can hold\n        - sigpending - max number of pending signals\n        - msgqueue - max memory used by POSIX message queues (bytes)\n        - nice - max nice priority allowed to raise to values: [-20, 19]\n        - rtprio - max realtime priority\n\nvalue   限制的具体值;\n```\n以下是一个具体的例子:\n``` bash\n#<domain>        <type>     <item>     <value>\n*                 soft      nproc       65536\n*                 hard      nproc       65536\n*                 -         nofile      65536\n%guest            -         maxlogins   10\nelastic           -         memlock     unlimit\n@dev              hard      fsize       10737418240\n```\n如上所示, 系统允许 elastic 用户的最大 memlock 为 unlimit, 如果这个值被设置为了一个比较小的值, 那么上上节 elasticsearch 试图将其改成 unlimit 便会失败;\n\n&nbsp;\n而对于 `/etc/security/limits.d` 目录的作用,  `/etc/security/limits.conf` 文件中的第二段与第三段有如下注释:\n\n> Also note that configuration files in /etc/security/limits.d directory,\nwhich are read in alphabetical order, override the settings in this\nfile in case the domain is the same or more specific.\n&nbsp;\nThat means for example that setting a limit for wildcard domain here\ncan be overriden with a wildcard setting in a config file in the\nsubdirectory, but a user specific setting here can be overriden only\nwith a user specific setting in the subdirectory.\n\n也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;\n举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 `20-nproc.conf`:\n``` bash\n# Default limit for number of user's processes to prevent\n# accidental fork bombs.\n# See rhbz #432903 for reasoning.\n*          soft    nproc     4096\nroot       soft    nproc     unlimited\n```\n这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;\n如果修改 limits.conf 文件:\n``` bash\n*          hard    nproc     65535\n```\n这时会发现, 除非自己试图 `ulimit -u` 修改 max processes, 否则这个值会依然被限制为 4096;\n而要想将该值默认放到 65535, 就必须修改 `20-nproc.conf` 文件方才生效;\n\n### **永久修改生效的必要条件**\n\n## **站内相关文章**\n- [pam 认证与配置]()\n- [dubbo 服务治理系统设计]()\n\n## **参考链接**\n- [ulimit 命令详解](http://www.cnblogs.com/zengkefu/p/5649407.html)\n- [linux /etc/security/limits.conf的相关说明](http://blog.csdn.net/taijianyu/article/details/5976319)\n\n","source":"_posts/linux-conf--ulimit调参与优化.md","raw":"---\ntitle: ulimit 调参与优化\ndate: 2017-10-28 23:23:05\ncategories:\n - linux\n - conf\ntags:\n - linux:conf\n---\n\n> ulimit 未正确设置是很多线上故障的根源: \n`Too many open files`;\n`java.lang.OutOfMemoryError: unable to create new native thread`;\n对于生产环境来说, ulimit 的调参优化至关重要;\n本文详细介绍并梳理一下与 ulimit 相关的林林总总;\n\n<!--more-->\n\n------\n\nulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;\n注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;\n在 `/etc/security/limits.conf` 文件中的第一段注释如下:\n> This file sets the resource limits for the users logged in via PAM.\nIt does not affect resource limits of the system services.\n\n关于 linux PAM 相关的内容, 可以前往另外一篇文章: [pam 认证与配置]();\n\n## **ulimit 基本信息**\n``` bash\n# 查看所有 ulimit 设置\n> ulimit -a\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 15018\nmax locked memory       (kbytes, -l) 64             # 每个进程可以锁住而不被 swap 出去的内存\nmax memory size         (kbytes, -m) unlimited      # 每个进程可使用的最大内存大小\nopen files                      (-n) 1024           # 每个进程可打开的文件数\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192           # 每个进程可使用的最大堆栈大小\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 4096           # 每个用户的最大进程数\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n## **ulimit 需要优化的场景及待优化参数**\nlinux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;\n### **场景1: tomcat web 容器 **\n一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;\n如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;\n所以, 可以对该机器的 ulimit 作出如下调整:\n``` bash\n1. max memory size -> unlimit\n2. open files -> 65536\n3. stack size -> unlimit\n```\n另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 `java.lang.OutOfMemoryError: unable to create new native thread` 的异常;\n最后确定问题的原因是 `ulimit -u` max user processes 的数量配置过低, 增大后解决问题:\n``` bash\n4. max user processes -> 65535\n```\n具体的情况可以参见这篇文章: [dubbo 服务治理系统设计]();\n\n### **场景2: elasticsearch data node**\n32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: '-Xmx30g -Xms30g', 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;\n所以, 可以对该机器的 ulimit 作出如下调整:\n```\n1. max locked memory -> unlimit\n2. max memory size -> unlimit\n3. open files -> 65536\n4. stack size -> unlimit\n```\n对于 max locked memory, elasticsearch.yml 本身有一个配置项 `bootstrap.mlockall`/`bootstrap.memory_lock` = true, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的; 只是, elasticsearch 试图自己主动改变该配置能生效的前提, 是 ulimit 配置文件里要允许其这样设置, 具体的逻辑请看本文下下节: [ulimit 的永久修改](#ulimit-的永久修改);\n\n&nbsp;\n另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;\n以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;\n\n## **ulimit 当前 session 下的临时修改**\nulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;\n其调整方法也已经在 `ulimit -a` 中被注明了:\n``` bash\n# max locked mem\nulimit -l unlimit\n# max mem size\nulimit -m unlimit\n# open files\nulimit -n 65536\n# max user processes\nulimit -u 65536\n...\n```\n\n## **ulimit 的永久修改**\n上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:\n\n1. `/etc/security/limits.conf`;\n2. `/etc/security/limits.d 目录`;\n\n这些文件用于持久化每个用户的资源限制设置;\n其中, `/etc/security/limits.conf` 自不必说, 这是配置 ulimit 的主要文件:\n``` bash\ndomain  限制的目标:\n        username    用户名;\n        @groupname  组名, 需加 '@' 前缀;\n        *           通配所有用户/组;\n        %groupname  这种写法只能用于限制 某个 group 的 maxlogin limit, 即最大登陆用户数限制;\n        \ntype    限制的属性:\n        `soft` 对 domain 给出的用户设置默认值; \n        `hard` 限制 domain 给出的用户自己所能设置的最大值; \n        `-` 将 soft 与 hard 都设为相同的值;\n        \nitem    限制的资源类型, 与 ulimit 所限制的资源类型大致相同:\n        - core - limits the core file size (KB)\n        - data - max data size (KB)\n        - fsize - maximum filesize (KB)\n        - memlock - max locked-in-memory address space (KB)\n        - nofile - max number of open file descriptors\n        - rss - max resident set size (KB)\n        - stack - max stack size (KB)\n        - cpu - max CPU time (MIN)\n        - nproc - max number of processes\n        - as - address space limit (KB)\n        - maxlogins - max number of logins for this user\n        - maxsyslogins - max number of logins on the system\n        - priority - the priority to run user process with\n        - locks - max number of file locks the user can hold\n        - sigpending - max number of pending signals\n        - msgqueue - max memory used by POSIX message queues (bytes)\n        - nice - max nice priority allowed to raise to values: [-20, 19]\n        - rtprio - max realtime priority\n\nvalue   限制的具体值;\n```\n以下是一个具体的例子:\n``` bash\n#<domain>        <type>     <item>     <value>\n*                 soft      nproc       65536\n*                 hard      nproc       65536\n*                 -         nofile      65536\n%guest            -         maxlogins   10\nelastic           -         memlock     unlimit\n@dev              hard      fsize       10737418240\n```\n如上所示, 系统允许 elastic 用户的最大 memlock 为 unlimit, 如果这个值被设置为了一个比较小的值, 那么上上节 elasticsearch 试图将其改成 unlimit 便会失败;\n\n&nbsp;\n而对于 `/etc/security/limits.d` 目录的作用,  `/etc/security/limits.conf` 文件中的第二段与第三段有如下注释:\n\n> Also note that configuration files in /etc/security/limits.d directory,\nwhich are read in alphabetical order, override the settings in this\nfile in case the domain is the same or more specific.\n&nbsp;\nThat means for example that setting a limit for wildcard domain here\ncan be overriden with a wildcard setting in a config file in the\nsubdirectory, but a user specific setting here can be overriden only\nwith a user specific setting in the subdirectory.\n\n也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;\n举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 `20-nproc.conf`:\n``` bash\n# Default limit for number of user's processes to prevent\n# accidental fork bombs.\n# See rhbz #432903 for reasoning.\n*          soft    nproc     4096\nroot       soft    nproc     unlimited\n```\n这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;\n如果修改 limits.conf 文件:\n``` bash\n*          hard    nproc     65535\n```\n这时会发现, 除非自己试图 `ulimit -u` 修改 max processes, 否则这个值会依然被限制为 4096;\n而要想将该值默认放到 65535, 就必须修改 `20-nproc.conf` 文件方才生效;\n\n### **永久修改生效的必要条件**\n\n## **站内相关文章**\n- [pam 认证与配置]()\n- [dubbo 服务治理系统设计]()\n\n## **参考链接**\n- [ulimit 命令详解](http://www.cnblogs.com/zengkefu/p/5649407.html)\n- [linux /etc/security/limits.conf的相关说明](http://blog.csdn.net/taijianyu/article/details/5976319)\n\n","slug":"linux-conf--ulimit调参与优化","published":1,"updated":"2018-01-27T14:53:07.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd550000j1jxaqi6uods","content":"<blockquote>\n<p>ulimit 未正确设置是很多线上故障的根源:<br><code>Too many open files</code>;<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>;<br>对于生产环境来说, ulimit 的调参优化至关重要;<br>本文详细介绍并梳理一下与 ulimit 相关的林林总总;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p>ulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;<br>注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;<br>在 <code>/etc/security/limits.conf</code> 文件中的第一段注释如下:</p>\n<blockquote>\n<p>This file sets the resource limits for the users logged in via PAM.<br>It does not affect resource limits of the system services.</p>\n</blockquote>\n<p>关于 linux PAM 相关的内容, 可以前往另外一篇文章: <a href=\"\">pam 认证与配置</a>;</p>\n<h2 id=\"ulimit-基本信息\"><a href=\"#ulimit-基本信息\" class=\"headerlink\" title=\"ulimit 基本信息\"></a><strong>ulimit 基本信息</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 ulimit 设置</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">ulimit</span> -a</span><br><span class=\"line\">core file size          (blocks, -c) 0</span><br><span class=\"line\">data seg size           (kbytes, -d) unlimited</span><br><span class=\"line\">scheduling priority             (-e) 0</span><br><span class=\"line\">file size               (blocks, -f) unlimited</span><br><span class=\"line\">pending signals                 (-i) 15018</span><br><span class=\"line\">max locked memory       (kbytes, -l) 64             <span class=\"comment\"># 每个进程可以锁住而不被 swap 出去的内存</span></span><br><span class=\"line\">max memory size         (kbytes, -m) unlimited      <span class=\"comment\"># 每个进程可使用的最大内存大小</span></span><br><span class=\"line\">open files                      (-n) 1024           <span class=\"comment\"># 每个进程可打开的文件数</span></span><br><span class=\"line\">pipe size            (512 bytes, -p) 8</span><br><span class=\"line\">POSIX message queues     (bytes, -q) 819200</span><br><span class=\"line\">real-time priority              (-r) 0</span><br><span class=\"line\">stack size              (kbytes, -s) 8192           <span class=\"comment\"># 每个进程可使用的最大堆栈大小</span></span><br><span class=\"line\">cpu time               (seconds, -t) unlimited</span><br><span class=\"line\">max user processes              (-u) 4096           <span class=\"comment\"># 每个用户的最大进程数</span></span><br><span class=\"line\">virtual memory          (kbytes, -v) unlimited</span><br><span class=\"line\">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>\n<h2 id=\"ulimit-需要优化的场景及待优化参数\"><a href=\"#ulimit-需要优化的场景及待优化参数\" class=\"headerlink\" title=\"ulimit 需要优化的场景及待优化参数\"></a><strong>ulimit 需要优化的场景及待优化参数</strong></h2><p>linux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;</p>\n<h3 id=\"场景1-tomcat-web-容器\"><a href=\"#场景1-tomcat-web-容器\" class=\"headerlink\" title=\"场景1: tomcat web 容器 \"></a><strong>场景1: tomcat web 容器 </strong></h3><p>一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;<br>如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max memory size -&gt; <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">2. open files -&gt; 65536</span><br><span class=\"line\">3. stack size -&gt; <span class=\"built_in\">unlimit</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 <code>java.lang.OutOfMemoryError: unable to create new native thread</code> 的异常;<br>最后确定问题的原因是 <code>ulimit -u</code> max user processes 的数量配置过低, 增大后解决问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. max user processes -&gt; 65535</span><br></pre></td></tr></table></figure></p>\n<p>具体的情况可以参见这篇文章: <a href=\"\">dubbo 服务治理系统设计</a>;</p>\n<h3 id=\"场景2-elasticsearch-data-node\"><a href=\"#场景2-elasticsearch-data-node\" class=\"headerlink\" title=\"场景2: elasticsearch data node\"></a><strong>场景2: elasticsearch data node</strong></h3><p>32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: ‘-Xmx30g -Xms30g’, 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max locked memory -&gt; unlimit</span><br><span class=\"line\">2. max memory size -&gt; unlimit</span><br><span class=\"line\">3. open files -&gt; 65536</span><br><span class=\"line\">4. stack size -&gt; unlimit</span><br></pre></td></tr></table></figure></p>\n<p>对于 max locked memory, elasticsearch.yml 本身有一个配置项 <code>bootstrap.mlockall</code>/<code>bootstrap.memory_lock</code> = true, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的; 只是, elasticsearch 试图自己主动改变该配置能生效的前提, 是 ulimit 配置文件里要允许其这样设置, 具体的逻辑请看本文下下节: <a href=\"#ulimit-的永久修改\">ulimit 的永久修改</a>;</p>\n<p>&nbsp;<br>另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;<br>以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;</p>\n<h2 id=\"ulimit-当前-session-下的临时修改\"><a href=\"#ulimit-当前-session-下的临时修改\" class=\"headerlink\" title=\"ulimit 当前 session 下的临时修改\"></a><strong>ulimit 当前 session 下的临时修改</strong></h2><p>ulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;<br>其调整方法也已经在 <code>ulimit -a</code> 中被注明了:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># max locked mem</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -l <span class=\"built_in\">unlimit</span></span><br><span class=\"line\"><span class=\"comment\"># max mem size</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -m <span class=\"built_in\">unlimit</span></span><br><span class=\"line\"><span class=\"comment\"># open files</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -n 65536</span><br><span class=\"line\"><span class=\"comment\"># max user processes</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -u 65536</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ulimit-的永久修改\"><a href=\"#ulimit-的永久修改\" class=\"headerlink\" title=\"ulimit 的永久修改\"></a><strong>ulimit 的永久修改</strong></h2><p>上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:</p>\n<ol>\n<li><code>/etc/security/limits.conf</code>;</li>\n<li><code>/etc/security/limits.d 目录</code>;</li>\n</ol>\n<p>这些文件用于持久化每个用户的资源限制设置;<br>其中, <code>/etc/security/limits.conf</code> 自不必说, 这是配置 ulimit 的主要文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">domain  限制的目标:</span><br><span class=\"line\">        username    用户名;</span><br><span class=\"line\">        @groupname  组名, 需加 <span class=\"string\">'@'</span> 前缀;</span><br><span class=\"line\">        *           通配所有用户/组;</span><br><span class=\"line\">        %groupname  这种写法只能用于限制 某个 group 的 maxlogin <span class=\"built_in\">limit</span>, 即最大登陆用户数限制;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"built_in\">type</span>    限制的属性:</span><br><span class=\"line\">        `soft` 对 domain 给出的用户设置默认值; </span><br><span class=\"line\">        `hard` 限制 domain 给出的用户自己所能设置的最大值; </span><br><span class=\"line\">        `-` 将 soft 与 hard 都设为相同的值;</span><br><span class=\"line\">        </span><br><span class=\"line\">item    限制的资源类型, 与 <span class=\"built_in\">ulimit</span> 所限制的资源类型大致相同:</span><br><span class=\"line\">        - core - limits the core file size (KB)</span><br><span class=\"line\">        - data - max data size (KB)</span><br><span class=\"line\">        - fsize - maximum filesize (KB)</span><br><span class=\"line\">        - memlock - max locked-in-memory address space (KB)</span><br><span class=\"line\">        - nofile - max number of open file descriptors</span><br><span class=\"line\">        - rss - max resident <span class=\"built_in\">set</span> size (KB)</span><br><span class=\"line\">        - stack - max stack size (KB)</span><br><span class=\"line\">        - cpu - max CPU time (MIN)</span><br><span class=\"line\">        - nproc - max number of processes</span><br><span class=\"line\">        - as - address space <span class=\"built_in\">limit</span> (KB)</span><br><span class=\"line\">        - maxlogins - max number of logins <span class=\"keyword\">for</span> this user</span><br><span class=\"line\">        - maxsyslogins - max number of logins on the system</span><br><span class=\"line\">        - priority - the priority to run user process with</span><br><span class=\"line\">        - locks - max number of file locks the user can hold</span><br><span class=\"line\">        - sigpending - max number of pending signals</span><br><span class=\"line\">        - msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class=\"line\">        - nice - max nice priority allowed to raise to values: [-20, 19]</span><br><span class=\"line\">        - rtprio - max realtime priority</span><br><span class=\"line\"></span><br><span class=\"line\">value   限制的具体值;</span><br></pre></td></tr></table></figure></p>\n<p>以下是一个具体的例子:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#&lt;domain&gt;        &lt;type&gt;     &lt;item&gt;     &lt;value&gt;</span></span><br><span class=\"line\">*                 soft      nproc       65536</span><br><span class=\"line\">*                 hard      nproc       65536</span><br><span class=\"line\">*                 -         nofile      65536</span><br><span class=\"line\">%guest            -         maxlogins   10</span><br><span class=\"line\">elastic           -         memlock     <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">@dev              hard      fsize       10737418240</span><br></pre></td></tr></table></figure></p>\n<p>如上所示, 系统允许 elastic 用户的最大 memlock 为 unlimit, 如果这个值被设置为了一个比较小的值, 那么上上节 elasticsearch 试图将其改成 unlimit 便会失败;</p>\n<p>&nbsp;<br>而对于 <code>/etc/security/limits.d</code> 目录的作用,  <code>/etc/security/limits.conf</code> 文件中的第二段与第三段有如下注释:</p>\n<blockquote>\n<p>Also note that configuration files in /etc/security/limits.d directory,<br>which are read in alphabetical order, override the settings in this<br>file in case the domain is the same or more specific.<br>&nbsp;<br>That means for example that setting a limit for wildcard domain here<br>can be overriden with a wildcard setting in a config file in the<br>subdirectory, but a user specific setting here can be overriden only<br>with a user specific setting in the subdirectory.</p>\n</blockquote>\n<p>也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;<br>举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 <code>20-nproc.conf</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default limit for number of user's processes to prevent</span></span><br><span class=\"line\"><span class=\"comment\"># accidental fork bombs.</span></span><br><span class=\"line\"><span class=\"comment\"># See rhbz #432903 for reasoning.</span></span><br><span class=\"line\">*          soft    nproc     4096</span><br><span class=\"line\">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure></p>\n<p>这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;<br>如果修改 limits.conf 文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*          hard    nproc     65535</span><br></pre></td></tr></table></figure></p>\n<p>这时会发现, 除非自己试图 <code>ulimit -u</code> 修改 max processes, 否则这个值会依然被限制为 4096;<br>而要想将该值默认放到 65535, 就必须修改 <code>20-nproc.conf</code> 文件方才生效;</p>\n<h3 id=\"永久修改生效的必要条件\"><a href=\"#永久修改生效的必要条件\" class=\"headerlink\" title=\"永久修改生效的必要条件\"></a><strong>永久修改生效的必要条件</strong></h3><h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">pam 认证与配置</a></li>\n<li><a href=\"\">dubbo 服务治理系统设计</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/zengkefu/p/5649407.html\" target=\"_blank\" rel=\"noopener\">ulimit 命令详解</a></li>\n<li><a href=\"http://blog.csdn.net/taijianyu/article/details/5976319\" target=\"_blank\" rel=\"noopener\">linux /etc/security/limits.conf的相关说明</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>ulimit 未正确设置是很多线上故障的根源:<br><code>Too many open files</code>;<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>;<br>对于生产环境来说, ulimit 的调参优化至关重要;<br>本文详细介绍并梳理一下与 ulimit 相关的林林总总;</p>\n</blockquote>","more":"<hr>\n<p>ulimit 是 linux 对于每个通过 PAM 登录的用户 ( 每个进程 ) 的资源最大使用限制的设置;<br>注意, 这里仅仅对通过 PAM 登陆的用户起作用, 而对于那些随系统启动而启动的 daemon service, ulimit 是不会去限制其资源使用的;<br>在 <code>/etc/security/limits.conf</code> 文件中的第一段注释如下:</p>\n<blockquote>\n<p>This file sets the resource limits for the users logged in via PAM.<br>It does not affect resource limits of the system services.</p>\n</blockquote>\n<p>关于 linux PAM 相关的内容, 可以前往另外一篇文章: <a href=\"\">pam 认证与配置</a>;</p>\n<h2 id=\"ulimit-基本信息\"><a href=\"#ulimit-基本信息\" class=\"headerlink\" title=\"ulimit 基本信息\"></a><strong>ulimit 基本信息</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有 ulimit 设置</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">ulimit</span> -a</span><br><span class=\"line\">core file size          (blocks, -c) 0</span><br><span class=\"line\">data seg size           (kbytes, -d) unlimited</span><br><span class=\"line\">scheduling priority             (-e) 0</span><br><span class=\"line\">file size               (blocks, -f) unlimited</span><br><span class=\"line\">pending signals                 (-i) 15018</span><br><span class=\"line\">max locked memory       (kbytes, -l) 64             <span class=\"comment\"># 每个进程可以锁住而不被 swap 出去的内存</span></span><br><span class=\"line\">max memory size         (kbytes, -m) unlimited      <span class=\"comment\"># 每个进程可使用的最大内存大小</span></span><br><span class=\"line\">open files                      (-n) 1024           <span class=\"comment\"># 每个进程可打开的文件数</span></span><br><span class=\"line\">pipe size            (512 bytes, -p) 8</span><br><span class=\"line\">POSIX message queues     (bytes, -q) 819200</span><br><span class=\"line\">real-time priority              (-r) 0</span><br><span class=\"line\">stack size              (kbytes, -s) 8192           <span class=\"comment\"># 每个进程可使用的最大堆栈大小</span></span><br><span class=\"line\">cpu time               (seconds, -t) unlimited</span><br><span class=\"line\">max user processes              (-u) 4096           <span class=\"comment\"># 每个用户的最大进程数</span></span><br><span class=\"line\">virtual memory          (kbytes, -v) unlimited</span><br><span class=\"line\">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>\n<h2 id=\"ulimit-需要优化的场景及待优化参数\"><a href=\"#ulimit-需要优化的场景及待优化参数\" class=\"headerlink\" title=\"ulimit 需要优化的场景及待优化参数\"></a><strong>ulimit 需要优化的场景及待优化参数</strong></h2><p>linux 默认的 ulimit 限制, 是出于安全考虑, 设置的有些保守; 实际的生产环境下, 往往需要对其作出适当的调整, 方可发挥机器的最大性能;</p>\n<h3 id=\"场景1-tomcat-web-容器\"><a href=\"#场景1-tomcat-web-容器\" class=\"headerlink\" title=\"场景1: tomcat web 容器 \"></a><strong>场景1: tomcat web 容器 </strong></h3><p>一台 4C4G60G 的标准虚拟主机, 其上部署了一个 tomcat 实例, 启动 catalina 进程的是 tomcat:tomcat 用户;<br>如果该服务是一个网络 IO 密集的应用, 需要打开的 socket file 远不止 1024, ulimit 设置的 max open files 就会限制其性能; 另外, 该主机只部署了这一个服务, tomcat 用户是唯一一个需要占用大量资源的用户, ulimit 对单个用户的限制便会造成机器资源闲置, 极低的使用率, 降低 web 服务的性能;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max memory size -&gt; <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">2. open files -&gt; 65536</span><br><span class=\"line\">3. stack size -&gt; <span class=\"built_in\">unlimit</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 我们还遇到一种特殊的情况, 用标准配置虚拟机跑 dubbo 的服务治理: 当时发现, 如果服务注册到 zookeeper 的数量达到一定级别, 线上就会报 <code>java.lang.OutOfMemoryError: unable to create new native thread</code> 的异常;<br>最后确定问题的原因是 <code>ulimit -u</code> max user processes 的数量配置过低, 增大后解决问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. max user processes -&gt; 65535</span><br></pre></td></tr></table></figure></p>\n<p>具体的情况可以参见这篇文章: <a href=\"\">dubbo 服务治理系统设计</a>;</p>\n<h3 id=\"场景2-elasticsearch-data-node\"><a href=\"#场景2-elasticsearch-data-node\" class=\"headerlink\" title=\"场景2: elasticsearch data node\"></a><strong>场景2: elasticsearch data node</strong></h3><p>32C64G4T 的配置, 为确保指针压缩特性被打开, 一般我们都会控制 jvm 的最大堆内存与最小堆内存: ‘-Xmx30g -Xms30g’, 并希望能锁住所有的内存, 避免堆内存被 swap 到磁盘, 降低了搜索性能; 这种场景下我们当然不希望 ulimit 限制了 max memory size 以及 max locked memory;<br>所以, 可以对该机器的 ulimit 作出如下调整:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. max locked memory -&gt; unlimit</span><br><span class=\"line\">2. max memory size -&gt; unlimit</span><br><span class=\"line\">3. open files -&gt; 65536</span><br><span class=\"line\">4. stack size -&gt; unlimit</span><br></pre></td></tr></table></figure></p>\n<p>对于 max locked memory, elasticsearch.yml 本身有一个配置项 <code>bootstrap.mlockall</code>/<code>bootstrap.memory_lock</code> = true, 其背后实现就是通过类似于 ulimit -l unlimit 的方法完成的; 只是, elasticsearch 试图自己主动改变该配置能生效的前提, 是 ulimit 配置文件里要允许其这样设置, 具体的逻辑请看本文下下节: <a href=\"#ulimit-的永久修改\">ulimit 的永久修改</a>;</p>\n<p>&nbsp;<br>另外, 还有其他的一些场景, 可能需要调整其他参数以作优化, 此处不一而论;<br>以上是需要调整 ulimit 参数的场景举例, 下面的内容是关于如何 临时/永久 修改 ulimit 设置;</p>\n<h2 id=\"ulimit-当前-session-下的临时修改\"><a href=\"#ulimit-当前-session-下的临时修改\" class=\"headerlink\" title=\"ulimit 当前 session 下的临时修改\"></a><strong>ulimit 当前 session 下的临时修改</strong></h2><p>ulimit 的临时调整, 只对当前 session 下的当前用户, 以及当前用户所起的进程生效;<br>其调整方法也已经在 <code>ulimit -a</code> 中被注明了:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># max locked mem</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -l <span class=\"built_in\">unlimit</span></span><br><span class=\"line\"><span class=\"comment\"># max mem size</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -m <span class=\"built_in\">unlimit</span></span><br><span class=\"line\"><span class=\"comment\"># open files</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -n 65536</span><br><span class=\"line\"><span class=\"comment\"># max user processes</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -u 65536</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ulimit-的永久修改\"><a href=\"#ulimit-的永久修改\" class=\"headerlink\" title=\"ulimit 的永久修改\"></a><strong>ulimit 的永久修改</strong></h2><p>上一节的方法, 只能在当前 session 下对当前用户作临时调整, 而 要想对 ulimit 作永久调整, 需要修改一些配置文件:</p>\n<ol>\n<li><code>/etc/security/limits.conf</code>;</li>\n<li><code>/etc/security/limits.d 目录</code>;</li>\n</ol>\n<p>这些文件用于持久化每个用户的资源限制设置;<br>其中, <code>/etc/security/limits.conf</code> 自不必说, 这是配置 ulimit 的主要文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">domain  限制的目标:</span><br><span class=\"line\">        username    用户名;</span><br><span class=\"line\">        @groupname  组名, 需加 <span class=\"string\">'@'</span> 前缀;</span><br><span class=\"line\">        *           通配所有用户/组;</span><br><span class=\"line\">        %groupname  这种写法只能用于限制 某个 group 的 maxlogin <span class=\"built_in\">limit</span>, 即最大登陆用户数限制;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"built_in\">type</span>    限制的属性:</span><br><span class=\"line\">        `soft` 对 domain 给出的用户设置默认值; </span><br><span class=\"line\">        `hard` 限制 domain 给出的用户自己所能设置的最大值; </span><br><span class=\"line\">        `-` 将 soft 与 hard 都设为相同的值;</span><br><span class=\"line\">        </span><br><span class=\"line\">item    限制的资源类型, 与 <span class=\"built_in\">ulimit</span> 所限制的资源类型大致相同:</span><br><span class=\"line\">        - core - limits the core file size (KB)</span><br><span class=\"line\">        - data - max data size (KB)</span><br><span class=\"line\">        - fsize - maximum filesize (KB)</span><br><span class=\"line\">        - memlock - max locked-in-memory address space (KB)</span><br><span class=\"line\">        - nofile - max number of open file descriptors</span><br><span class=\"line\">        - rss - max resident <span class=\"built_in\">set</span> size (KB)</span><br><span class=\"line\">        - stack - max stack size (KB)</span><br><span class=\"line\">        - cpu - max CPU time (MIN)</span><br><span class=\"line\">        - nproc - max number of processes</span><br><span class=\"line\">        - as - address space <span class=\"built_in\">limit</span> (KB)</span><br><span class=\"line\">        - maxlogins - max number of logins <span class=\"keyword\">for</span> this user</span><br><span class=\"line\">        - maxsyslogins - max number of logins on the system</span><br><span class=\"line\">        - priority - the priority to run user process with</span><br><span class=\"line\">        - locks - max number of file locks the user can hold</span><br><span class=\"line\">        - sigpending - max number of pending signals</span><br><span class=\"line\">        - msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class=\"line\">        - nice - max nice priority allowed to raise to values: [-20, 19]</span><br><span class=\"line\">        - rtprio - max realtime priority</span><br><span class=\"line\"></span><br><span class=\"line\">value   限制的具体值;</span><br></pre></td></tr></table></figure></p>\n<p>以下是一个具体的例子:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#&lt;domain&gt;        &lt;type&gt;     &lt;item&gt;     &lt;value&gt;</span></span><br><span class=\"line\">*                 soft      nproc       65536</span><br><span class=\"line\">*                 hard      nproc       65536</span><br><span class=\"line\">*                 -         nofile      65536</span><br><span class=\"line\">%guest            -         maxlogins   10</span><br><span class=\"line\">elastic           -         memlock     <span class=\"built_in\">unlimit</span></span><br><span class=\"line\">@dev              hard      fsize       10737418240</span><br></pre></td></tr></table></figure></p>\n<p>如上所示, 系统允许 elastic 用户的最大 memlock 为 unlimit, 如果这个值被设置为了一个比较小的值, 那么上上节 elasticsearch 试图将其改成 unlimit 便会失败;</p>\n<p>&nbsp;<br>而对于 <code>/etc/security/limits.d</code> 目录的作用,  <code>/etc/security/limits.conf</code> 文件中的第二段与第三段有如下注释:</p>\n<blockquote>\n<p>Also note that configuration files in /etc/security/limits.d directory,<br>which are read in alphabetical order, override the settings in this<br>file in case the domain is the same or more specific.<br>&nbsp;<br>That means for example that setting a limit for wildcard domain here<br>can be overriden with a wildcard setting in a config file in the<br>subdirectory, but a user specific setting here can be overriden only<br>with a user specific setting in the subdirectory.</p>\n</blockquote>\n<p>也就是说, limits.conf 配置文件, 可以在用户级别上被 limits.d 目录下的配置文件覆盖;<br>举一个例子, 在 redhat/centos 各发行版本中, limits.d 目录下就有一个文件 <code>20-nproc.conf</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default limit for number of user's processes to prevent</span></span><br><span class=\"line\"><span class=\"comment\"># accidental fork bombs.</span></span><br><span class=\"line\"><span class=\"comment\"># See rhbz #432903 for reasoning.</span></span><br><span class=\"line\">*          soft    nproc     4096</span><br><span class=\"line\">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure></p>\n<p>这里面对除了 root 用户之外的所有用户作了一个最大进程/线程数目的 soft 限制;<br>如果修改 limits.conf 文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*          hard    nproc     65535</span><br></pre></td></tr></table></figure></p>\n<p>这时会发现, 除非自己试图 <code>ulimit -u</code> 修改 max processes, 否则这个值会依然被限制为 4096;<br>而要想将该值默认放到 65535, 就必须修改 <code>20-nproc.conf</code> 文件方才生效;</p>\n<h3 id=\"永久修改生效的必要条件\"><a href=\"#永久修改生效的必要条件\" class=\"headerlink\" title=\"永久修改生效的必要条件\"></a><strong>永久修改生效的必要条件</strong></h3><h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">pam 认证与配置</a></li>\n<li><a href=\"\">dubbo 服务治理系统设计</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/zengkefu/p/5649407.html\" target=\"_blank\" rel=\"noopener\">ulimit 命令详解</a></li>\n<li><a href=\"http://blog.csdn.net/taijianyu/article/details/5976319\" target=\"_blank\" rel=\"noopener\">linux /etc/security/limits.conf的相关说明</a></li>\n</ul>"},{"title":"sysvinit / systemd 命令使用与对比","date":"2017-11-12T09:18:06.000Z","_content":"\n> 当用户空间引导程序 systemV init 被 systemd 所取代, centos 7 下操纵与查看 daemon service 的命令也随之而改变;\n不过, 由于 systemd 的庞大复杂, 命令选项繁多, 本文对 systemd 的整理主要集中于与 sysvinit 所提供的功能重合度最高的 systemctl 命令;\n\n<!--more-->\n\n------\n\n## **传统的 sysvinit 相关命令**\n与传统的 systemV init 引导程序相匹配的 daemon service 操纵命令主要是 service 与 chkconfig/ntsysv;\n其中:\nservice 命令用于 启, 停, 查看 具体的 daemon service; \nchkconfig 命令用于 修改, 查看 具体 daemon service 的 runlevel 及启停信息;\nntsysv 命令提供了一个 GUI 界面用于操纵各个 runlevel 上各 daemon service 的启停;\n### **service 的使用方式**\n``` bash\n# 启动, 停止, 重启, 查看\nsudo service ntpd start\nsudo service ntpd stop\nsudo service ntpd restart\nsudo service ntpd status\n```\n### **chkconfig 的使用方式**\n``` bash\n# 列举所有的 daemon service 在各个 runlevel 上的启停状态\nsudo chkconfig --list\n# 列举指定的 daemon service 在各个 runlevel 上的启停状态\n> sudo chkconfig --list ntpd\nntpd           \t0:on\t1:on\t2:on\t3:on\t4:on\t5:on\t6:off\n\n# 添加一个 daemon service\nsudo chkconfig --add mysqld\n# 在默认的 2, 3, 4, 5 四个 runlevel 上自动启动 mysqld\nsudo chkconfig mysqld on\n# 在指定的 3, 5 两个 runlevel 上自动启动 mysqld\nsudo chkconfig --level 35 mysqld on\n\n# 删除一个 daemon service\nsudo chkconfig --del rngd\n```\n### **ntsysv 的使用方式**\nntsysv 在 centos 7 之前的各发行版本上都默认安装, 不过从 centos 7 之后, 该命令的 GUI 形式已经不再默认提供, 只提供了 chkconfig 命令用于兼容照顾老的 systemV init 方式;\n``` bash\n# 默认情况下 ntsysv 配置的是当前 user session 所在的 runlevel\nsudo ntsysv\n# 配置 runlevel = 5 的 daemon service\nsudo ntsysv --level 5\n```\n\n## **主流的 systemd 相关命令**\nsystemd 相比 sysvinit 就要复杂多了, 同时也比 sysvinit 强大多了;\nsystemd 相比 sysvinit 更强大的其中一个重要点是, systemd 不仅仅管理系统中的各进程, 它管理 linux 系统中的所有资源, 并把不同的资源称为 unit:\n``` bash\nservice unit: 系统服务\ntarget unit: 多个 unit 构成的一个组\ndevice unit: 硬件设备\nmount unit: 文件系统的挂载点\nautomount unit: 自动挂载点\npath unit: 文件或路径\nscope unit: 不是由 systemd 启动的外部进程\nslice unit: 进程组\nsnapshot unit: systemd 快照, 可以切回某个快照\nsocket unit: 进程间通信的 socket\nswap unit: swap 文件\ntimer unit: 定时器, 可与 crond 相对比, 可圈可点\n```\n其中, **service unit** 在 12 类 unit 中是最主要的一类, 也是日常操作中最频繁接触的一类, 当然也是与传统的 sysvinit 可以直接比较的对象;\n另外, systemd 里另外一个比较有意思的是 timer unit, 关于此的详细内容可以参见: [systemd 的定时器功能]();\n&nbsp;\nsystemd 主要涉及到的命令有: `systemctl`, `hostnamectl`, `localectl`, `timedatectl`, `loginctl`, `journalctl` 等, 其中:\n\n- `systemctl` 是最重要的命令, 最核心的操作都与此命令有关, 比如启停服务, 管理各 unit 等;\n- `hostnamectl` 用于管理主机信息等;\n- `localectl` 用于本地化设置管理;\n- `timedatectl` 用于时区管理;\n- `loginctl` 用于管理当前登录的用户;\n- `journalctl` 用于管理 systemd 与各 unit 的输出日志, 用于辅助其余命令查看状态与日志;\n\n&nbsp;\n本主要整理与 systemctl 有关的内容, 其余的如 timedatectl, journalctl 请参见另一篇文章: [sysvinit / systemd 日志系统的使用与对比]();\n\n### **systemctl 的常用命令列表**\nsystemctl 的使用场景十分广泛, 从大的角度来说, 可以分为 **系统管理** 和 **unit 管理** 两大类;\n系统管理类的命令如下:\n``` bash\n# 重启系统\nsudo systemctl reboot\n# 关闭系统, 切断电源\nsudo systemctl poweroff\n# CPU 停止工作\nsudo systemctl halt\n# 暂停系统\nsudo systemctl suspend\n# 让系统进入冬眠状态\nsudo systemctl hibernate\n# 让系统进入交互式休眠状态\nsudo systemctl hybrid-sleep\n# 启动进入救援状态 (单用户状态, runlevel = 1)\nsudo systemctl rescue\n```\nunit 管理类 的命令种类繁多, 大致可以再细分为两小类: **查看管理类** 与 **操纵动作类**;\n**查看管理类仅仅是统计与查看, 并不改变 unit 的状态:**\n(1) 从整体角度管理 units\n``` bash\n# 默认列出正在运行的 unit\nsudo systemctl list-units\n# 列出所有 unit, 包括没有找到配置文件的或者启动失败的\nsudo systemctl list-units --all\n# 列出所有没有运行的 unit\nsudo systemctl list-units --all --state=inactive\n# 列出所有加载失败的 unit\nsudo systemctl list-units --failed\n# 列出所有正在运行的, 类型为 service 的 unit; -t: --type\nsudo systemctl list-units --type=service\n```\n(2) 管理具体的某个 unit\n``` bash\n# 显示某个 unit 的状态\nsudo systemctl status rsyslog.service\n# 显示某个 unit 是否正在运行\nsudo systemctl is-active rsyslog.service\n# 显示某个 unit 是否处于启动失败状态\nsudo systemctl is-failed rsyslog.service\n# 显示某个 unit 服务是否建立了启动链接\nsudo systemctl is-enabled rsyslog.service\n\n# 显示某个 unit 的启动是否依赖其他 unit 的启动, --all 展开所有 target unit 下的每一个详细 unit\nsudo systemctl list-dependencies --all rsyslog.service\n\n# 显示某个 unit 的所有底层参数\nsudo systemctl show rsyslog.service\n# 显示某个 unit 的指定属性的值\nsudo systemctl show -p CPUShares rsyslog.service\n```\n**操纵动作类, 主要是针对 service unit:**\n``` bash\n# 设置为开机启动\nsudo systemctl enable nginx.service\n# 启动\nsudo systemctl start nginx.service\n# 停止\nsudo systemctl stop nginx.service\n# 重启\nsudo systemctl restart nginx.service\n# 杀死一个服务的所有子进程\nsudo systemctl kill nginx.service\n# 重新加载一个服务的配置文件\nsudo systemctl reload nginx.service\n\n# 设置某个 unit 的指定属性\nsudo systemctl set-property nginx.service CPUShares=500\n```\n\n### **systemctl 的状态与诊断**\n使用 systemctl status 输出服务详情状态:\n``` bash\n# Loaded:   该 unit 配置文件的位置以及是否开机启动\n# Active:   运行状态\n# Main PID: 父进程 pid\n# CGroup:   所有的子进程列表\n# 最后是 service 的日志\n> sudo systemctl status rsyslog.service\n\n● rsyslog.service - System Logging Service\n   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)\n   Active: active (running) since Wed 2017-07-19 16:01:19 CST; 6 months 10 days ago\n Main PID: 504 (rsyslogd)\n   CGroup: /system.slice/rsyslog.service\n           └─504 /usr/sbin/rsyslogd -n\n\nJul 19 16:01:19 localhost.localdomain systemd[1]: Starting System Logging Service...\nJul 19 16:01:19 localhost.localdomain systemd[1]: Started System Logging Service.\n```\n使用 journalctl 查看日志:\n``` bash\n# 指定查看某个 unit 的日志\nsudo journalctl -u nagios\n# 指定时间范围 --since=  --until=\nsudo journalctl -u nagios -S \"2017-04-19 09:00:00\"\nsudo journalctl -u nagios -S \"2 days ago\"\nsudo journalctl -u nagios -U \"2017-12-31 23:59:59\"\n# 指定某次启动后的所有日志\nsudo journalctl -u nagios -b [-0] # 当前启动后\nsudo journalctl -u nagios -b  -1  # 上次启动后\nsudo journalctl -u nagios -b  -2  # 继续往上追溯\n```\n关于 journalctl 的详细内容, 请参见另外一篇文章: [sysvinit / systemd 日志系统的使用与对比]();\n\n## **站内相关文章**\n- [sysvinit/systemd/upstart 初始化过程梳理]()\n- [systemd 的定时器功能]()\n- [systemd 相关配置文件整理]()\n- [sysvinit / systemd 日志系统的使用与对比]()\n\n## **参考链接**\n- [Linux下chkconfig命令详解](https://www.cnblogs.com/panjun-Donet/archive/2010/08/10/1796873.html)\n- [ntsysv命令](http://man.linuxde.net/ntsysv)\n- [CentOS 7 启动, 重启, chkconfig 等命令已经合并为 systemctl](https://zhangzifan.com/centos-systemctl.html)\n- [RHEL 7 中 systemctl 的用法 (替代service 和 chkconfig)](http://blog.csdn.net/catoop/article/details/47318225)\n- [Systemd 入门教程: 命令篇](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)\n- [systemctl 命令完全指南](https://linux.cn/article-5926-1.html)\n\n","source":"_posts/linux-init--sysvinit_systemd命令使用与对比.md","raw":"---\ntitle: sysvinit / systemd 命令使用与对比\ndate: 2017-11-12 17:18:06\ncategories:\n - linux\n - init\ntags:\n - linux:init\n - systemd\n---\n\n> 当用户空间引导程序 systemV init 被 systemd 所取代, centos 7 下操纵与查看 daemon service 的命令也随之而改变;\n不过, 由于 systemd 的庞大复杂, 命令选项繁多, 本文对 systemd 的整理主要集中于与 sysvinit 所提供的功能重合度最高的 systemctl 命令;\n\n<!--more-->\n\n------\n\n## **传统的 sysvinit 相关命令**\n与传统的 systemV init 引导程序相匹配的 daemon service 操纵命令主要是 service 与 chkconfig/ntsysv;\n其中:\nservice 命令用于 启, 停, 查看 具体的 daemon service; \nchkconfig 命令用于 修改, 查看 具体 daemon service 的 runlevel 及启停信息;\nntsysv 命令提供了一个 GUI 界面用于操纵各个 runlevel 上各 daemon service 的启停;\n### **service 的使用方式**\n``` bash\n# 启动, 停止, 重启, 查看\nsudo service ntpd start\nsudo service ntpd stop\nsudo service ntpd restart\nsudo service ntpd status\n```\n### **chkconfig 的使用方式**\n``` bash\n# 列举所有的 daemon service 在各个 runlevel 上的启停状态\nsudo chkconfig --list\n# 列举指定的 daemon service 在各个 runlevel 上的启停状态\n> sudo chkconfig --list ntpd\nntpd           \t0:on\t1:on\t2:on\t3:on\t4:on\t5:on\t6:off\n\n# 添加一个 daemon service\nsudo chkconfig --add mysqld\n# 在默认的 2, 3, 4, 5 四个 runlevel 上自动启动 mysqld\nsudo chkconfig mysqld on\n# 在指定的 3, 5 两个 runlevel 上自动启动 mysqld\nsudo chkconfig --level 35 mysqld on\n\n# 删除一个 daemon service\nsudo chkconfig --del rngd\n```\n### **ntsysv 的使用方式**\nntsysv 在 centos 7 之前的各发行版本上都默认安装, 不过从 centos 7 之后, 该命令的 GUI 形式已经不再默认提供, 只提供了 chkconfig 命令用于兼容照顾老的 systemV init 方式;\n``` bash\n# 默认情况下 ntsysv 配置的是当前 user session 所在的 runlevel\nsudo ntsysv\n# 配置 runlevel = 5 的 daemon service\nsudo ntsysv --level 5\n```\n\n## **主流的 systemd 相关命令**\nsystemd 相比 sysvinit 就要复杂多了, 同时也比 sysvinit 强大多了;\nsystemd 相比 sysvinit 更强大的其中一个重要点是, systemd 不仅仅管理系统中的各进程, 它管理 linux 系统中的所有资源, 并把不同的资源称为 unit:\n``` bash\nservice unit: 系统服务\ntarget unit: 多个 unit 构成的一个组\ndevice unit: 硬件设备\nmount unit: 文件系统的挂载点\nautomount unit: 自动挂载点\npath unit: 文件或路径\nscope unit: 不是由 systemd 启动的外部进程\nslice unit: 进程组\nsnapshot unit: systemd 快照, 可以切回某个快照\nsocket unit: 进程间通信的 socket\nswap unit: swap 文件\ntimer unit: 定时器, 可与 crond 相对比, 可圈可点\n```\n其中, **service unit** 在 12 类 unit 中是最主要的一类, 也是日常操作中最频繁接触的一类, 当然也是与传统的 sysvinit 可以直接比较的对象;\n另外, systemd 里另外一个比较有意思的是 timer unit, 关于此的详细内容可以参见: [systemd 的定时器功能]();\n&nbsp;\nsystemd 主要涉及到的命令有: `systemctl`, `hostnamectl`, `localectl`, `timedatectl`, `loginctl`, `journalctl` 等, 其中:\n\n- `systemctl` 是最重要的命令, 最核心的操作都与此命令有关, 比如启停服务, 管理各 unit 等;\n- `hostnamectl` 用于管理主机信息等;\n- `localectl` 用于本地化设置管理;\n- `timedatectl` 用于时区管理;\n- `loginctl` 用于管理当前登录的用户;\n- `journalctl` 用于管理 systemd 与各 unit 的输出日志, 用于辅助其余命令查看状态与日志;\n\n&nbsp;\n本主要整理与 systemctl 有关的内容, 其余的如 timedatectl, journalctl 请参见另一篇文章: [sysvinit / systemd 日志系统的使用与对比]();\n\n### **systemctl 的常用命令列表**\nsystemctl 的使用场景十分广泛, 从大的角度来说, 可以分为 **系统管理** 和 **unit 管理** 两大类;\n系统管理类的命令如下:\n``` bash\n# 重启系统\nsudo systemctl reboot\n# 关闭系统, 切断电源\nsudo systemctl poweroff\n# CPU 停止工作\nsudo systemctl halt\n# 暂停系统\nsudo systemctl suspend\n# 让系统进入冬眠状态\nsudo systemctl hibernate\n# 让系统进入交互式休眠状态\nsudo systemctl hybrid-sleep\n# 启动进入救援状态 (单用户状态, runlevel = 1)\nsudo systemctl rescue\n```\nunit 管理类 的命令种类繁多, 大致可以再细分为两小类: **查看管理类** 与 **操纵动作类**;\n**查看管理类仅仅是统计与查看, 并不改变 unit 的状态:**\n(1) 从整体角度管理 units\n``` bash\n# 默认列出正在运行的 unit\nsudo systemctl list-units\n# 列出所有 unit, 包括没有找到配置文件的或者启动失败的\nsudo systemctl list-units --all\n# 列出所有没有运行的 unit\nsudo systemctl list-units --all --state=inactive\n# 列出所有加载失败的 unit\nsudo systemctl list-units --failed\n# 列出所有正在运行的, 类型为 service 的 unit; -t: --type\nsudo systemctl list-units --type=service\n```\n(2) 管理具体的某个 unit\n``` bash\n# 显示某个 unit 的状态\nsudo systemctl status rsyslog.service\n# 显示某个 unit 是否正在运行\nsudo systemctl is-active rsyslog.service\n# 显示某个 unit 是否处于启动失败状态\nsudo systemctl is-failed rsyslog.service\n# 显示某个 unit 服务是否建立了启动链接\nsudo systemctl is-enabled rsyslog.service\n\n# 显示某个 unit 的启动是否依赖其他 unit 的启动, --all 展开所有 target unit 下的每一个详细 unit\nsudo systemctl list-dependencies --all rsyslog.service\n\n# 显示某个 unit 的所有底层参数\nsudo systemctl show rsyslog.service\n# 显示某个 unit 的指定属性的值\nsudo systemctl show -p CPUShares rsyslog.service\n```\n**操纵动作类, 主要是针对 service unit:**\n``` bash\n# 设置为开机启动\nsudo systemctl enable nginx.service\n# 启动\nsudo systemctl start nginx.service\n# 停止\nsudo systemctl stop nginx.service\n# 重启\nsudo systemctl restart nginx.service\n# 杀死一个服务的所有子进程\nsudo systemctl kill nginx.service\n# 重新加载一个服务的配置文件\nsudo systemctl reload nginx.service\n\n# 设置某个 unit 的指定属性\nsudo systemctl set-property nginx.service CPUShares=500\n```\n\n### **systemctl 的状态与诊断**\n使用 systemctl status 输出服务详情状态:\n``` bash\n# Loaded:   该 unit 配置文件的位置以及是否开机启动\n# Active:   运行状态\n# Main PID: 父进程 pid\n# CGroup:   所有的子进程列表\n# 最后是 service 的日志\n> sudo systemctl status rsyslog.service\n\n● rsyslog.service - System Logging Service\n   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)\n   Active: active (running) since Wed 2017-07-19 16:01:19 CST; 6 months 10 days ago\n Main PID: 504 (rsyslogd)\n   CGroup: /system.slice/rsyslog.service\n           └─504 /usr/sbin/rsyslogd -n\n\nJul 19 16:01:19 localhost.localdomain systemd[1]: Starting System Logging Service...\nJul 19 16:01:19 localhost.localdomain systemd[1]: Started System Logging Service.\n```\n使用 journalctl 查看日志:\n``` bash\n# 指定查看某个 unit 的日志\nsudo journalctl -u nagios\n# 指定时间范围 --since=  --until=\nsudo journalctl -u nagios -S \"2017-04-19 09:00:00\"\nsudo journalctl -u nagios -S \"2 days ago\"\nsudo journalctl -u nagios -U \"2017-12-31 23:59:59\"\n# 指定某次启动后的所有日志\nsudo journalctl -u nagios -b [-0] # 当前启动后\nsudo journalctl -u nagios -b  -1  # 上次启动后\nsudo journalctl -u nagios -b  -2  # 继续往上追溯\n```\n关于 journalctl 的详细内容, 请参见另外一篇文章: [sysvinit / systemd 日志系统的使用与对比]();\n\n## **站内相关文章**\n- [sysvinit/systemd/upstart 初始化过程梳理]()\n- [systemd 的定时器功能]()\n- [systemd 相关配置文件整理]()\n- [sysvinit / systemd 日志系统的使用与对比]()\n\n## **参考链接**\n- [Linux下chkconfig命令详解](https://www.cnblogs.com/panjun-Donet/archive/2010/08/10/1796873.html)\n- [ntsysv命令](http://man.linuxde.net/ntsysv)\n- [CentOS 7 启动, 重启, chkconfig 等命令已经合并为 systemctl](https://zhangzifan.com/centos-systemctl.html)\n- [RHEL 7 中 systemctl 的用法 (替代service 和 chkconfig)](http://blog.csdn.net/catoop/article/details/47318225)\n- [Systemd 入门教程: 命令篇](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)\n- [systemctl 命令完全指南](https://linux.cn/article-5926-1.html)\n\n","slug":"linux-init--sysvinit_systemd命令使用与对比","published":1,"updated":"2018-04-23T15:34:44.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5a0002j1jxm51im9lb","content":"<blockquote>\n<p>当用户空间引导程序 systemV init 被 systemd 所取代, centos 7 下操纵与查看 daemon service 的命令也随之而改变;<br>不过, 由于 systemd 的庞大复杂, 命令选项繁多, 本文对 systemd 的整理主要集中于与 sysvinit 所提供的功能重合度最高的 systemctl 命令;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"传统的-sysvinit-相关命令\"><a href=\"#传统的-sysvinit-相关命令\" class=\"headerlink\" title=\"传统的 sysvinit 相关命令\"></a><strong>传统的 sysvinit 相关命令</strong></h2><p>与传统的 systemV init 引导程序相匹配的 daemon service 操纵命令主要是 service 与 chkconfig/ntsysv;<br>其中:<br>service 命令用于 启, 停, 查看 具体的 daemon service;<br>chkconfig 命令用于 修改, 查看 具体 daemon service 的 runlevel 及启停信息;<br>ntsysv 命令提供了一个 GUI 界面用于操纵各个 runlevel 上各 daemon service 的启停;</p>\n<h3 id=\"service-的使用方式\"><a href=\"#service-的使用方式\" class=\"headerlink\" title=\"service 的使用方式\"></a><strong>service 的使用方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动, 停止, 重启, 查看</span></span><br><span class=\"line\">sudo service ntpd start</span><br><span class=\"line\">sudo service ntpd stop</span><br><span class=\"line\">sudo service ntpd restart</span><br><span class=\"line\">sudo service ntpd status</span><br></pre></td></tr></table></figure>\n<h3 id=\"chkconfig-的使用方式\"><a href=\"#chkconfig-的使用方式\" class=\"headerlink\" title=\"chkconfig 的使用方式\"></a><strong>chkconfig 的使用方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列举所有的 daemon service 在各个 runlevel 上的启停状态</span></span><br><span class=\"line\">sudo chkconfig --list</span><br><span class=\"line\"><span class=\"comment\"># 列举指定的 daemon service 在各个 runlevel 上的启停状态</span></span><br><span class=\"line\">&gt; sudo chkconfig --list ntpd</span><br><span class=\"line\">ntpd           \t0:on\t1:on\t2:on\t3:on\t4:on\t5:on\t6:off</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加一个 daemon service</span></span><br><span class=\"line\">sudo chkconfig --add mysqld</span><br><span class=\"line\"><span class=\"comment\"># 在默认的 2, 3, 4, 5 四个 runlevel 上自动启动 mysqld</span></span><br><span class=\"line\">sudo chkconfig mysqld on</span><br><span class=\"line\"><span class=\"comment\"># 在指定的 3, 5 两个 runlevel 上自动启动 mysqld</span></span><br><span class=\"line\">sudo chkconfig --level 35 mysqld on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个 daemon service</span></span><br><span class=\"line\">sudo chkconfig --del rngd</span><br></pre></td></tr></table></figure>\n<h3 id=\"ntsysv-的使用方式\"><a href=\"#ntsysv-的使用方式\" class=\"headerlink\" title=\"ntsysv 的使用方式\"></a><strong>ntsysv 的使用方式</strong></h3><p>ntsysv 在 centos 7 之前的各发行版本上都默认安装, 不过从 centos 7 之后, 该命令的 GUI 形式已经不再默认提供, 只提供了 chkconfig 命令用于兼容照顾老的 systemV init 方式;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认情况下 ntsysv 配置的是当前 user session 所在的 runlevel</span></span><br><span class=\"line\">sudo ntsysv</span><br><span class=\"line\"><span class=\"comment\"># 配置 runlevel = 5 的 daemon service</span></span><br><span class=\"line\">sudo ntsysv --level 5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"主流的-systemd-相关命令\"><a href=\"#主流的-systemd-相关命令\" class=\"headerlink\" title=\"主流的 systemd 相关命令\"></a><strong>主流的 systemd 相关命令</strong></h2><p>systemd 相比 sysvinit 就要复杂多了, 同时也比 sysvinit 强大多了;<br>systemd 相比 sysvinit 更强大的其中一个重要点是, systemd 不仅仅管理系统中的各进程, 它管理 linux 系统中的所有资源, 并把不同的资源称为 unit:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service unit: 系统服务</span><br><span class=\"line\">target unit: 多个 unit 构成的一个组</span><br><span class=\"line\">device unit: 硬件设备</span><br><span class=\"line\">mount unit: 文件系统的挂载点</span><br><span class=\"line\">automount unit: 自动挂载点</span><br><span class=\"line\">path unit: 文件或路径</span><br><span class=\"line\">scope unit: 不是由 systemd 启动的外部进程</span><br><span class=\"line\">slice unit: 进程组</span><br><span class=\"line\">snapshot unit: systemd 快照, 可以切回某个快照</span><br><span class=\"line\">socket unit: 进程间通信的 socket</span><br><span class=\"line\">swap unit: swap 文件</span><br><span class=\"line\">timer unit: 定时器, 可与 crond 相对比, 可圈可点</span><br></pre></td></tr></table></figure></p>\n<p>其中, <strong>service unit</strong> 在 12 类 unit 中是最主要的一类, 也是日常操作中最频繁接触的一类, 当然也是与传统的 sysvinit 可以直接比较的对象;<br>另外, systemd 里另外一个比较有意思的是 timer unit, 关于此的详细内容可以参见: <a href=\"\">systemd 的定时器功能</a>;<br>&nbsp;<br>systemd 主要涉及到的命令有: <code>systemctl</code>, <code>hostnamectl</code>, <code>localectl</code>, <code>timedatectl</code>, <code>loginctl</code>, <code>journalctl</code> 等, 其中:</p>\n<ul>\n<li><code>systemctl</code> 是最重要的命令, 最核心的操作都与此命令有关, 比如启停服务, 管理各 unit 等;</li>\n<li><code>hostnamectl</code> 用于管理主机信息等;</li>\n<li><code>localectl</code> 用于本地化设置管理;</li>\n<li><code>timedatectl</code> 用于时区管理;</li>\n<li><code>loginctl</code> 用于管理当前登录的用户;</li>\n<li><code>journalctl</code> 用于管理 systemd 与各 unit 的输出日志, 用于辅助其余命令查看状态与日志;</li>\n</ul>\n<p>&nbsp;<br>本主要整理与 systemctl 有关的内容, 其余的如 timedatectl, journalctl 请参见另一篇文章: <a href=\"\">sysvinit / systemd 日志系统的使用与对比</a>;</p>\n<h3 id=\"systemctl-的常用命令列表\"><a href=\"#systemctl-的常用命令列表\" class=\"headerlink\" title=\"systemctl 的常用命令列表\"></a><strong>systemctl 的常用命令列表</strong></h3><p>systemctl 的使用场景十分广泛, 从大的角度来说, 可以分为 <strong>系统管理</strong> 和 <strong>unit 管理</strong> 两大类;<br>系统管理类的命令如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重启系统</span></span><br><span class=\"line\">sudo systemctl reboot</span><br><span class=\"line\"><span class=\"comment\"># 关闭系统, 切断电源</span></span><br><span class=\"line\">sudo systemctl poweroff</span><br><span class=\"line\"><span class=\"comment\"># CPU 停止工作</span></span><br><span class=\"line\">sudo systemctl halt</span><br><span class=\"line\"><span class=\"comment\"># 暂停系统</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">suspend</span></span><br><span class=\"line\"><span class=\"comment\"># 让系统进入冬眠状态</span></span><br><span class=\"line\">sudo systemctl hibernate</span><br><span class=\"line\"><span class=\"comment\"># 让系统进入交互式休眠状态</span></span><br><span class=\"line\">sudo systemctl hybrid-sleep</span><br><span class=\"line\"><span class=\"comment\"># 启动进入救援状态 (单用户状态, runlevel = 1)</span></span><br><span class=\"line\">sudo systemctl rescue</span><br></pre></td></tr></table></figure></p>\n<p>unit 管理类 的命令种类繁多, 大致可以再细分为两小类: <strong>查看管理类</strong> 与 <strong>操纵动作类</strong>;<br><strong>查看管理类仅仅是统计与查看, 并不改变 unit 的状态:</strong><br>(1) 从整体角度管理 units<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认列出正在运行的 unit</span></span><br><span class=\"line\">sudo systemctl list-units</span><br><span class=\"line\"><span class=\"comment\"># 列出所有 unit, 包括没有找到配置文件的或者启动失败的</span></span><br><span class=\"line\">sudo systemctl list-units --all</span><br><span class=\"line\"><span class=\"comment\"># 列出所有没有运行的 unit</span></span><br><span class=\"line\">sudo systemctl list-units --all --state=inactive</span><br><span class=\"line\"><span class=\"comment\"># 列出所有加载失败的 unit</span></span><br><span class=\"line\">sudo systemctl list-units --failed</span><br><span class=\"line\"><span class=\"comment\"># 列出所有正在运行的, 类型为 service 的 unit; -t: --type</span></span><br><span class=\"line\">sudo systemctl list-units --<span class=\"built_in\">type</span>=service</span><br></pre></td></tr></table></figure></p>\n<p>(2) 管理具体的某个 unit<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的状态</span></span><br><span class=\"line\">sudo systemctl status rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 是否正在运行</span></span><br><span class=\"line\">sudo systemctl is-active rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 是否处于启动失败状态</span></span><br><span class=\"line\">sudo systemctl is-failed rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 服务是否建立了启动链接</span></span><br><span class=\"line\">sudo systemctl is-enabled rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的启动是否依赖其他 unit 的启动, --all 展开所有 target unit 下的每一个详细 unit</span></span><br><span class=\"line\">sudo systemctl list-dependencies --all rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的所有底层参数</span></span><br><span class=\"line\">sudo systemctl show rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的指定属性的值</span></span><br><span class=\"line\">sudo systemctl show -p CPUShares rsyslog.service</span><br></pre></td></tr></table></figure></p>\n<p><strong>操纵动作类, 主要是针对 service unit:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置为开机启动</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">sudo systemctl start nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">sudo systemctl stop nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 重启</span></span><br><span class=\"line\">sudo systemctl restart nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 杀死一个服务的所有子进程</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">kill</span> nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 重新加载一个服务的配置文件</span></span><br><span class=\"line\">sudo systemctl reload nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置某个 unit 的指定属性</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">set</span>-property nginx.service CPUShares=500</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"systemctl-的状态与诊断\"><a href=\"#systemctl-的状态与诊断\" class=\"headerlink\" title=\"systemctl 的状态与诊断\"></a><strong>systemctl 的状态与诊断</strong></h3><p>使用 systemctl status 输出服务详情状态:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Loaded:   该 unit 配置文件的位置以及是否开机启动</span></span><br><span class=\"line\"><span class=\"comment\"># Active:   运行状态</span></span><br><span class=\"line\"><span class=\"comment\"># Main PID: 父进程 pid</span></span><br><span class=\"line\"><span class=\"comment\"># CGroup:   所有的子进程列表</span></span><br><span class=\"line\"><span class=\"comment\"># 最后是 service 的日志</span></span><br><span class=\"line\">&gt; sudo systemctl status rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\">● rsyslog.service - System Logging Service</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Wed 2017-07-19 16:01:19 CST; 6 months 10 days ago</span><br><span class=\"line\"> Main PID: 504 (rsyslogd)</span><br><span class=\"line\">   CGroup: /system.slice/rsyslog.service</span><br><span class=\"line\">           └─504 /usr/sbin/rsyslogd -n</span><br><span class=\"line\"></span><br><span class=\"line\">Jul 19 16:01:19 localhost.localdomain systemd[1]: Starting System Logging Service...</span><br><span class=\"line\">Jul 19 16:01:19 localhost.localdomain systemd[1]: Started System Logging Service.</span><br></pre></td></tr></table></figure></p>\n<p>使用 journalctl 查看日志:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定查看某个 unit 的日志</span></span><br><span class=\"line\">sudo journalctl -u nagios</span><br><span class=\"line\"><span class=\"comment\"># 指定时间范围 --since=  --until=</span></span><br><span class=\"line\">sudo journalctl -u nagios -S <span class=\"string\">\"2017-04-19 09:00:00\"</span></span><br><span class=\"line\">sudo journalctl -u nagios -S <span class=\"string\">\"2 days ago\"</span></span><br><span class=\"line\">sudo journalctl -u nagios -U <span class=\"string\">\"2017-12-31 23:59:59\"</span></span><br><span class=\"line\"><span class=\"comment\"># 指定某次启动后的所有日志</span></span><br><span class=\"line\">sudo journalctl -u nagios -b [-0] <span class=\"comment\"># 当前启动后</span></span><br><span class=\"line\">sudo journalctl -u nagios -b  -1  <span class=\"comment\"># 上次启动后</span></span><br><span class=\"line\">sudo journalctl -u nagios -b  -2  <span class=\"comment\"># 继续往上追溯</span></span><br></pre></td></tr></table></figure></p>\n<p>关于 journalctl 的详细内容, 请参见另外一篇文章: <a href=\"\">sysvinit / systemd 日志系统的使用与对比</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">sysvinit/systemd/upstart 初始化过程梳理</a></li>\n<li><a href=\"\">systemd 的定时器功能</a></li>\n<li><a href=\"\">systemd 相关配置文件整理</a></li>\n<li><a href=\"\">sysvinit / systemd 日志系统的使用与对比</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://www.cnblogs.com/panjun-Donet/archive/2010/08/10/1796873.html\" target=\"_blank\" rel=\"noopener\">Linux下chkconfig命令详解</a></li>\n<li><a href=\"http://man.linuxde.net/ntsysv\" target=\"_blank\" rel=\"noopener\">ntsysv命令</a></li>\n<li><a href=\"https://zhangzifan.com/centos-systemctl.html\" target=\"_blank\" rel=\"noopener\">CentOS 7 启动, 重启, chkconfig 等命令已经合并为 systemctl</a></li>\n<li><a href=\"http://blog.csdn.net/catoop/article/details/47318225\" target=\"_blank\" rel=\"noopener\">RHEL 7 中 systemctl 的用法 (替代service 和 chkconfig)</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\" target=\"_blank\" rel=\"noopener\">Systemd 入门教程: 命令篇</a></li>\n<li><a href=\"https://linux.cn/article-5926-1.html\" target=\"_blank\" rel=\"noopener\">systemctl 命令完全指南</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>当用户空间引导程序 systemV init 被 systemd 所取代, centos 7 下操纵与查看 daemon service 的命令也随之而改变;<br>不过, 由于 systemd 的庞大复杂, 命令选项繁多, 本文对 systemd 的整理主要集中于与 sysvinit 所提供的功能重合度最高的 systemctl 命令;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"传统的-sysvinit-相关命令\"><a href=\"#传统的-sysvinit-相关命令\" class=\"headerlink\" title=\"传统的 sysvinit 相关命令\"></a><strong>传统的 sysvinit 相关命令</strong></h2><p>与传统的 systemV init 引导程序相匹配的 daemon service 操纵命令主要是 service 与 chkconfig/ntsysv;<br>其中:<br>service 命令用于 启, 停, 查看 具体的 daemon service;<br>chkconfig 命令用于 修改, 查看 具体 daemon service 的 runlevel 及启停信息;<br>ntsysv 命令提供了一个 GUI 界面用于操纵各个 runlevel 上各 daemon service 的启停;</p>\n<h3 id=\"service-的使用方式\"><a href=\"#service-的使用方式\" class=\"headerlink\" title=\"service 的使用方式\"></a><strong>service 的使用方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动, 停止, 重启, 查看</span></span><br><span class=\"line\">sudo service ntpd start</span><br><span class=\"line\">sudo service ntpd stop</span><br><span class=\"line\">sudo service ntpd restart</span><br><span class=\"line\">sudo service ntpd status</span><br></pre></td></tr></table></figure>\n<h3 id=\"chkconfig-的使用方式\"><a href=\"#chkconfig-的使用方式\" class=\"headerlink\" title=\"chkconfig 的使用方式\"></a><strong>chkconfig 的使用方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列举所有的 daemon service 在各个 runlevel 上的启停状态</span></span><br><span class=\"line\">sudo chkconfig --list</span><br><span class=\"line\"><span class=\"comment\"># 列举指定的 daemon service 在各个 runlevel 上的启停状态</span></span><br><span class=\"line\">&gt; sudo chkconfig --list ntpd</span><br><span class=\"line\">ntpd           \t0:on\t1:on\t2:on\t3:on\t4:on\t5:on\t6:off</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加一个 daemon service</span></span><br><span class=\"line\">sudo chkconfig --add mysqld</span><br><span class=\"line\"><span class=\"comment\"># 在默认的 2, 3, 4, 5 四个 runlevel 上自动启动 mysqld</span></span><br><span class=\"line\">sudo chkconfig mysqld on</span><br><span class=\"line\"><span class=\"comment\"># 在指定的 3, 5 两个 runlevel 上自动启动 mysqld</span></span><br><span class=\"line\">sudo chkconfig --level 35 mysqld on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个 daemon service</span></span><br><span class=\"line\">sudo chkconfig --del rngd</span><br></pre></td></tr></table></figure>\n<h3 id=\"ntsysv-的使用方式\"><a href=\"#ntsysv-的使用方式\" class=\"headerlink\" title=\"ntsysv 的使用方式\"></a><strong>ntsysv 的使用方式</strong></h3><p>ntsysv 在 centos 7 之前的各发行版本上都默认安装, 不过从 centos 7 之后, 该命令的 GUI 形式已经不再默认提供, 只提供了 chkconfig 命令用于兼容照顾老的 systemV init 方式;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认情况下 ntsysv 配置的是当前 user session 所在的 runlevel</span></span><br><span class=\"line\">sudo ntsysv</span><br><span class=\"line\"><span class=\"comment\"># 配置 runlevel = 5 的 daemon service</span></span><br><span class=\"line\">sudo ntsysv --level 5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"主流的-systemd-相关命令\"><a href=\"#主流的-systemd-相关命令\" class=\"headerlink\" title=\"主流的 systemd 相关命令\"></a><strong>主流的 systemd 相关命令</strong></h2><p>systemd 相比 sysvinit 就要复杂多了, 同时也比 sysvinit 强大多了;<br>systemd 相比 sysvinit 更强大的其中一个重要点是, systemd 不仅仅管理系统中的各进程, 它管理 linux 系统中的所有资源, 并把不同的资源称为 unit:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service unit: 系统服务</span><br><span class=\"line\">target unit: 多个 unit 构成的一个组</span><br><span class=\"line\">device unit: 硬件设备</span><br><span class=\"line\">mount unit: 文件系统的挂载点</span><br><span class=\"line\">automount unit: 自动挂载点</span><br><span class=\"line\">path unit: 文件或路径</span><br><span class=\"line\">scope unit: 不是由 systemd 启动的外部进程</span><br><span class=\"line\">slice unit: 进程组</span><br><span class=\"line\">snapshot unit: systemd 快照, 可以切回某个快照</span><br><span class=\"line\">socket unit: 进程间通信的 socket</span><br><span class=\"line\">swap unit: swap 文件</span><br><span class=\"line\">timer unit: 定时器, 可与 crond 相对比, 可圈可点</span><br></pre></td></tr></table></figure></p>\n<p>其中, <strong>service unit</strong> 在 12 类 unit 中是最主要的一类, 也是日常操作中最频繁接触的一类, 当然也是与传统的 sysvinit 可以直接比较的对象;<br>另外, systemd 里另外一个比较有意思的是 timer unit, 关于此的详细内容可以参见: <a href=\"\">systemd 的定时器功能</a>;<br>&nbsp;<br>systemd 主要涉及到的命令有: <code>systemctl</code>, <code>hostnamectl</code>, <code>localectl</code>, <code>timedatectl</code>, <code>loginctl</code>, <code>journalctl</code> 等, 其中:</p>\n<ul>\n<li><code>systemctl</code> 是最重要的命令, 最核心的操作都与此命令有关, 比如启停服务, 管理各 unit 等;</li>\n<li><code>hostnamectl</code> 用于管理主机信息等;</li>\n<li><code>localectl</code> 用于本地化设置管理;</li>\n<li><code>timedatectl</code> 用于时区管理;</li>\n<li><code>loginctl</code> 用于管理当前登录的用户;</li>\n<li><code>journalctl</code> 用于管理 systemd 与各 unit 的输出日志, 用于辅助其余命令查看状态与日志;</li>\n</ul>\n<p>&nbsp;<br>本主要整理与 systemctl 有关的内容, 其余的如 timedatectl, journalctl 请参见另一篇文章: <a href=\"\">sysvinit / systemd 日志系统的使用与对比</a>;</p>\n<h3 id=\"systemctl-的常用命令列表\"><a href=\"#systemctl-的常用命令列表\" class=\"headerlink\" title=\"systemctl 的常用命令列表\"></a><strong>systemctl 的常用命令列表</strong></h3><p>systemctl 的使用场景十分广泛, 从大的角度来说, 可以分为 <strong>系统管理</strong> 和 <strong>unit 管理</strong> 两大类;<br>系统管理类的命令如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重启系统</span></span><br><span class=\"line\">sudo systemctl reboot</span><br><span class=\"line\"><span class=\"comment\"># 关闭系统, 切断电源</span></span><br><span class=\"line\">sudo systemctl poweroff</span><br><span class=\"line\"><span class=\"comment\"># CPU 停止工作</span></span><br><span class=\"line\">sudo systemctl halt</span><br><span class=\"line\"><span class=\"comment\"># 暂停系统</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">suspend</span></span><br><span class=\"line\"><span class=\"comment\"># 让系统进入冬眠状态</span></span><br><span class=\"line\">sudo systemctl hibernate</span><br><span class=\"line\"><span class=\"comment\"># 让系统进入交互式休眠状态</span></span><br><span class=\"line\">sudo systemctl hybrid-sleep</span><br><span class=\"line\"><span class=\"comment\"># 启动进入救援状态 (单用户状态, runlevel = 1)</span></span><br><span class=\"line\">sudo systemctl rescue</span><br></pre></td></tr></table></figure></p>\n<p>unit 管理类 的命令种类繁多, 大致可以再细分为两小类: <strong>查看管理类</strong> 与 <strong>操纵动作类</strong>;<br><strong>查看管理类仅仅是统计与查看, 并不改变 unit 的状态:</strong><br>(1) 从整体角度管理 units<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认列出正在运行的 unit</span></span><br><span class=\"line\">sudo systemctl list-units</span><br><span class=\"line\"><span class=\"comment\"># 列出所有 unit, 包括没有找到配置文件的或者启动失败的</span></span><br><span class=\"line\">sudo systemctl list-units --all</span><br><span class=\"line\"><span class=\"comment\"># 列出所有没有运行的 unit</span></span><br><span class=\"line\">sudo systemctl list-units --all --state=inactive</span><br><span class=\"line\"><span class=\"comment\"># 列出所有加载失败的 unit</span></span><br><span class=\"line\">sudo systemctl list-units --failed</span><br><span class=\"line\"><span class=\"comment\"># 列出所有正在运行的, 类型为 service 的 unit; -t: --type</span></span><br><span class=\"line\">sudo systemctl list-units --<span class=\"built_in\">type</span>=service</span><br></pre></td></tr></table></figure></p>\n<p>(2) 管理具体的某个 unit<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的状态</span></span><br><span class=\"line\">sudo systemctl status rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 是否正在运行</span></span><br><span class=\"line\">sudo systemctl is-active rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 是否处于启动失败状态</span></span><br><span class=\"line\">sudo systemctl is-failed rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 服务是否建立了启动链接</span></span><br><span class=\"line\">sudo systemctl is-enabled rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的启动是否依赖其他 unit 的启动, --all 展开所有 target unit 下的每一个详细 unit</span></span><br><span class=\"line\">sudo systemctl list-dependencies --all rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的所有底层参数</span></span><br><span class=\"line\">sudo systemctl show rsyslog.service</span><br><span class=\"line\"><span class=\"comment\"># 显示某个 unit 的指定属性的值</span></span><br><span class=\"line\">sudo systemctl show -p CPUShares rsyslog.service</span><br></pre></td></tr></table></figure></p>\n<p><strong>操纵动作类, 主要是针对 service unit:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置为开机启动</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">sudo systemctl start nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">sudo systemctl stop nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 重启</span></span><br><span class=\"line\">sudo systemctl restart nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 杀死一个服务的所有子进程</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">kill</span> nginx.service</span><br><span class=\"line\"><span class=\"comment\"># 重新加载一个服务的配置文件</span></span><br><span class=\"line\">sudo systemctl reload nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置某个 unit 的指定属性</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">set</span>-property nginx.service CPUShares=500</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"systemctl-的状态与诊断\"><a href=\"#systemctl-的状态与诊断\" class=\"headerlink\" title=\"systemctl 的状态与诊断\"></a><strong>systemctl 的状态与诊断</strong></h3><p>使用 systemctl status 输出服务详情状态:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Loaded:   该 unit 配置文件的位置以及是否开机启动</span></span><br><span class=\"line\"><span class=\"comment\"># Active:   运行状态</span></span><br><span class=\"line\"><span class=\"comment\"># Main PID: 父进程 pid</span></span><br><span class=\"line\"><span class=\"comment\"># CGroup:   所有的子进程列表</span></span><br><span class=\"line\"><span class=\"comment\"># 最后是 service 的日志</span></span><br><span class=\"line\">&gt; sudo systemctl status rsyslog.service</span><br><span class=\"line\"></span><br><span class=\"line\">● rsyslog.service - System Logging Service</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Wed 2017-07-19 16:01:19 CST; 6 months 10 days ago</span><br><span class=\"line\"> Main PID: 504 (rsyslogd)</span><br><span class=\"line\">   CGroup: /system.slice/rsyslog.service</span><br><span class=\"line\">           └─504 /usr/sbin/rsyslogd -n</span><br><span class=\"line\"></span><br><span class=\"line\">Jul 19 16:01:19 localhost.localdomain systemd[1]: Starting System Logging Service...</span><br><span class=\"line\">Jul 19 16:01:19 localhost.localdomain systemd[1]: Started System Logging Service.</span><br></pre></td></tr></table></figure></p>\n<p>使用 journalctl 查看日志:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定查看某个 unit 的日志</span></span><br><span class=\"line\">sudo journalctl -u nagios</span><br><span class=\"line\"><span class=\"comment\"># 指定时间范围 --since=  --until=</span></span><br><span class=\"line\">sudo journalctl -u nagios -S <span class=\"string\">\"2017-04-19 09:00:00\"</span></span><br><span class=\"line\">sudo journalctl -u nagios -S <span class=\"string\">\"2 days ago\"</span></span><br><span class=\"line\">sudo journalctl -u nagios -U <span class=\"string\">\"2017-12-31 23:59:59\"</span></span><br><span class=\"line\"><span class=\"comment\"># 指定某次启动后的所有日志</span></span><br><span class=\"line\">sudo journalctl -u nagios -b [-0] <span class=\"comment\"># 当前启动后</span></span><br><span class=\"line\">sudo journalctl -u nagios -b  -1  <span class=\"comment\"># 上次启动后</span></span><br><span class=\"line\">sudo journalctl -u nagios -b  -2  <span class=\"comment\"># 继续往上追溯</span></span><br></pre></td></tr></table></figure></p>\n<p>关于 journalctl 的详细内容, 请参见另外一篇文章: <a href=\"\">sysvinit / systemd 日志系统的使用与对比</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">sysvinit/systemd/upstart 初始化过程梳理</a></li>\n<li><a href=\"\">systemd 的定时器功能</a></li>\n<li><a href=\"\">systemd 相关配置文件整理</a></li>\n<li><a href=\"\">sysvinit / systemd 日志系统的使用与对比</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://www.cnblogs.com/panjun-Donet/archive/2010/08/10/1796873.html\" target=\"_blank\" rel=\"noopener\">Linux下chkconfig命令详解</a></li>\n<li><a href=\"http://man.linuxde.net/ntsysv\" target=\"_blank\" rel=\"noopener\">ntsysv命令</a></li>\n<li><a href=\"https://zhangzifan.com/centos-systemctl.html\" target=\"_blank\" rel=\"noopener\">CentOS 7 启动, 重启, chkconfig 等命令已经合并为 systemctl</a></li>\n<li><a href=\"http://blog.csdn.net/catoop/article/details/47318225\" target=\"_blank\" rel=\"noopener\">RHEL 7 中 systemctl 的用法 (替代service 和 chkconfig)</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\" target=\"_blank\" rel=\"noopener\">Systemd 入门教程: 命令篇</a></li>\n<li><a href=\"https://linux.cn/article-5926-1.html\" target=\"_blank\" rel=\"noopener\">systemctl 命令完全指南</a></li>\n</ul>"},{"title":"du / df 使用及其区别","date":"2017-04-07T14:58:04.000Z","_content":"\n> 本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;\n接着, 一般性得总结这两个命令在实际工作中的应用;\n然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;\n\n<!--more-->\n\n------\n\n## **du命令**\n> estimate disk file space usage. --- man du\n\n### **du 的常用选项**\n``` bash\n# 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小\nsudo du /target_path\n# 列举指定路径下所有的文件(包括目录与文件)的大小\nsudo du -a /target_path\n# 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)\nsudo du -s /target_path\n# 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和\n# (诊断 磁盘满问题 最常用的方式)\nsudo du -sh /target_path/*\n# 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和\n# 理论上这与目标路径不含通配符的 -sh 输出结果是相同的\nsudo du -c /target_path\n```\n\n## **df 命令**\n> file system disk space usage. --- man df\n\n### **df 的常用选项**\n``` bash\n# 显示给定的路径所挂载的磁盘分区的大小及使用量等\ndf /target_path\n# 以 MB 最小单位显示大小及使用量\ndf --block-size=1m /target_path\ndf -B 1m /target_path\n# 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况\ndf -h # 1024\ndf -H # 1000\n# 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)\ndf -a\n# 过滤 nfs 远程文件系统后的本地文件系统\ndf -l\n```\n&nbsp;\n**一般性总结:**\ndf 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小; \n所以 df 命令的主要运用场景是: `df -h`, 判断所挂载的每个分区的使用率, 是不是满了;\n作为先决判断依据, 如果发现磁盘满了, 再接着使用 `du -sh` 等命令进一步排查;\n&nbsp;\n\n## **du 与 df 命令的区别**\n### **df 命令与 du 命令的工作原理**\ndf 命令使用 系统调用 `statfs`, 获取磁盘分区的超级块 (super block) 使用情况;\ndu 命令使用 系统调用 `fstat`, 获取待统计文件的大小;\n### **df 命令与 du 命令可接受范围内不一致**\n[**问题场景**]: *du -s 与 df 核算精确结果总有差异;*\n&nbsp;\n[**原因**]: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;\ndf 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;\n所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;\n&nbsp;\n[**结论**]: *这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;*\n### **df 命令与 du 命令显著不一致**\n[**问题场景**]: *当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量仍会将其计入在内;*\n&nbsp;\n[**原因**]: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;\n这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;\n&nbsp;\n[**结论**]: *这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;*\n### **问题解决方案**\n磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:\n1.配合使用 lsof 找出相关的 `幽灵文件` 的句柄持有情况(command 与 pid):\n``` bash\n> sudo lsof | grep deleted\nnginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/local/openresty/nginx/client_body_temp/0068359496 (deleted)\nnginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/local/openresty/nginx/client_body_temp/0068359498 (deleted)\n...\n```\n然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;\n当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号) 和 [nginx signals 处理]();\n另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来; \n所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: [logrotate 配置与运维]();\n&nbsp;\n2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:\n``` bash\n# 将文件写空\nsudo echo > file_path\n```\n将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;\n\n## **站内相关文章**\n- [logrotate 配置与运维](https://zshell-zhang.github.io/2018/01/15/linux-varlog--logrotate%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E7%BB%B4/)\n- [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号)\n- [nginx signals 处理]()\n\n## **参考链接**\n- [df和du显示的磁盘空间使用情况不一致的原因及处理](http://www.cnblogs.com/heyonggang/p/3644736.html)\n- [linux lsof 详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n\n","source":"_posts/linux-disk--du_df使用及其区别.md","raw":"---\ntitle: du / df 使用及其区别\ndate: 2017-04-07 22:58:04\ncategories:\n - linux\n - disk\ntags:\n - linux:disk\n---\n\n> 本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;\n接着, 一般性得总结这两个命令在实际工作中的应用;\n然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;\n\n<!--more-->\n\n------\n\n## **du命令**\n> estimate disk file space usage. --- man du\n\n### **du 的常用选项**\n``` bash\n# 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小\nsudo du /target_path\n# 列举指定路径下所有的文件(包括目录与文件)的大小\nsudo du -a /target_path\n# 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)\nsudo du -s /target_path\n# 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和\n# (诊断 磁盘满问题 最常用的方式)\nsudo du -sh /target_path/*\n# 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和\n# 理论上这与目标路径不含通配符的 -sh 输出结果是相同的\nsudo du -c /target_path\n```\n\n## **df 命令**\n> file system disk space usage. --- man df\n\n### **df 的常用选项**\n``` bash\n# 显示给定的路径所挂载的磁盘分区的大小及使用量等\ndf /target_path\n# 以 MB 最小单位显示大小及使用量\ndf --block-size=1m /target_path\ndf -B 1m /target_path\n# 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况\ndf -h # 1024\ndf -H # 1000\n# 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)\ndf -a\n# 过滤 nfs 远程文件系统后的本地文件系统\ndf -l\n```\n&nbsp;\n**一般性总结:**\ndf 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小; \n所以 df 命令的主要运用场景是: `df -h`, 判断所挂载的每个分区的使用率, 是不是满了;\n作为先决判断依据, 如果发现磁盘满了, 再接着使用 `du -sh` 等命令进一步排查;\n&nbsp;\n\n## **du 与 df 命令的区别**\n### **df 命令与 du 命令的工作原理**\ndf 命令使用 系统调用 `statfs`, 获取磁盘分区的超级块 (super block) 使用情况;\ndu 命令使用 系统调用 `fstat`, 获取待统计文件的大小;\n### **df 命令与 du 命令可接受范围内不一致**\n[**问题场景**]: *du -s 与 df 核算精确结果总有差异;*\n&nbsp;\n[**原因**]: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;\ndf 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;\n所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;\n&nbsp;\n[**结论**]: *这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;*\n### **df 命令与 du 命令显著不一致**\n[**问题场景**]: *当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量仍会将其计入在内;*\n&nbsp;\n[**原因**]: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;\n这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;\n&nbsp;\n[**结论**]: *这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;*\n### **问题解决方案**\n磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:\n1.配合使用 lsof 找出相关的 `幽灵文件` 的句柄持有情况(command 与 pid):\n``` bash\n> sudo lsof | grep deleted\nnginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/local/openresty/nginx/client_body_temp/0068359496 (deleted)\nnginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/local/openresty/nginx/client_body_temp/0068359498 (deleted)\n...\n```\n然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;\n当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号) 和 [nginx signals 处理]();\n另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来; \n所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: [logrotate 配置与运维]();\n&nbsp;\n2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:\n``` bash\n# 将文件写空\nsudo echo > file_path\n```\n将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;\n\n## **站内相关文章**\n- [logrotate 配置与运维](https://zshell-zhang.github.io/2018/01/15/linux-varlog--logrotate%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E7%BB%B4/)\n- [linux signals 总体认识#其他信号](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号)\n- [nginx signals 处理]()\n\n## **参考链接**\n- [df和du显示的磁盘空间使用情况不一致的原因及处理](http://www.cnblogs.com/heyonggang/p/3644736.html)\n- [linux lsof 详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n\n","slug":"linux-disk--du_df使用及其区别","published":1,"updated":"2018-04-06T13:22:05.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5e0005j1jxwyogtosg","content":"<blockquote>\n<p>本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;<br>接着, 一般性得总结这两个命令在实际工作中的应用;<br>然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a><strong>du命令</strong></h2><blockquote>\n<p>estimate disk file space usage. — man du</p>\n</blockquote>\n<h3 id=\"du-的常用选项\"><a href=\"#du-的常用选项\" class=\"headerlink\" title=\"du 的常用选项\"></a><strong>du 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小</span></span><br><span class=\"line\">sudo du /target_path</span><br><span class=\"line\"><span class=\"comment\"># 列举指定路径下所有的文件(包括目录与文件)的大小</span></span><br><span class=\"line\">sudo du -a /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)</span></span><br><span class=\"line\">sudo du -s /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和</span></span><br><span class=\"line\"><span class=\"comment\"># (诊断 磁盘满问题 最常用的方式)</span></span><br><span class=\"line\">sudo du -sh /target_path/*</span><br><span class=\"line\"><span class=\"comment\"># 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和</span></span><br><span class=\"line\"><span class=\"comment\"># 理论上这与目标路径不含通配符的 -sh 输出结果是相同的</span></span><br><span class=\"line\">sudo du -c /target_path</span><br></pre></td></tr></table></figure>\n<h2 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a><strong>df 命令</strong></h2><blockquote>\n<p>file system disk space usage. — man df</p>\n</blockquote>\n<h3 id=\"df-的常用选项\"><a href=\"#df-的常用选项\" class=\"headerlink\" title=\"df 的常用选项\"></a><strong>df 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示给定的路径所挂载的磁盘分区的大小及使用量等</span></span><br><span class=\"line\">df /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 MB 最小单位显示大小及使用量</span></span><br><span class=\"line\">df --block-size=1m /target_path</span><br><span class=\"line\">df -B 1m /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况</span></span><br><span class=\"line\">df -h <span class=\"comment\"># 1024</span></span><br><span class=\"line\">df -H <span class=\"comment\"># 1000</span></span><br><span class=\"line\"><span class=\"comment\"># 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)</span></span><br><span class=\"line\">df -a</span><br><span class=\"line\"><span class=\"comment\"># 过滤 nfs 远程文件系统后的本地文件系统</span></span><br><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n<p>&nbsp;<br><strong>一般性总结:</strong><br>df 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小;<br>所以 df 命令的主要运用场景是: <code>df -h</code>, 判断所挂载的每个分区的使用率, 是不是满了;<br>作为先决判断依据, 如果发现磁盘满了, 再接着使用 <code>du -sh</code> 等命令进一步排查;<br>&nbsp;</p>\n<h2 id=\"du-与-df-命令的区别\"><a href=\"#du-与-df-命令的区别\" class=\"headerlink\" title=\"du 与 df 命令的区别\"></a><strong>du 与 df 命令的区别</strong></h2><h3 id=\"df-命令与-du-命令的工作原理\"><a href=\"#df-命令与-du-命令的工作原理\" class=\"headerlink\" title=\"df 命令与 du 命令的工作原理\"></a><strong>df 命令与 du 命令的工作原理</strong></h3><p>df 命令使用 系统调用 <code>statfs</code>, 获取磁盘分区的超级块 (super block) 使用情况;<br>du 命令使用 系统调用 <code>fstat</code>, 获取待统计文件的大小;</p>\n<h3 id=\"df-命令与-du-命令可接受范围内不一致\"><a href=\"#df-命令与-du-命令可接受范围内不一致\" class=\"headerlink\" title=\"df 命令与 du 命令可接受范围内不一致\"></a><strong>df 命令与 du 命令可接受范围内不一致</strong></h3><p>[<strong>问题场景</strong>]: <em>du -s 与 df 核算精确结果总有差异;</em><br>&nbsp;<br>[<strong>原因</strong>]: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;<br>df 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;<br>所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;<br>&nbsp;<br>[<strong>结论</strong>]: <em>这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;</em></p>\n<h3 id=\"df-命令与-du-命令显著不一致\"><a href=\"#df-命令与-du-命令显著不一致\" class=\"headerlink\" title=\"df 命令与 du 命令显著不一致\"></a><strong>df 命令与 du 命令显著不一致</strong></h3><p>[<strong>问题场景</strong>]: <em>当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量仍会将其计入在内;</em><br>&nbsp;<br>[<strong>原因</strong>]: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;<br>这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;<br>&nbsp;<br>[<strong>结论</strong>]: <em>这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;</em></p>\n<h3 id=\"问题解决方案\"><a href=\"#问题解决方案\" class=\"headerlink\" title=\"问题解决方案\"></a><strong>问题解决方案</strong></h3><p>磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:<br>1.配合使用 lsof 找出相关的 <code>幽灵文件</code> 的句柄持有情况(command 与 pid):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo lsof | grep deleted</span><br><span class=\"line\">nginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359496 (deleted)</span><br><span class=\"line\">nginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359498 (deleted)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;<br>当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识#其他信号</a> 和 <a href=\"\">nginx signals 处理</a>;<br>另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来;<br>所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: <a href=\"\">logrotate 配置与运维</a>;<br>&nbsp;<br>2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件写空</span></span><br><span class=\"line\">sudo <span class=\"built_in\">echo</span> &gt; file_path</span><br></pre></td></tr></table></figure></p>\n<p>将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"https://zshell-zhang.github.io/2018/01/15/linux-varlog--logrotate%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E7%BB%B4/\" target=\"_blank\" rel=\"noopener\">logrotate 配置与运维</a></li>\n<li><a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识#其他信号</a></li>\n<li><a href=\"\">nginx signals 处理</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/heyonggang/p/3644736.html\" target=\"_blank\" rel=\"noopener\">df和du显示的磁盘空间使用情况不一致的原因及处理</a></li>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof 详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要是整理 磁盘使用量 相关的命令, 如 du, df 等;<br>接着, 一般性得总结这两个命令在实际工作中的应用;<br>然后再以 du, df 命令的区别为例, 讨论命令背后的逻辑, 工作中存在的问题, 最后引申出问题解决的工具: lsof;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a><strong>du命令</strong></h2><blockquote>\n<p>estimate disk file space usage. — man du</p>\n</blockquote>\n<h3 id=\"du-的常用选项\"><a href=\"#du-的常用选项\" class=\"headerlink\" title=\"du 的常用选项\"></a><strong>du 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不加任何选项, 默认是 列举指定路径下, 每一个目录(递归所有的子目录)的大小</span></span><br><span class=\"line\">sudo du /target_path</span><br><span class=\"line\"><span class=\"comment\"># 列举指定路径下所有的文件(包括目录与文件)的大小</span></span><br><span class=\"line\">sudo du -a /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的形式, 列举目标路径的文件磁盘占用总大小(将该路径下所有子文件大小求和)</span></span><br><span class=\"line\">sudo du -s /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以指定路径下所有的子一级路径为 target, 以 human-readable 的方式列举其中每一个下的所有子文件大小之和</span></span><br><span class=\"line\"><span class=\"comment\"># (诊断 磁盘满问题 最常用的方式)</span></span><br><span class=\"line\">sudo du -sh /target_path/*</span><br><span class=\"line\"><span class=\"comment\"># 除了其余选项该有的输出之外, 最后一行另附一个给定 target_path 下的 total 总和</span></span><br><span class=\"line\"><span class=\"comment\"># 理论上这与目标路径不含通配符的 -sh 输出结果是相同的</span></span><br><span class=\"line\">sudo du -c /target_path</span><br></pre></td></tr></table></figure>\n<h2 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a><strong>df 命令</strong></h2><blockquote>\n<p>file system disk space usage. — man df</p>\n</blockquote>\n<h3 id=\"df-的常用选项\"><a href=\"#df-的常用选项\" class=\"headerlink\" title=\"df 的常用选项\"></a><strong>df 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示给定的路径所挂载的磁盘分区的大小及使用量等</span></span><br><span class=\"line\">df /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 MB 最小单位显示大小及使用量</span></span><br><span class=\"line\">df --block-size=1m /target_path</span><br><span class=\"line\">df -B 1m /target_path</span><br><span class=\"line\"><span class=\"comment\"># 以 human-readable 的方式显示 当前挂载的所有可用健康的文件系统 的大小, 使用量等情况</span></span><br><span class=\"line\">df -h <span class=\"comment\"># 1024</span></span><br><span class=\"line\">df -H <span class=\"comment\"># 1000</span></span><br><span class=\"line\"><span class=\"comment\"># 显示所有的文件系统, 包括 伪文件系统, 重复的, 不可访问的文件系统 (pseudo, duplicate, inaccessible)</span></span><br><span class=\"line\">df -a</span><br><span class=\"line\"><span class=\"comment\"># 过滤 nfs 远程文件系统后的本地文件系统</span></span><br><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n<p>&nbsp;<br><strong>一般性总结:</strong><br>df 命令主要关心的是磁盘分区的 size, 而不是具体某文件的占用大小;<br>所以 df 命令的主要运用场景是: <code>df -h</code>, 判断所挂载的每个分区的使用率, 是不是满了;<br>作为先决判断依据, 如果发现磁盘满了, 再接着使用 <code>du -sh</code> 等命令进一步排查;<br>&nbsp;</p>\n<h2 id=\"du-与-df-命令的区别\"><a href=\"#du-与-df-命令的区别\" class=\"headerlink\" title=\"du 与 df 命令的区别\"></a><strong>du 与 df 命令的区别</strong></h2><h3 id=\"df-命令与-du-命令的工作原理\"><a href=\"#df-命令与-du-命令的工作原理\" class=\"headerlink\" title=\"df 命令与 du 命令的工作原理\"></a><strong>df 命令与 du 命令的工作原理</strong></h3><p>df 命令使用 系统调用 <code>statfs</code>, 获取磁盘分区的超级块 (super block) 使用情况;<br>du 命令使用 系统调用 <code>fstat</code>, 获取待统计文件的大小;</p>\n<h3 id=\"df-命令与-du-命令可接受范围内不一致\"><a href=\"#df-命令与-du-命令可接受范围内不一致\" class=\"headerlink\" title=\"df 命令与 du 命令可接受范围内不一致\"></a><strong>df 命令与 du 命令可接受范围内不一致</strong></h3><p>[<strong>问题场景</strong>]: <em>du -s 与 df 核算精确结果总有差异;</em><br>&nbsp;<br>[<strong>原因</strong>]: du -s 命令通过将指定文件系统中所有的目录, 符号链接和文件使用的块数累加得到该文件系统使用的总块数, 这是上层用户级的数据;<br>df 命令通过查看文件系统磁盘块分配图得出总块数与剩余块数, 这是直接从底层获取的数据;<br>所以, 一些元数据信息(inode, super blocks 等)不会被上层的 du 命令计入在内, 而 df 命令由于直接获取的底层超级块的信息, 则会将其计入在内;<br>&nbsp;<br>[<strong>结论</strong>]: <em>这种差异属于系统性的差异, 是由命令的特点决定的, 无法改变;</em></p>\n<h3 id=\"df-命令与-du-命令显著不一致\"><a href=\"#df-命令与-du-命令显著不一致\" class=\"headerlink\" title=\"df 命令与 du 命令显著不一致\"></a><strong>df 命令与 du 命令显著不一致</strong></h3><p>[<strong>问题场景</strong>]: <em>当一个被某进程持有其句柄的文件被删除后, 进程不释放句柄, du 将不会再统计该文件, 而 df 的使用量仍会将其计入在内;</em><br>&nbsp;<br>[<strong>原因</strong>]: 当文件句柄被进程持有, 尽管文件被删除, 目录项已经不存在该文件路径了, 但只要句柄不释放, 文件在磁盘上就不会真正删除该文件;<br>这样一来, 目录项不存在该文件了, du 命令就不会统计到该文件, 但文件没真正删除, 磁盘分区 super block 的信息就不会改变, df 命令仍会将其计入使用量;<br>&nbsp;<br>[<strong>结论</strong>]: <em>这种差异属于第三方因素干扰导致的差异, 且差异十分显著, 需要通过下一节所讨论的方式加以解决;</em></p>\n<h3 id=\"问题解决方案\"><a href=\"#问题解决方案\" class=\"headerlink\" title=\"问题解决方案\"></a><strong>问题解决方案</strong></h3><p>磁盘满了, 但是有进程持有大文件的句柄, 无法真正从磁盘删除掉; 对于这类问题, 有如下两种解决方案:<br>1.配合使用 lsof 找出相关的 <code>幽灵文件</code> 的句柄持有情况(command 与 pid):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sudo lsof | grep deleted</span><br><span class=\"line\">nginx      4804      nobody   59u      REG\t253,1    110116  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359496 (deleted)</span><br><span class=\"line\">nginx      4819      nobody   51u      REG\t253,1    115876  243425480 /usr/<span class=\"built_in\">local</span>/openresty/nginx/client_body_temp/0068359498 (deleted)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>然后 kill 掉进程 (或 restart 进程), 即可释放文件句柄;<br>当然, 本文是以 nginx 举例, 但实际上 nginx 对于日志文件的文件句柄释放, 有自己专有的方法, 具体内容请见本站另外两篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识#其他信号</a> 和 <a href=\"\">nginx signals 处理</a>;<br>另外, 磁盘满的问题, 不能总是靠人肉登机器去解决, 我们需要一些自动化的方案来将我们从这种低级的操作中解放出来;<br>所以, 对于所有机器上都会遇到的日志文件不断累积占满磁盘的问题, 这篇文章介绍了解决方案: <a href=\"\">logrotate 配置与运维</a>;<br>&nbsp;<br>2.如果进程很重要, 不能容忍任何时间范围内的服务不可用 (其实理论上这种情况属于单点瓶颈, 未能做到高可用), 则可以采用如下方式:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件写空</span></span><br><span class=\"line\">sudo <span class=\"built_in\">echo</span> &gt; file_path</span><br></pre></td></tr></table></figure></p>\n<p>将文件内容间接删除, 这样即便句柄未释放, 但文件本身已经没有内容, 也就不再占用空间了;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"https://zshell-zhang.github.io/2018/01/15/linux-varlog--logrotate%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E7%BB%B4/\" target=\"_blank\" rel=\"noopener\">logrotate 配置与运维</a></li>\n<li><a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals总体认识/#其他信号\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识#其他信号</a></li>\n<li><a href=\"\">nginx signals 处理</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.cnblogs.com/heyonggang/p/3644736.html\" target=\"_blank\" rel=\"noopener\">df和du显示的磁盘空间使用情况不一致的原因及处理</a></li>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof 详解</a></li>\n</ul>"},{"title":"chattr / lsattr 使用总结","date":"2018-04-06T13:23:22.000Z","_content":"\n> 对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;\n对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;\n\n<!--more-->\n\n------\n\n### **chattr 命令**\n``` bash\n# + 在原有参数基础上追加设置\n# - 在原有参数基础上移除设置\n# = 将设置更改为指定的参数\n# mode 指定的设置项\nsudo chattr +|-|=mode file_path\n\n# 递归设置指定目录下的所有文件\nsudo chattr -R +|-|=mode file_path\n```\n\n其中, mode 中常用的设置项如下:\n``` bash\na   设置只能向指定文件中追加内容, 不能删除\ni   设置文件不能修改, 删除, 不能被设置链接关系, 是最常用的 mode\ns   security, 当 rm 该文件时, 从磁盘上彻底删除它;\n```\n\nchattr 并非万能, 以下几个目录 chattr 并不能干预:\n``` bash\n/\n/dev\n/tmp\n/var\n```\n\n### **lsattr 命令**\nlsattr 命令用于查看文件被 chattr 设置的情况;\n``` bash\n> lsattr file_path\n----i--------e- file_path\n```\n可以发现, 有的时候 lsattr 所展示的文件属性掩码中, 有一个 `e`, 这在 chattr 的 manual 文档里是这么说的:\n> The `e` attribute indicates that the file is using extents for mapping the blocks on disk. It may not be removed using chattr(1).\n\n所以说, 对 chattr 来说, 这个掩码并不意味着什么;\n\n### **常用的情景**\n对于生产环境中的机器, 有如下一些重要文件一般会将其用 chattr 设为不可修改, 不可删除:\n``` bash\nsudo chattr +i /etc/resolv.conf\nsudo chattr +i /etc/hosts.allow\nsudo chattr +i /etc/hosts.deny\n```\n其中, /etc/hosts.allow 与 /etc/hosts.deny 是关于 ssh 的登陆白名单/黑名单信息, 安全考虑, 正常只允许跳板机 ssh 到本机, 而禁止其他所有的机器; 这两个文件绝不允许被无故修改;\n而 /etc/resolv.conf 则是关于 dns 解析的文件, 一旦被修改, 会导致一些网络请求中的域名无法正常解析, 所以也需要被 chattr 锁定防止无故修改;\n\n### **参考链接**\n- [Linux的chattr与lsattr命令详解](http://www.ha97.com/5172.html)\n\n","source":"_posts/linux-disk--chattr_lsattr使用总结.md","raw":"---\ntitle: chattr / lsattr 使用总结\ndate: 2018-04-06 21:23:22\ncategories:\n - linux\n - disk\ntags:\n - linux:disk\n - 系统安全\n---\n\n> 对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;\n对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;\n\n<!--more-->\n\n------\n\n### **chattr 命令**\n``` bash\n# + 在原有参数基础上追加设置\n# - 在原有参数基础上移除设置\n# = 将设置更改为指定的参数\n# mode 指定的设置项\nsudo chattr +|-|=mode file_path\n\n# 递归设置指定目录下的所有文件\nsudo chattr -R +|-|=mode file_path\n```\n\n其中, mode 中常用的设置项如下:\n``` bash\na   设置只能向指定文件中追加内容, 不能删除\ni   设置文件不能修改, 删除, 不能被设置链接关系, 是最常用的 mode\ns   security, 当 rm 该文件时, 从磁盘上彻底删除它;\n```\n\nchattr 并非万能, 以下几个目录 chattr 并不能干预:\n``` bash\n/\n/dev\n/tmp\n/var\n```\n\n### **lsattr 命令**\nlsattr 命令用于查看文件被 chattr 设置的情况;\n``` bash\n> lsattr file_path\n----i--------e- file_path\n```\n可以发现, 有的时候 lsattr 所展示的文件属性掩码中, 有一个 `e`, 这在 chattr 的 manual 文档里是这么说的:\n> The `e` attribute indicates that the file is using extents for mapping the blocks on disk. It may not be removed using chattr(1).\n\n所以说, 对 chattr 来说, 这个掩码并不意味着什么;\n\n### **常用的情景**\n对于生产环境中的机器, 有如下一些重要文件一般会将其用 chattr 设为不可修改, 不可删除:\n``` bash\nsudo chattr +i /etc/resolv.conf\nsudo chattr +i /etc/hosts.allow\nsudo chattr +i /etc/hosts.deny\n```\n其中, /etc/hosts.allow 与 /etc/hosts.deny 是关于 ssh 的登陆白名单/黑名单信息, 安全考虑, 正常只允许跳板机 ssh 到本机, 而禁止其他所有的机器; 这两个文件绝不允许被无故修改;\n而 /etc/resolv.conf 则是关于 dns 解析的文件, 一旦被修改, 会导致一些网络请求中的域名无法正常解析, 所以也需要被 chattr 锁定防止无故修改;\n\n### **参考链接**\n- [Linux的chattr与lsattr命令详解](http://www.ha97.com/5172.html)\n\n","slug":"linux-disk--chattr_lsattr使用总结","published":1,"updated":"2018-04-07T10:08:56.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5g0006j1jxbvhw18n8","content":"<blockquote>\n<p>对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;<br>对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"chattr-命令\"><a href=\"#chattr-命令\" class=\"headerlink\" title=\"chattr 命令\"></a><strong>chattr 命令</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># + 在原有参数基础上追加设置</span></span><br><span class=\"line\"><span class=\"comment\"># - 在原有参数基础上移除设置</span></span><br><span class=\"line\"><span class=\"comment\"># = 将设置更改为指定的参数</span></span><br><span class=\"line\"><span class=\"comment\"># mode 指定的设置项</span></span><br><span class=\"line\">sudo chattr +|-|=mode file_path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 递归设置指定目录下的所有文件</span></span><br><span class=\"line\">sudo chattr -R +|-|=mode file_path</span><br></pre></td></tr></table></figure>\n<p>其中, mode 中常用的设置项如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a   设置只能向指定文件中追加内容, 不能删除</span><br><span class=\"line\">i   设置文件不能修改, 删除, 不能被设置链接关系, 是最常用的 mode</span><br><span class=\"line\">s   security, 当 rm 该文件时, 从磁盘上彻底删除它;</span><br></pre></td></tr></table></figure></p>\n<p>chattr 并非万能, 以下几个目录 chattr 并不能干预:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\">/dev</span><br><span class=\"line\">/tmp</span><br><span class=\"line\">/var</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"lsattr-命令\"><a href=\"#lsattr-命令\" class=\"headerlink\" title=\"lsattr 命令\"></a><strong>lsattr 命令</strong></h3><p>lsattr 命令用于查看文件被 chattr 设置的情况;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr file_path</span><br><span class=\"line\">----i--------e- file_path</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, 有的时候 lsattr 所展示的文件属性掩码中, 有一个 <code>e</code>, 这在 chattr 的 manual 文档里是这么说的:</p>\n<blockquote>\n<p>The <code>e</code> attribute indicates that the file is using extents for mapping the blocks on disk. It may not be removed using chattr(1).</p>\n</blockquote>\n<p>所以说, 对 chattr 来说, 这个掩码并不意味着什么;</p>\n<h3 id=\"常用的情景\"><a href=\"#常用的情景\" class=\"headerlink\" title=\"常用的情景\"></a><strong>常用的情景</strong></h3><p>对于生产环境中的机器, 有如下一些重要文件一般会将其用 chattr 设为不可修改, 不可删除:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chattr +i /etc/resolv.conf</span><br><span class=\"line\">sudo chattr +i /etc/hosts.allow</span><br><span class=\"line\">sudo chattr +i /etc/hosts.deny</span><br></pre></td></tr></table></figure></p>\n<p>其中, /etc/hosts.allow 与 /etc/hosts.deny 是关于 ssh 的登陆白名单/黑名单信息, 安全考虑, 正常只允许跳板机 ssh 到本机, 而禁止其他所有的机器; 这两个文件绝不允许被无故修改;<br>而 /etc/resolv.conf 则是关于 dns 解析的文件, 一旦被修改, 会导致一些网络请求中的域名无法正常解析, 所以也需要被 chattr 锁定防止无故修改;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.ha97.com/5172.html\" target=\"_blank\" rel=\"noopener\">Linux的chattr与lsattr命令详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;<br>对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"chattr-命令\"><a href=\"#chattr-命令\" class=\"headerlink\" title=\"chattr 命令\"></a><strong>chattr 命令</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># + 在原有参数基础上追加设置</span></span><br><span class=\"line\"><span class=\"comment\"># - 在原有参数基础上移除设置</span></span><br><span class=\"line\"><span class=\"comment\"># = 将设置更改为指定的参数</span></span><br><span class=\"line\"><span class=\"comment\"># mode 指定的设置项</span></span><br><span class=\"line\">sudo chattr +|-|=mode file_path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 递归设置指定目录下的所有文件</span></span><br><span class=\"line\">sudo chattr -R +|-|=mode file_path</span><br></pre></td></tr></table></figure>\n<p>其中, mode 中常用的设置项如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a   设置只能向指定文件中追加内容, 不能删除</span><br><span class=\"line\">i   设置文件不能修改, 删除, 不能被设置链接关系, 是最常用的 mode</span><br><span class=\"line\">s   security, 当 rm 该文件时, 从磁盘上彻底删除它;</span><br></pre></td></tr></table></figure></p>\n<p>chattr 并非万能, 以下几个目录 chattr 并不能干预:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\">/dev</span><br><span class=\"line\">/tmp</span><br><span class=\"line\">/var</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"lsattr-命令\"><a href=\"#lsattr-命令\" class=\"headerlink\" title=\"lsattr 命令\"></a><strong>lsattr 命令</strong></h3><p>lsattr 命令用于查看文件被 chattr 设置的情况;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lsattr file_path</span><br><span class=\"line\">----i--------e- file_path</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, 有的时候 lsattr 所展示的文件属性掩码中, 有一个 <code>e</code>, 这在 chattr 的 manual 文档里是这么说的:</p>\n<blockquote>\n<p>The <code>e</code> attribute indicates that the file is using extents for mapping the blocks on disk. It may not be removed using chattr(1).</p>\n</blockquote>\n<p>所以说, 对 chattr 来说, 这个掩码并不意味着什么;</p>\n<h3 id=\"常用的情景\"><a href=\"#常用的情景\" class=\"headerlink\" title=\"常用的情景\"></a><strong>常用的情景</strong></h3><p>对于生产环境中的机器, 有如下一些重要文件一般会将其用 chattr 设为不可修改, 不可删除:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chattr +i /etc/resolv.conf</span><br><span class=\"line\">sudo chattr +i /etc/hosts.allow</span><br><span class=\"line\">sudo chattr +i /etc/hosts.deny</span><br></pre></td></tr></table></figure></p>\n<p>其中, /etc/hosts.allow 与 /etc/hosts.deny 是关于 ssh 的登陆白名单/黑名单信息, 安全考虑, 正常只允许跳板机 ssh 到本机, 而禁止其他所有的机器; 这两个文件绝不允许被无故修改;<br>而 /etc/resolv.conf 则是关于 dns 解析的文件, 一旦被修改, 会导致一些网络请求中的域名无法正常解析, 所以也需要被 chattr 锁定防止无故修改;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.ha97.com/5172.html\" target=\"_blank\" rel=\"noopener\">Linux的chattr与lsattr命令详解</a></li>\n</ul>"},{"title":"elasticsearch 6.x 升级调研报告","date":"2018-03-24T14:11:48.000Z","_content":"\n> 关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;\n在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;\n希望能给各位读者带来工作上的帮助!\n\n<!--more-->\n\n------\n\n**万字长文, 高能预警! 如只希望了解最终结论, 请点击:** *[本文总结](#本文总结);*\n&nbsp;\n戊戌年春, 历时余月, 本文终于迎来了收尾;\n这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: [ES consume high cpu with threadlocal](https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402); 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文即是该升级调研的一个总结报告;\n相比于公司内部发表的版本, 本篇博客对所有涉及公司内部的信息作了脱敏处理, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;\n\n## **客户端兼容性问题**\n在这篇文章的编排结构中, 我将客户端兼容性问题摆在了第一的位置: 因为不管 rest api 如何变化, 或者如何不变, 都只能算是 \"术\"; 我们真正跑在生产环境中的系统, 使用的是 elasticsearch java client; client 端的基础兼容性问题才是根本之 \"道\";\n\n### **巨轮转向的前提: es-adapter**\n我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;\n如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 \"无效\" 工作量, 他们一定不会积极配合, 我们将无法推动进展;\n还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优; 其余的系统必须通过调用其暴露出去的 dubbo 接口间接访问 elasticsearch; 这个系统被命名为 es-adapter;\n当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: [apache httpclient 初始化参数设置总结](); 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;\n有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;\n不得不说, 当系统规模与复杂度发展到了一个 \"船大难掉头\" 的程度时, es-adapter 就像是《三体》中描述的 \"水滴\" 一样, 带领整个体系从一个更高的维度完成 \"平滑\" 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: [search api 的兼容性](#search-api-的兼容性);\n\n### **升级过渡期 client 端的技术选型**\n关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:\n> We plan on deprecating the `TransportClient` in Elasticsearch 7.0 and removing it completely in 8.0.\n\n所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;\n值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;\n要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:\n``` xml\n<!-- elasticsearch core -->\n<dependency>\n    <groupId>org.elasticsearch</groupId>\n    <artifactId>elasticsearch</artifactId>\n    <version>6.2.2</version>\n</dependency>\n<!-- low level rest client -->\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-client</artifactId>\n    <version>6.2.2</version>\n</dependency>\n<!-- high level rest client -->\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n    <version>6.2.2</version>\n</dependency>\n```\n后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;\n之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: [searchbox-io/Jest](https://github.com/searchbox-io/Jest)), 基本囊括了 elasticsearch 各种类别的请求功能;\n但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score, aggregations 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;\n这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;\n我们经过 demo 快速测试验证, 初步得出了结论:\n&nbsp;\n**6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;**\n&nbsp;\n这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: [Compatibility](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html);\n所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;\n\n### **HighLevelClient 的使用注意事项**\n**(1) 初始化的重要选项**\nHighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:\n\n1. `CONNECTION_REQUEST_TIMEOUT`\n2. `CONNECT_TIMEOUT`\n3. `SOCKET_TIMEOUT`\n4. `MAX_CONN_TOTAL`\n5. `MAX_CONN_PER_ROUTE`\n\n不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:\n``` java\nList<HttpHost> httpHosts = Lists.newArrayListWithExpectedSize(serverNum);\nserverAddressList.forEach((server) -> httpHosts.add(new HttpHost(server.getAddr(), server.getPort(), \"http\")));\nprivate RestHighLevelClient highLevelClient = new RestHighLevelClient(\n        RestClient.builder(httpHosts.toArray(new HttpHost[0]))\n        // timeout settings\n        .setRequestConfigCallback((callback) -> callback\n                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)\n                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)\n                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))\n        // connections total and connections per host\n        .setHttpClientConfigCallback((callback) -> callback\n                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)\n                .setMaxConnTotal(MAX_CONN_TOTAL)\n        )\n);\n```\n\n**(2) request timeout 的设置**\n对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;\n这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;\n那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;\n首先需要定义一个 response 容器来盛装异步回调里拿到的 result:\n``` java\nclass ResponseWrapper<T> {\n    private T response;\n    private Exception exception;\n    public T getResponse() { return response; }\n    public void setResponse(T response) { this.response = response; }\n    public Exception getException() { return exception; }\n    public void setException(Exception exception) { this.exception = exception;}\n}\n```\n下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:\n``` java\n/* get request with timeout */\nfinal ResponseWrapper<GetResponse> wrapper = new ResponseWrapper<>();\nfinal CountDownLatch latch = new CountDownLatch(1);\nhighLevelClient.getAsync(request, new ActionListener<GetResponse>() {\n    @Override\n    public void onResponse(GetResponse documentFields) {\n        wrapper.setResponse(documentFields);\n        latch.countDown();\n    }\n    @Override\n    public void onFailure(Exception e) {\n        wrapper.setException(e);\n        wrapper.setResponse(null);\n        latch.countDown();\n    }\n});\ntry {\n    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);\n} catch (InterruptedException e) {\n    throw new ElasticsearchTimeoutException(\"timeout\");\n}\nif (wrapper.getResponse() == null) { // 异常处理 } \nelse { 处理 wrapper.getResponse() 的返回结果 }\n```\n\n**(3) query 请求 dsl 的传参问题**\nes-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:\n``` javascript\n{\n    \"query\": { ... },\n    \"_source\": {\n        \"include\": [ ... ],\n        \"exclude\": [ ... ]\n    },\n    \"from\": xxx,\n    \"size\": yyy,\n    \"sort\": [ ... ],\n    \"aggs\": { ... }\n}\n```\n业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象; \n这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;\n权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:\n``` java\nString dslStr = \"...\";\nSearchModule searchModule = new SearchModule(Settings.EMPTY, false, Collections.emptyList());\nXContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(\n        new NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);\n\nSearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);\n```\n\n**(4) 无厘头的 `adjust_pure_negative`**\n整个 HighLevelClient 中, 最让人感到费解的一个东西就是一个神秘的属性:\n``` java\n/* org.elasticsearch.index.query.BoolQueryBuilder */\nprivate static final ParseField ADJUST_PURE_NEGATIVE = new ParseField(\"adjust_pure_negative\");\nprivate boolean adjustPureNegative = ADJUST_PURE_NEGATIVE_DEFAULT;\n```\n先是看官方文档, 搜不到;\n然后搜 google, 就找到这么一个稍微相关一点的帖子: [What does \"adjust_pure_negative\" flag do?](https://discuss.elastic.co/t/what-does-adjust-pure-negative-flag-do/92348), 而其给出的唯一回复是 \"**You can ignore it**\";\n实在搜不到有效的信息, 我只好去扒源码; 然而, 除了如上所述的 BoolQueryBuilder 中的这坨, 再加上一些测试类, 就再也没在其他地方看到与 `adjust_pure_negative` 相关的逻辑了;\n也许真的如 elastic 讨论组中所说的 *You can ignore it?* 但是现在有一个问题让我无法忽略它: 这个属性无法被 2.4.2 的 elasticsearch 识别, 但在 6.2.2 的 elasticsearch 中, 各个 QueryBuilder 的 toString() 方法会自动将其带上:\n``` javascript\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": { ... },\n      \"should\": { ... },\n      \"must_not\": { ... },\n      \"adjust_pure_negative\": true,\n      \"boost\": 1.0\n    }\n  }\n}\n```\n在上一节中提到, es-adapter 接受业务线传来的 query dsl str, 使用 6.2.2 的 elasticsearch 便会将上述语句传给 es-adapter; 如果其访问的索引已经迁移到 6.2.2 新集群, 那么该语句没问题; 但如果其访问的索引还未来得及迁移到新集群, es-adapter 会将该请求路由到旧的 2.4.2 集群, 接着便会发生语法解析异常;\n&nbsp;\n*这意味着, 在某个系统所需要访问的所有索引迁移到 6.2.2 新集群之前, 其 maven 依赖的 elasticsearch 版本, 不能提前升级到 6.2.2, 以阻止 adjust_pure_negative 的生成;*\n*当然考虑到 major 版本升级所带来的语法规则的巨变已被 es-adapter 缓冲掉了绝大部分, 我相信各业务线也不希望把 elasticsearch 的 maven 版本给直接升上去的; 毕竟那意味着代码将红成一大片, 要花费大量的精力修改代码, 这等于把 es-adapter 原本要替其做的事, 提前自己给办了;*\n\n**(5) 其他小众的需求**\n以上展示的是业务线普遍会遇到的情况, 然后还有两个比较小众的需求, 在个别系统中会使用到,  也是上面所提到的 nested_filter 和 aggregations;\n关于 nested_filter 还稍顺利些, api 有一些变化但是新的 api 有新的解决方案:\n``` java\n// 6.2.2 版本: 构造一个 携带 nested_filter 的 sort\nprivate SortBuilder buildNestedSort(NestedSort nestedSort) {\n    QueryBuilder termFilter = QueryBuilders.termsQuery(nestedSort.getTermField(), nestedSort.getTermValue());\n    return SortBuilders.fieldSort(nestedSort.getSortName())\n            .setNestedSort(new NestedSortBuilder(nestedSort.getNestedPath()).setFilter(termFilter))\n            .order(nestedSort.getOrder())\n            .sortMode(SortMode.fromString(nestedSort.getSortMode()))\n            .missing(nestedSort.getMissing());\n}\n```\n只不过这种顺利是建立在之前的不顺利基础上的: org.elasticsearch.search.sort.SortBuilders 没有实现 java.io.Serializable 接口, 各业务线的系统没法通过 dubbo 接口把参数传给我, 所以不得不自定义了上面的 NestedSort 类用于盛装 nested sort filter 的相关参数:\n``` java\npublic class NestedSort implements Serializable {\n    private String sortName; // 排序用的字段名\n    private SortOrder order = SortOrder.ASC;\n    private String missing; // _first/_last,如果指定的字段不存在的排序逻辑\n    private String sortMode; // max/min/sum/avg\n    private String nestedPath;\n    private String termField; // filter对应的 term 的field,现在只支持terms;\n    private Collection<String> termValue;\n}\n```\n好在 nested_filter 相关参数类别可以固化, 比较稳定, 自定义类也算是个解决方案了;\n&nbsp;\n但是另一个小众需求就没那么省事了: aggregations; 之前 2.4.2 的 agg api 中, 有一个通用的方法:\n``` java\npublic SearchRequestBuilder setAggregations(byte[] aggregations) {\n    sourceBuilder().aggregations(aggregations);\n    return this;\n}\n```\nelasticsearch 聚合的 api 比较丰富自由, 而上面方法中的 aggregations 参数是以字节的形式传过来的, 所以业务线可以自由发挥, 不受 es-adapter 的约束, 但可惜这个方法在 6.2.2 版本中取消了;\n这样一来不得不回到束缚之中, 针对不同的聚合类型作各自的处理了; 可惜各个聚合类型依然没有实现 java.io.Serializable 接口, 所以还是得自定义类型去盛装参数了; 比如以下是针对分位数的聚合:\n``` java\npublic class PercentileAggregation implements Serializable {\n    private String aggName;\n    private String aggField;\n    private double[] percents;\n}\n```\n``` java\nPercentilesAggregationBuilder percentileAggBuilder = AggregationBuilders.percentiles(param.getPercentileAggregation().getAggName())\n        .field(param.getPercentileAggregation().getAggField())\n        .percentiles(param.getPercentileAggregation().getPercents());\nsearchSourceBuilder.aggregation(percentileAggBuilder)\n```\n其他的聚合类型不再一一列举; 关于 aggregations 的 api 变化着实比较大, 好在使用它的系统比较少, 推动其修改逻辑阻力亦不是很大;\n&nbsp;\nHighLevelClient 的使用基本上要解决的就是以上几个问题了; 解决了客户端的问题, 就是解决了 \"道\" 的问题, 剩下的 \"术\" 的问题, 都已不是主要矛盾了;\n\n## **语法兼容性问题**\n语法兼容性问题便是上文所提及 \"术\" 的问题的主要表现形式; 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;\n\n### **索引创建的兼容性**\nes 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:\n&nbsp;\n**首先是 settings 中的区别;**\n&nbsp;\n部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;\n``` javascript\n\"settings\":{\n    \"index\":{\n        // creation_date 不能出现在索引创建的定义语句里\n        \"creation_date\": \"1502713848656\",\n        \"number_of_shards\":\"2\",\n        \"analysis\":{\n            \"analyzer\":{\n                \"comma_analyzer\":{\n                    \"type\":\"custom\",\n                    \"tokenizer\":\"comma_tk\"\n                }   \n            },  \n            \"tokenizer\":{\n                \"comma_tk\":{\n                    \"pattern\":\",\",\n                    \"type\":\"pattern\"\n                }   \n            }   \n        },\n        \"number_of_replicas\":\"1\",\n        // uuid 不能出现在索引创建的定义语句里\n        \"uuid\":\"Oa0tz0x-SpSfuC591_ASIQ\",\n        // version.create, version.update 不能出现在索引创建的定义语句里\n        \"version\":{\n            \"created\":\"1070399\",\n            \"upgraded\":\"2040299\"\n        }\n    }\n}\n```\n*这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;*\n&nbsp;\n**然后是 mappings 中的区别;**\n&nbsp;\n**(1) 布尔类型的取值内容规范化**\nelasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:\n``` javascript\n// elasticsearch 2.4.2\n// xxx_idx/_mapping/field/xxx_field\n{\n    \"xxx_idx\":{\n        \"mappings\":{\n            \"xxx_type\":{\n                \"xxx_field\":{\n                    \"full_name\":\"xxx_field\",\n                    \"mapping\":{\n                        \"xxx_field\":{\n                            \"type\":\"string\",\n                            \"index_name\":\"xxx_field\",\n                            // 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义\n                            \"index\":\"not_analyzed\", \n                            \"store\":false,\n                            \"doc_values\":false,\n                            \"term_vector\":\"no\",\n                            \"norms\":{\n                                \"enabled\":false\n                            },\n                            \"null_value\":null,\n                            \"include_in_all\":false\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: `true` 或 `false`;\n*从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 `index` 属性可能会经常用到;*\n\n**(2) _timestamp 字段被废弃**\n*这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;*\n&nbsp;\n况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:\n``` javascript\n\"_timestamp\": {\n    \"enabled\": true\n}\n```\n当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;\n\n**(3) _all 字段被 deprecated, include_in_all 属性被废弃**\n在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;\n之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:\n``` javascript\n\"_all\": {\n    \"enabled\": false\n}\n```\n从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;\n与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;\nelasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 `copy_to` 属性:\n``` javascript\n\"properties\": {\n    \"first_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\" \n    },\n    \"last_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\" \n    },\n    \"full_name\": {\n        \"type\": \"text\"\n    }\n}\n```\n这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;\n&nbsp;\n*无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;*\n\n**(4) 史诗级大改变: string 类型被废弃**\nstring 类型被废弃, 代替者是分词的 `text` 类型和不分词的 `keyword` 类型;\n当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;\n&nbsp;\n*不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;*\n&nbsp;\n经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: [Changelog](https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst);\n仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;\n比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:\n``` javascript\n\"xxx\": {\n    \"type\": \"string\",\n    \"index\": \"not_analyzed\" // 不需要分词, 但要索引\n},\n\"yyy\": {\n    \"type\": \"string\",\n    \"index\": \"no\" // 不需要分词, 也不需要索引\n},\n\"zzz\": {\n    \"type\": \"string\" // 默认情况, 需要索引, 也需要分词\n}\n```\n`index` 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 `not_analyzed`, `analyzed`, `no` 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 `not_analyzed`, `no` 中作出选择; 不得不说这非常混乱;\n要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;\n至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;\n现在逻辑理清楚了, `index` 的取值类型, 也就如上一节所说的, 必须要在 `true` 或 `false` 中选择, 非常清晰;\n\n**(5) mapping 中取消 multi types**\n从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: [Removal of mapping types](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html);\n由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:\n> In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.\n\n&nbsp;\n*这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;*\n\n### **query dsl 的兼容性**\n索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;\n\n**(1) filtered query 被废弃**\n其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;\nfiltered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: \n> Exclude as many document as you can with a filter, then query just the documents that remain.\n\n然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;\n&nbsp;\n*从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:*\n``` javascript\n{\n  // 在 es-adapter 中删除 filtered\n  \"filtered\": {\n    // 如果有 filter, 将其移动到 query -> bool 中\n    \"filter\": { ... },\n    \"query\": {\n      \"bool\": {\n        \"must\": { ... },\n        \"should\": { ... },\n        \"must_not\": { ... }\n      }\n    }\n  }\n}\n```\n\n**(2) filter context 被限定在 bool query 中使用**\n如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:\n``` javascript\n{\n  \"query\": {\n    \"bool\": {\n      // 引入 filter context 作前置过滤\n      \"filter\": { ... },\n      \n      \"must\": { ... },\n      \"should\": { ... },\n      \"must_not\": { ... }\n    }\n  }\n}\n```\n&nbsp;\n*由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;*\n\n**(3) and/or/not query 被废弃**\n与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;\n可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;\n现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;\n但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;\n&nbsp;\n*从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;*\n\n**(4) missing query 被废弃**\n要实现 missing 语义的 query, 现在必须统一使用 must_not exists:\n``` javascript\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must_not\": {\n                \"exists\": {\n                    \"field\": \"xxx\"\n                }\n            }\n        }\n    }\n}\n```\n这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;\n&nbsp;\n*这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;*\n*另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;*\n*所以, 关于 missing , 必须由业务线自己来修改相关代码了;*\n\n### **search api 的兼容性**\n相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;\n\n**(1) search_type `scan` 被废弃**\n关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);\n从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num \\* target_size 数量的结果集大小; 除此之外, 没有其他什么区别;\n&nbsp;\n*然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:*\n``` java\n/* es-adapter 的查询服务 */\npublic ResponseContent query(RequestParam param) {\n    if (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) {\n        return scroll(param);\n    } else if (param.getSearchType().equals(SearchType.COUNT)) {\n        return count(param);\n    } else {\n        return normallyQuery(param);\n    }\n}\n```\n*可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;*\n*这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;*\n\n**(2) search_type `count` 被废弃**\ncount 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:\n``` java\n/**\n * Only counts the results, will still execute aggregations and the like.\n * @deprecated does not any improvements compared to {@link #QUERY_THEN_FETCH} with a `size` of {@code 0}\n */\n@Deprecated\nCOUNT((byte) 5);\n```\n对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;\n&nbsp;\n*可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;*\n\n**(3) search_type `query_and_fetch` 被 deprecated, `dfs_query_and_fetch` 被废弃**\n这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;\n&nbsp;\n*所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;*\n\n## **底层索引数据兼容性问题**\n根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;\n背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;\n\n* 由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;\n但是看了官方文档, 这个想法是不可行的: [Reindex before upgrading](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html ); elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;\n* 其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: [Snapshot And Restore](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html)):\n> A snapshot of an index created in 5.x can be restored to 6.x.\nA snapshot of an index created in 2.x can be restored to 5.x.\nA snapshot of an index created in 1.x can be restored to 2.x.\n\n* 接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: `reindex.remote.whitelist: oldhost:port` 以允许连接远程主机作 reindex;\n以下是 _reindex api 的使用方法:\n``` javascript\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://oldhost:9273\"\n    },\n    \"index\": \"source_idx\",\n    \"type\": \"source_type\",\n    \"query\": {\n      \"match_all\": {}\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest_idx\",\n    \"type\": \"dest_type\"\n  }\n}\n```\n* 除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;\n\n## **工具兼容性问题**\n### **http 访问工具兼容性**\n目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;\n关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: [Strict Content-Type Checking for Elasticsearch REST Requests](https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests);\n现在所有带 body 的请求都必须要加上 `Content-Type` 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;\n&nbsp;\n目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: [yannart/docker-cerebro](https://github.com/yannart/docker-cerebro); 经过部署测试, 完全兼容 elasticsearch 6.2.2;\n不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;\n&nbsp;\n没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;\n首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 `Content-Type`, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;\n然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 `Content-Type` 的时候, 那就指定为 `application/json` 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;\n如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:\n``` bash\nserver {\n   listen 80;\n   server_name esbetae.corp.11bee.com;\n\n   location / {\n      proxy_pass http://l-es5.beta.p1.11bee.com:9273/;\n\n      proxy_set_header X-Real-Scheme $scheme;\n      proxy_set_header Host $host;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      # 统一加上 application/json 的 Content-Type\n      proxy_set_header Content-Type application/json;\n   }\n}\n```\n测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;\n其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;\n\n### **插件兼容性**\n笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;\n**(1) elasticfence**\n这个插件追踪溯源的话是这个项目: [elasticfence](https://github.com/elasticfence/elasticsearch-http-user-auth); 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;\n当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;\n首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;\n当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;\n``` java\n/**\n * A filter allowing to filter rest operations.\n */\npublic abstract class RestFilter implements Closeable {\n    public int order() {return 0;}\n    @Override\n    public void close() {}\n    /**\n     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.\n     */\n    public abstract void process(RestRequest request, RestChannel channel, RestFilterChain filterChain) throws Exception;\n}\n```\n原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;\n经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:\n``` java\n// public interface ActionPlugin\n\n/**\n * Returns a function used to wrap each rest request before handling the request.\n * Note: Only one installed plugin may implement a rest wrapper.\n */\ndefault UnaryOperator<RestHandler> getRestHandlerWrapper(ThreadContext threadContext) {\n    return null;\n}\n```\n让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:\n``` java\n// public class ElasticfencePlugin extends Plugin implements ActionPlugin\n\n@Override\npublic UnaryOperator<RestHandler> getRestHandlerWrapper(ThreadContext threadContext) {\n    if (isPluginDisabled()) {\n        // 透传请求\n        return (originRestHandler) -> authRestFilter.wrapNone(originRestHandler);\n    } else {\n        // 权限控制\n        return (originRestHandler) -> authRestFilter.wrap(originRestHandler);\n    }\n}\n```\n本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;\n换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制...... 要想使用, 就必须申请权限!\n当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;\n然而实际上, 申请权限却不是那么顺利: 我按照官方文档 [Help for plugin authors](https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions) 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;\n&nbsp;\n根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!\n想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;\n不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;\n在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;\n源码中与 java security manager 相关的代码主要有以下几个地方:\n首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):\n``` java\n// org.elasticsearch.bootstrap.Elasticsearch\n\npublic static void main(final String[] args) throws Exception {\n    // we want the JVM to think there is a security manager installed so that if internal policy \n    // decisions that would be based on the presence of a security manager\n    // or lack thereof act as if there is a security manager present (e.g., DNS cache policy)\n    System.setSecurityManager(new SecurityManager() {\n        @Override\n        public void checkPermission(Permission perm) {\n            // grant all permissions so that we can later set the security manager to the one that we want\n        }\n    });\n    LogConfigurator.registerErrorListener();\n    final Elasticsearch elasticsearch = new Elasticsearch();\n    int status = main(args, elasticsearch, Terminal.DEFAULT);\n    if (status != ExitCodes.OK) {\n        exit(status);\n    }\n}\n```\n接着是 Bootstrap 类:\n``` java\n// org.elasticsearch.bootstrap.Bootstrap\n\nprivate void setup(boolean addShutdownHook, Environment environment) throws BootstrapException {\n    ......\n    // install SM after natives, shutdown hooks, etc.\n    try {\n        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));\n    } catch (IOException | NoSuchAlgorithmException e) {\n        throw new BootstrapException(e);\n    }\n    ......\n}\n```\n最后是 BootstrapChecks 类:\n``` java\n// org.elasticsearch.bootstrap.BootstrapChecks\n\n// the list of checks to execute\nstatic List<BootstrapCheck> checks() {\n    final List<BootstrapCheck> checks = new ArrayList<>();\n    ......\n    checks.add(new AllPermissionCheck());\n    return Collections.unmodifiableList(checks);\n}\n\nstatic class AllPermissionCheck implements BootstrapCheck {\n    @Override\n    public final BootstrapCheckResult check(BootstrapContext context) {\n        if (isAllPermissionGranted()) {\n            return BootstrapCheck.BootstrapCheckResult.failure(\"granting the all permission effectively disables security\");\n        }\n        return BootstrapCheckResult.success();\n    }\n    boolean isAllPermissionGranted() {\n        final SecurityManager sm = System.getSecurityManager();\n        assert sm != null;\n        try {\n            sm.checkPermission(new AllPermission());\n        } catch (final SecurityException e) {\n            return false;\n        }\n        return true;\n    }\n}\n```\n与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;\n重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动; 尽管这个问题暂时解决了, 但总是 \"不太光彩\"; 如果有人知道如何通过常规方法解决 security manager 的问题, 还请不吝赐教;\n\n**(2) elasticsearch-analysis-ik** \n这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, [medcl](https://github.com/medcl) 一定会在新版本发布第一时间更新 [elasticsearch-analysis-ik](https://github.com/medcl/elasticsearch-analysis-ik), 与公司共进退;\n安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;\n\n**(3) 其余插件**\n在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;\n\n## **监控体系**\n### **基于 rest api + graphite + grafana 的方案**\n基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们监控 elasticsearch 集群健康状况的主力工具 (这篇文章详细介绍了 elasticsearch 各种 rest api 收集到的指标以及将其可视化的方法: [使用 rest api 可视化监控 elasticsearch 集群]());\n将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现 rest api 有了一些变化;\n首先是 rest api 调用的参数的细微变化:\n``` bash\n# 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数\n_nodes/stats?all=true\n_stats?all=true\n```\nall 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;\n其余的 api 在调用的路径和参数上都没有什么变化, 比较顺利;\n然后是调用 api 返回的内容有一些细微的变化:\n``` bash\n# 2.4.2 的 load 指标\n$node_name.os.load_avergae\n# 6.2.2 的 load 指标\n$node_name.os.cpu.load_average.1m\n$node_name.os.cpu.load_average.5m\n$node_name.os.cpu.load_average.15m\n```\n6.2.2 的机器 load 指标收集, 随系统细分为了 1min, 5min 和 15min 三种, 也算是更精致了;\n\n### **elastic 官方组件 x-pack**\n在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;\n从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:\n![x-pack-fee-table](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png)\n对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;\n我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;\n可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:\n![x-pack-monitor](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png)\n另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:\n![x-pack-search-profiler](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png)\n除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;\n以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;\n\n## **本文总结**\n本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级到 6.2.2 的可行性与兼容性问题;\n**首先是客户端兼容性问题:**\nelastic 公司新推出的 `RestHighLevelClient` 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 `RestHighLevelClient` 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利; 对各业务线而言, 只有有限的 (诸如 aggregations) api 被迫需要修改, 其余的都可以延续下去;\n**其次是语法兼容性问题:**\n此处仍需细分为三个方面: **create index**, **query dsl** 和 **search api** ;\n**create index** 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 `string` 类型, 改而细分出两个司职更明确的类型: `text` 与 `keyword`, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;\n**query dsl** 方面, 对我们的影响也在控制范围之内: 只有 `missing` 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;\n**search api** 方面, 可能影响就比较大了: `scan` 和 `count` 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;\n**然后是索引数据迁移兼容性问题:**\n经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;\n**接着是工具兼容性问题:**\n经过不断探索与变通, 最后 `cerebro`, `elasticsearch-head`, `elasticfence`, `elasticsearch-analysis-ik`, `curator` 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 \"顺利\" 实现了对 6.2.2 版本的兼容;\n这其中, `elasticfence` 实现兼容的过程比较坎坷, 甚至还重新编译了 elasticsearch 的源码才解决了 security manager 的问题; 如果以后能通过常规方式解决安全的问题, 一定还得弄回去;\n**最后是监控体系兼容性问题:**\n得益于 6.x 版本 rest api 对先前的延续 (除了极个别 api 有细微调整之外), 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;\n另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;\n\n&nbsp;\n**以上便是本文的全部内容;**\n\n## **站内相关文章**\n- [apache httpclient 初始化参数设置总结]()\n- [使用 rest api 可视化监控 elasticsearch 集群]()\n\n## **参考链接**\n- [Changelog](https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst)\n- [Removal of mapping types](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html)\n- [Strict Content-Type Checking for Elasticsearch REST Requests](https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests)\n- [Compatibility](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html)\n- [State of the official Elasticsearch Java clients](https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients)\n- [Elasticsearch 6 新特性与重要变更解读](http://blog.csdn.net/napoay/article/details/79135136)\n- [Help for plugin authors](https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions)\n- [Intellij Idea 编译 Elasticsearch 源码](https://elasticsearch.cn/article/338)\n- [elasticsearch: Building from Source](https://github.com/elastic/elasticsearch#building-from-source)\n- [Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You](https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0)\n- [Kibana+X-Pack](https://www.cnblogs.com/Leo_wl/p/6181563.html)\n- [Subscriptions that Go to Work for You](https://www.elastic.co/subscriptions)\n\n","source":"_posts/elasticsearch--elasticsearch6.x升级调研报告.md","raw":"---\ntitle: elasticsearch 6.x 升级调研报告\ndate: 2018-03-24 22:11:48\ncategories:\n - elasticsearch\ntags:\n - elasticsearch\n - httpcomponents\n---\n\n> 关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;\n在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;\n希望能给各位读者带来工作上的帮助!\n\n<!--more-->\n\n------\n\n**万字长文, 高能预警! 如只希望了解最终结论, 请点击:** *[本文总结](#本文总结);*\n&nbsp;\n戊戌年春, 历时余月, 本文终于迎来了收尾;\n这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: [ES consume high cpu with threadlocal](https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402); 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文即是该升级调研的一个总结报告;\n相比于公司内部发表的版本, 本篇博客对所有涉及公司内部的信息作了脱敏处理, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;\n\n## **客户端兼容性问题**\n在这篇文章的编排结构中, 我将客户端兼容性问题摆在了第一的位置: 因为不管 rest api 如何变化, 或者如何不变, 都只能算是 \"术\"; 我们真正跑在生产环境中的系统, 使用的是 elasticsearch java client; client 端的基础兼容性问题才是根本之 \"道\";\n\n### **巨轮转向的前提: es-adapter**\n我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;\n如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 \"无效\" 工作量, 他们一定不会积极配合, 我们将无法推动进展;\n还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优; 其余的系统必须通过调用其暴露出去的 dubbo 接口间接访问 elasticsearch; 这个系统被命名为 es-adapter;\n当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: [apache httpclient 初始化参数设置总结](); 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;\n有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;\n不得不说, 当系统规模与复杂度发展到了一个 \"船大难掉头\" 的程度时, es-adapter 就像是《三体》中描述的 \"水滴\" 一样, 带领整个体系从一个更高的维度完成 \"平滑\" 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: [search api 的兼容性](#search-api-的兼容性);\n\n### **升级过渡期 client 端的技术选型**\n关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:\n> We plan on deprecating the `TransportClient` in Elasticsearch 7.0 and removing it completely in 8.0.\n\n所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;\n值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;\n要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:\n``` xml\n<!-- elasticsearch core -->\n<dependency>\n    <groupId>org.elasticsearch</groupId>\n    <artifactId>elasticsearch</artifactId>\n    <version>6.2.2</version>\n</dependency>\n<!-- low level rest client -->\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-client</artifactId>\n    <version>6.2.2</version>\n</dependency>\n<!-- high level rest client -->\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n    <version>6.2.2</version>\n</dependency>\n```\n后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;\n之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: [searchbox-io/Jest](https://github.com/searchbox-io/Jest)), 基本囊括了 elasticsearch 各种类别的请求功能;\n但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score, aggregations 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;\n这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;\n我们经过 demo 快速测试验证, 初步得出了结论:\n&nbsp;\n**6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;**\n&nbsp;\n这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: [Compatibility](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html);\n所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;\n\n### **HighLevelClient 的使用注意事项**\n**(1) 初始化的重要选项**\nHighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:\n\n1. `CONNECTION_REQUEST_TIMEOUT`\n2. `CONNECT_TIMEOUT`\n3. `SOCKET_TIMEOUT`\n4. `MAX_CONN_TOTAL`\n5. `MAX_CONN_PER_ROUTE`\n\n不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:\n``` java\nList<HttpHost> httpHosts = Lists.newArrayListWithExpectedSize(serverNum);\nserverAddressList.forEach((server) -> httpHosts.add(new HttpHost(server.getAddr(), server.getPort(), \"http\")));\nprivate RestHighLevelClient highLevelClient = new RestHighLevelClient(\n        RestClient.builder(httpHosts.toArray(new HttpHost[0]))\n        // timeout settings\n        .setRequestConfigCallback((callback) -> callback\n                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)\n                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)\n                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))\n        // connections total and connections per host\n        .setHttpClientConfigCallback((callback) -> callback\n                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)\n                .setMaxConnTotal(MAX_CONN_TOTAL)\n        )\n);\n```\n\n**(2) request timeout 的设置**\n对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;\n这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;\n那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;\n首先需要定义一个 response 容器来盛装异步回调里拿到的 result:\n``` java\nclass ResponseWrapper<T> {\n    private T response;\n    private Exception exception;\n    public T getResponse() { return response; }\n    public void setResponse(T response) { this.response = response; }\n    public Exception getException() { return exception; }\n    public void setException(Exception exception) { this.exception = exception;}\n}\n```\n下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:\n``` java\n/* get request with timeout */\nfinal ResponseWrapper<GetResponse> wrapper = new ResponseWrapper<>();\nfinal CountDownLatch latch = new CountDownLatch(1);\nhighLevelClient.getAsync(request, new ActionListener<GetResponse>() {\n    @Override\n    public void onResponse(GetResponse documentFields) {\n        wrapper.setResponse(documentFields);\n        latch.countDown();\n    }\n    @Override\n    public void onFailure(Exception e) {\n        wrapper.setException(e);\n        wrapper.setResponse(null);\n        latch.countDown();\n    }\n});\ntry {\n    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);\n} catch (InterruptedException e) {\n    throw new ElasticsearchTimeoutException(\"timeout\");\n}\nif (wrapper.getResponse() == null) { // 异常处理 } \nelse { 处理 wrapper.getResponse() 的返回结果 }\n```\n\n**(3) query 请求 dsl 的传参问题**\nes-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:\n``` javascript\n{\n    \"query\": { ... },\n    \"_source\": {\n        \"include\": [ ... ],\n        \"exclude\": [ ... ]\n    },\n    \"from\": xxx,\n    \"size\": yyy,\n    \"sort\": [ ... ],\n    \"aggs\": { ... }\n}\n```\n业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象; \n这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;\n权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:\n``` java\nString dslStr = \"...\";\nSearchModule searchModule = new SearchModule(Settings.EMPTY, false, Collections.emptyList());\nXContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(\n        new NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);\n\nSearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);\n```\n\n**(4) 无厘头的 `adjust_pure_negative`**\n整个 HighLevelClient 中, 最让人感到费解的一个东西就是一个神秘的属性:\n``` java\n/* org.elasticsearch.index.query.BoolQueryBuilder */\nprivate static final ParseField ADJUST_PURE_NEGATIVE = new ParseField(\"adjust_pure_negative\");\nprivate boolean adjustPureNegative = ADJUST_PURE_NEGATIVE_DEFAULT;\n```\n先是看官方文档, 搜不到;\n然后搜 google, 就找到这么一个稍微相关一点的帖子: [What does \"adjust_pure_negative\" flag do?](https://discuss.elastic.co/t/what-does-adjust-pure-negative-flag-do/92348), 而其给出的唯一回复是 \"**You can ignore it**\";\n实在搜不到有效的信息, 我只好去扒源码; 然而, 除了如上所述的 BoolQueryBuilder 中的这坨, 再加上一些测试类, 就再也没在其他地方看到与 `adjust_pure_negative` 相关的逻辑了;\n也许真的如 elastic 讨论组中所说的 *You can ignore it?* 但是现在有一个问题让我无法忽略它: 这个属性无法被 2.4.2 的 elasticsearch 识别, 但在 6.2.2 的 elasticsearch 中, 各个 QueryBuilder 的 toString() 方法会自动将其带上:\n``` javascript\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": { ... },\n      \"should\": { ... },\n      \"must_not\": { ... },\n      \"adjust_pure_negative\": true,\n      \"boost\": 1.0\n    }\n  }\n}\n```\n在上一节中提到, es-adapter 接受业务线传来的 query dsl str, 使用 6.2.2 的 elasticsearch 便会将上述语句传给 es-adapter; 如果其访问的索引已经迁移到 6.2.2 新集群, 那么该语句没问题; 但如果其访问的索引还未来得及迁移到新集群, es-adapter 会将该请求路由到旧的 2.4.2 集群, 接着便会发生语法解析异常;\n&nbsp;\n*这意味着, 在某个系统所需要访问的所有索引迁移到 6.2.2 新集群之前, 其 maven 依赖的 elasticsearch 版本, 不能提前升级到 6.2.2, 以阻止 adjust_pure_negative 的生成;*\n*当然考虑到 major 版本升级所带来的语法规则的巨变已被 es-adapter 缓冲掉了绝大部分, 我相信各业务线也不希望把 elasticsearch 的 maven 版本给直接升上去的; 毕竟那意味着代码将红成一大片, 要花费大量的精力修改代码, 这等于把 es-adapter 原本要替其做的事, 提前自己给办了;*\n\n**(5) 其他小众的需求**\n以上展示的是业务线普遍会遇到的情况, 然后还有两个比较小众的需求, 在个别系统中会使用到,  也是上面所提到的 nested_filter 和 aggregations;\n关于 nested_filter 还稍顺利些, api 有一些变化但是新的 api 有新的解决方案:\n``` java\n// 6.2.2 版本: 构造一个 携带 nested_filter 的 sort\nprivate SortBuilder buildNestedSort(NestedSort nestedSort) {\n    QueryBuilder termFilter = QueryBuilders.termsQuery(nestedSort.getTermField(), nestedSort.getTermValue());\n    return SortBuilders.fieldSort(nestedSort.getSortName())\n            .setNestedSort(new NestedSortBuilder(nestedSort.getNestedPath()).setFilter(termFilter))\n            .order(nestedSort.getOrder())\n            .sortMode(SortMode.fromString(nestedSort.getSortMode()))\n            .missing(nestedSort.getMissing());\n}\n```\n只不过这种顺利是建立在之前的不顺利基础上的: org.elasticsearch.search.sort.SortBuilders 没有实现 java.io.Serializable 接口, 各业务线的系统没法通过 dubbo 接口把参数传给我, 所以不得不自定义了上面的 NestedSort 类用于盛装 nested sort filter 的相关参数:\n``` java\npublic class NestedSort implements Serializable {\n    private String sortName; // 排序用的字段名\n    private SortOrder order = SortOrder.ASC;\n    private String missing; // _first/_last,如果指定的字段不存在的排序逻辑\n    private String sortMode; // max/min/sum/avg\n    private String nestedPath;\n    private String termField; // filter对应的 term 的field,现在只支持terms;\n    private Collection<String> termValue;\n}\n```\n好在 nested_filter 相关参数类别可以固化, 比较稳定, 自定义类也算是个解决方案了;\n&nbsp;\n但是另一个小众需求就没那么省事了: aggregations; 之前 2.4.2 的 agg api 中, 有一个通用的方法:\n``` java\npublic SearchRequestBuilder setAggregations(byte[] aggregations) {\n    sourceBuilder().aggregations(aggregations);\n    return this;\n}\n```\nelasticsearch 聚合的 api 比较丰富自由, 而上面方法中的 aggregations 参数是以字节的形式传过来的, 所以业务线可以自由发挥, 不受 es-adapter 的约束, 但可惜这个方法在 6.2.2 版本中取消了;\n这样一来不得不回到束缚之中, 针对不同的聚合类型作各自的处理了; 可惜各个聚合类型依然没有实现 java.io.Serializable 接口, 所以还是得自定义类型去盛装参数了; 比如以下是针对分位数的聚合:\n``` java\npublic class PercentileAggregation implements Serializable {\n    private String aggName;\n    private String aggField;\n    private double[] percents;\n}\n```\n``` java\nPercentilesAggregationBuilder percentileAggBuilder = AggregationBuilders.percentiles(param.getPercentileAggregation().getAggName())\n        .field(param.getPercentileAggregation().getAggField())\n        .percentiles(param.getPercentileAggregation().getPercents());\nsearchSourceBuilder.aggregation(percentileAggBuilder)\n```\n其他的聚合类型不再一一列举; 关于 aggregations 的 api 变化着实比较大, 好在使用它的系统比较少, 推动其修改逻辑阻力亦不是很大;\n&nbsp;\nHighLevelClient 的使用基本上要解决的就是以上几个问题了; 解决了客户端的问题, 就是解决了 \"道\" 的问题, 剩下的 \"术\" 的问题, 都已不是主要矛盾了;\n\n## **语法兼容性问题**\n语法兼容性问题便是上文所提及 \"术\" 的问题的主要表现形式; 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;\n\n### **索引创建的兼容性**\nes 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:\n&nbsp;\n**首先是 settings 中的区别;**\n&nbsp;\n部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;\n``` javascript\n\"settings\":{\n    \"index\":{\n        // creation_date 不能出现在索引创建的定义语句里\n        \"creation_date\": \"1502713848656\",\n        \"number_of_shards\":\"2\",\n        \"analysis\":{\n            \"analyzer\":{\n                \"comma_analyzer\":{\n                    \"type\":\"custom\",\n                    \"tokenizer\":\"comma_tk\"\n                }   \n            },  \n            \"tokenizer\":{\n                \"comma_tk\":{\n                    \"pattern\":\",\",\n                    \"type\":\"pattern\"\n                }   \n            }   \n        },\n        \"number_of_replicas\":\"1\",\n        // uuid 不能出现在索引创建的定义语句里\n        \"uuid\":\"Oa0tz0x-SpSfuC591_ASIQ\",\n        // version.create, version.update 不能出现在索引创建的定义语句里\n        \"version\":{\n            \"created\":\"1070399\",\n            \"upgraded\":\"2040299\"\n        }\n    }\n}\n```\n*这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;*\n&nbsp;\n**然后是 mappings 中的区别;**\n&nbsp;\n**(1) 布尔类型的取值内容规范化**\nelasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:\n``` javascript\n// elasticsearch 2.4.2\n// xxx_idx/_mapping/field/xxx_field\n{\n    \"xxx_idx\":{\n        \"mappings\":{\n            \"xxx_type\":{\n                \"xxx_field\":{\n                    \"full_name\":\"xxx_field\",\n                    \"mapping\":{\n                        \"xxx_field\":{\n                            \"type\":\"string\",\n                            \"index_name\":\"xxx_field\",\n                            // 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义\n                            \"index\":\"not_analyzed\", \n                            \"store\":false,\n                            \"doc_values\":false,\n                            \"term_vector\":\"no\",\n                            \"norms\":{\n                                \"enabled\":false\n                            },\n                            \"null_value\":null,\n                            \"include_in_all\":false\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: `true` 或 `false`;\n*从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 `index` 属性可能会经常用到;*\n\n**(2) _timestamp 字段被废弃**\n*这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;*\n&nbsp;\n况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:\n``` javascript\n\"_timestamp\": {\n    \"enabled\": true\n}\n```\n当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;\n\n**(3) _all 字段被 deprecated, include_in_all 属性被废弃**\n在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;\n之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:\n``` javascript\n\"_all\": {\n    \"enabled\": false\n}\n```\n从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;\n与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;\nelasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 `copy_to` 属性:\n``` javascript\n\"properties\": {\n    \"first_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\" \n    },\n    \"last_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\" \n    },\n    \"full_name\": {\n        \"type\": \"text\"\n    }\n}\n```\n这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;\n&nbsp;\n*无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;*\n\n**(4) 史诗级大改变: string 类型被废弃**\nstring 类型被废弃, 代替者是分词的 `text` 类型和不分词的 `keyword` 类型;\n当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;\n&nbsp;\n*不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;*\n&nbsp;\n经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: [Changelog](https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst);\n仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;\n比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:\n``` javascript\n\"xxx\": {\n    \"type\": \"string\",\n    \"index\": \"not_analyzed\" // 不需要分词, 但要索引\n},\n\"yyy\": {\n    \"type\": \"string\",\n    \"index\": \"no\" // 不需要分词, 也不需要索引\n},\n\"zzz\": {\n    \"type\": \"string\" // 默认情况, 需要索引, 也需要分词\n}\n```\n`index` 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 `not_analyzed`, `analyzed`, `no` 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 `not_analyzed`, `no` 中作出选择; 不得不说这非常混乱;\n要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;\n至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;\n现在逻辑理清楚了, `index` 的取值类型, 也就如上一节所说的, 必须要在 `true` 或 `false` 中选择, 非常清晰;\n\n**(5) mapping 中取消 multi types**\n从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: [Removal of mapping types](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html);\n由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:\n> In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.\n\n&nbsp;\n*这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;*\n\n### **query dsl 的兼容性**\n索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;\n\n**(1) filtered query 被废弃**\n其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;\nfiltered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: \n> Exclude as many document as you can with a filter, then query just the documents that remain.\n\n然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;\n&nbsp;\n*从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:*\n``` javascript\n{\n  // 在 es-adapter 中删除 filtered\n  \"filtered\": {\n    // 如果有 filter, 将其移动到 query -> bool 中\n    \"filter\": { ... },\n    \"query\": {\n      \"bool\": {\n        \"must\": { ... },\n        \"should\": { ... },\n        \"must_not\": { ... }\n      }\n    }\n  }\n}\n```\n\n**(2) filter context 被限定在 bool query 中使用**\n如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:\n``` javascript\n{\n  \"query\": {\n    \"bool\": {\n      // 引入 filter context 作前置过滤\n      \"filter\": { ... },\n      \n      \"must\": { ... },\n      \"should\": { ... },\n      \"must_not\": { ... }\n    }\n  }\n}\n```\n&nbsp;\n*由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;*\n\n**(3) and/or/not query 被废弃**\n与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;\n可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;\n现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;\n但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;\n&nbsp;\n*从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;*\n\n**(4) missing query 被废弃**\n要实现 missing 语义的 query, 现在必须统一使用 must_not exists:\n``` javascript\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must_not\": {\n                \"exists\": {\n                    \"field\": \"xxx\"\n                }\n            }\n        }\n    }\n}\n```\n这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;\n&nbsp;\n*这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;*\n*另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;*\n*所以, 关于 missing , 必须由业务线自己来修改相关代码了;*\n\n### **search api 的兼容性**\n相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;\n\n**(1) search_type `scan` 被废弃**\n关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);\n从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num \\* target_size 数量的结果集大小; 除此之外, 没有其他什么区别;\n&nbsp;\n*然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:*\n``` java\n/* es-adapter 的查询服务 */\npublic ResponseContent query(RequestParam param) {\n    if (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) {\n        return scroll(param);\n    } else if (param.getSearchType().equals(SearchType.COUNT)) {\n        return count(param);\n    } else {\n        return normallyQuery(param);\n    }\n}\n```\n*可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;*\n*这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;*\n\n**(2) search_type `count` 被废弃**\ncount 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:\n``` java\n/**\n * Only counts the results, will still execute aggregations and the like.\n * @deprecated does not any improvements compared to {@link #QUERY_THEN_FETCH} with a `size` of {@code 0}\n */\n@Deprecated\nCOUNT((byte) 5);\n```\n对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;\n&nbsp;\n*可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;*\n\n**(3) search_type `query_and_fetch` 被 deprecated, `dfs_query_and_fetch` 被废弃**\n这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;\n&nbsp;\n*所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;*\n\n## **底层索引数据兼容性问题**\n根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;\n背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;\n\n* 由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;\n但是看了官方文档, 这个想法是不可行的: [Reindex before upgrading](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html ); elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;\n* 其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: [Snapshot And Restore](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html)):\n> A snapshot of an index created in 5.x can be restored to 6.x.\nA snapshot of an index created in 2.x can be restored to 5.x.\nA snapshot of an index created in 1.x can be restored to 2.x.\n\n* 接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: `reindex.remote.whitelist: oldhost:port` 以允许连接远程主机作 reindex;\n以下是 _reindex api 的使用方法:\n``` javascript\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://oldhost:9273\"\n    },\n    \"index\": \"source_idx\",\n    \"type\": \"source_type\",\n    \"query\": {\n      \"match_all\": {}\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest_idx\",\n    \"type\": \"dest_type\"\n  }\n}\n```\n* 除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;\n\n## **工具兼容性问题**\n### **http 访问工具兼容性**\n目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;\n关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: [Strict Content-Type Checking for Elasticsearch REST Requests](https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests);\n现在所有带 body 的请求都必须要加上 `Content-Type` 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;\n&nbsp;\n目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: [yannart/docker-cerebro](https://github.com/yannart/docker-cerebro); 经过部署测试, 完全兼容 elasticsearch 6.2.2;\n不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;\n&nbsp;\n没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;\n首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 `Content-Type`, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;\n然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 `Content-Type` 的时候, 那就指定为 `application/json` 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;\n如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:\n``` bash\nserver {\n   listen 80;\n   server_name esbetae.corp.11bee.com;\n\n   location / {\n      proxy_pass http://l-es5.beta.p1.11bee.com:9273/;\n\n      proxy_set_header X-Real-Scheme $scheme;\n      proxy_set_header Host $host;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      # 统一加上 application/json 的 Content-Type\n      proxy_set_header Content-Type application/json;\n   }\n}\n```\n测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;\n其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;\n\n### **插件兼容性**\n笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;\n**(1) elasticfence**\n这个插件追踪溯源的话是这个项目: [elasticfence](https://github.com/elasticfence/elasticsearch-http-user-auth); 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;\n当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;\n首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;\n当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;\n``` java\n/**\n * A filter allowing to filter rest operations.\n */\npublic abstract class RestFilter implements Closeable {\n    public int order() {return 0;}\n    @Override\n    public void close() {}\n    /**\n     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.\n     */\n    public abstract void process(RestRequest request, RestChannel channel, RestFilterChain filterChain) throws Exception;\n}\n```\n原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;\n经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:\n``` java\n// public interface ActionPlugin\n\n/**\n * Returns a function used to wrap each rest request before handling the request.\n * Note: Only one installed plugin may implement a rest wrapper.\n */\ndefault UnaryOperator<RestHandler> getRestHandlerWrapper(ThreadContext threadContext) {\n    return null;\n}\n```\n让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:\n``` java\n// public class ElasticfencePlugin extends Plugin implements ActionPlugin\n\n@Override\npublic UnaryOperator<RestHandler> getRestHandlerWrapper(ThreadContext threadContext) {\n    if (isPluginDisabled()) {\n        // 透传请求\n        return (originRestHandler) -> authRestFilter.wrapNone(originRestHandler);\n    } else {\n        // 权限控制\n        return (originRestHandler) -> authRestFilter.wrap(originRestHandler);\n    }\n}\n```\n本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;\n换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制...... 要想使用, 就必须申请权限!\n当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;\n然而实际上, 申请权限却不是那么顺利: 我按照官方文档 [Help for plugin authors](https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions) 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;\n&nbsp;\n根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!\n想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;\n不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;\n在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;\n源码中与 java security manager 相关的代码主要有以下几个地方:\n首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):\n``` java\n// org.elasticsearch.bootstrap.Elasticsearch\n\npublic static void main(final String[] args) throws Exception {\n    // we want the JVM to think there is a security manager installed so that if internal policy \n    // decisions that would be based on the presence of a security manager\n    // or lack thereof act as if there is a security manager present (e.g., DNS cache policy)\n    System.setSecurityManager(new SecurityManager() {\n        @Override\n        public void checkPermission(Permission perm) {\n            // grant all permissions so that we can later set the security manager to the one that we want\n        }\n    });\n    LogConfigurator.registerErrorListener();\n    final Elasticsearch elasticsearch = new Elasticsearch();\n    int status = main(args, elasticsearch, Terminal.DEFAULT);\n    if (status != ExitCodes.OK) {\n        exit(status);\n    }\n}\n```\n接着是 Bootstrap 类:\n``` java\n// org.elasticsearch.bootstrap.Bootstrap\n\nprivate void setup(boolean addShutdownHook, Environment environment) throws BootstrapException {\n    ......\n    // install SM after natives, shutdown hooks, etc.\n    try {\n        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));\n    } catch (IOException | NoSuchAlgorithmException e) {\n        throw new BootstrapException(e);\n    }\n    ......\n}\n```\n最后是 BootstrapChecks 类:\n``` java\n// org.elasticsearch.bootstrap.BootstrapChecks\n\n// the list of checks to execute\nstatic List<BootstrapCheck> checks() {\n    final List<BootstrapCheck> checks = new ArrayList<>();\n    ......\n    checks.add(new AllPermissionCheck());\n    return Collections.unmodifiableList(checks);\n}\n\nstatic class AllPermissionCheck implements BootstrapCheck {\n    @Override\n    public final BootstrapCheckResult check(BootstrapContext context) {\n        if (isAllPermissionGranted()) {\n            return BootstrapCheck.BootstrapCheckResult.failure(\"granting the all permission effectively disables security\");\n        }\n        return BootstrapCheckResult.success();\n    }\n    boolean isAllPermissionGranted() {\n        final SecurityManager sm = System.getSecurityManager();\n        assert sm != null;\n        try {\n            sm.checkPermission(new AllPermission());\n        } catch (final SecurityException e) {\n            return false;\n        }\n        return true;\n    }\n}\n```\n与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;\n重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动; 尽管这个问题暂时解决了, 但总是 \"不太光彩\"; 如果有人知道如何通过常规方法解决 security manager 的问题, 还请不吝赐教;\n\n**(2) elasticsearch-analysis-ik** \n这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, [medcl](https://github.com/medcl) 一定会在新版本发布第一时间更新 [elasticsearch-analysis-ik](https://github.com/medcl/elasticsearch-analysis-ik), 与公司共进退;\n安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;\n\n**(3) 其余插件**\n在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;\n\n## **监控体系**\n### **基于 rest api + graphite + grafana 的方案**\n基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们监控 elasticsearch 集群健康状况的主力工具 (这篇文章详细介绍了 elasticsearch 各种 rest api 收集到的指标以及将其可视化的方法: [使用 rest api 可视化监控 elasticsearch 集群]());\n将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现 rest api 有了一些变化;\n首先是 rest api 调用的参数的细微变化:\n``` bash\n# 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数\n_nodes/stats?all=true\n_stats?all=true\n```\nall 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;\n其余的 api 在调用的路径和参数上都没有什么变化, 比较顺利;\n然后是调用 api 返回的内容有一些细微的变化:\n``` bash\n# 2.4.2 的 load 指标\n$node_name.os.load_avergae\n# 6.2.2 的 load 指标\n$node_name.os.cpu.load_average.1m\n$node_name.os.cpu.load_average.5m\n$node_name.os.cpu.load_average.15m\n```\n6.2.2 的机器 load 指标收集, 随系统细分为了 1min, 5min 和 15min 三种, 也算是更精致了;\n\n### **elastic 官方组件 x-pack**\n在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;\n从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:\n![x-pack-fee-table](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png)\n对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;\n我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;\n可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:\n![x-pack-monitor](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png)\n另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:\n![x-pack-search-profiler](https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png)\n除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;\n以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;\n\n## **本文总结**\n本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级到 6.2.2 的可行性与兼容性问题;\n**首先是客户端兼容性问题:**\nelastic 公司新推出的 `RestHighLevelClient` 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 `RestHighLevelClient` 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利; 对各业务线而言, 只有有限的 (诸如 aggregations) api 被迫需要修改, 其余的都可以延续下去;\n**其次是语法兼容性问题:**\n此处仍需细分为三个方面: **create index**, **query dsl** 和 **search api** ;\n**create index** 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 `string` 类型, 改而细分出两个司职更明确的类型: `text` 与 `keyword`, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;\n**query dsl** 方面, 对我们的影响也在控制范围之内: 只有 `missing` 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;\n**search api** 方面, 可能影响就比较大了: `scan` 和 `count` 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;\n**然后是索引数据迁移兼容性问题:**\n经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;\n**接着是工具兼容性问题:**\n经过不断探索与变通, 最后 `cerebro`, `elasticsearch-head`, `elasticfence`, `elasticsearch-analysis-ik`, `curator` 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 \"顺利\" 实现了对 6.2.2 版本的兼容;\n这其中, `elasticfence` 实现兼容的过程比较坎坷, 甚至还重新编译了 elasticsearch 的源码才解决了 security manager 的问题; 如果以后能通过常规方式解决安全的问题, 一定还得弄回去;\n**最后是监控体系兼容性问题:**\n得益于 6.x 版本 rest api 对先前的延续 (除了极个别 api 有细微调整之外), 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;\n另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;\n\n&nbsp;\n**以上便是本文的全部内容;**\n\n## **站内相关文章**\n- [apache httpclient 初始化参数设置总结]()\n- [使用 rest api 可视化监控 elasticsearch 集群]()\n\n## **参考链接**\n- [Changelog](https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst)\n- [Removal of mapping types](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html)\n- [Strict Content-Type Checking for Elasticsearch REST Requests](https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests)\n- [Compatibility](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html)\n- [State of the official Elasticsearch Java clients](https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients)\n- [Elasticsearch 6 新特性与重要变更解读](http://blog.csdn.net/napoay/article/details/79135136)\n- [Help for plugin authors](https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions)\n- [Intellij Idea 编译 Elasticsearch 源码](https://elasticsearch.cn/article/338)\n- [elasticsearch: Building from Source](https://github.com/elastic/elasticsearch#building-from-source)\n- [Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You](https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0)\n- [Kibana+X-Pack](https://www.cnblogs.com/Leo_wl/p/6181563.html)\n- [Subscriptions that Go to Work for You](https://www.elastic.co/subscriptions)\n\n","slug":"elasticsearch--elasticsearch6.x升级调研报告","published":1,"updated":"2018-04-07T10:01:40.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5h0007j1jxjn2mzt4d","content":"<blockquote>\n<p>关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;<br>在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;<br>希望能给各位读者带来工作上的帮助!</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p><strong>万字长文, 高能预警! 如只希望了解最终结论, 请点击:</strong> <em><a href=\"#本文总结\">本文总结</a>;</em><br>&nbsp;<br>戊戌年春, 历时余月, 本文终于迎来了收尾;<br>这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: <a href=\"https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402\" target=\"_blank\" rel=\"noopener\">ES consume high cpu with threadlocal</a>; 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文即是该升级调研的一个总结报告;<br>相比于公司内部发表的版本, 本篇博客对所有涉及公司内部的信息作了脱敏处理, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;</p>\n<h2 id=\"客户端兼容性问题\"><a href=\"#客户端兼容性问题\" class=\"headerlink\" title=\"客户端兼容性问题\"></a><strong>客户端兼容性问题</strong></h2><p>在这篇文章的编排结构中, 我将客户端兼容性问题摆在了第一的位置: 因为不管 rest api 如何变化, 或者如何不变, 都只能算是 “术”; 我们真正跑在生产环境中的系统, 使用的是 elasticsearch java client; client 端的基础兼容性问题才是根本之 “道”;</p>\n<h3 id=\"巨轮转向的前提-es-adapter\"><a href=\"#巨轮转向的前提-es-adapter\" class=\"headerlink\" title=\"巨轮转向的前提: es-adapter\"></a><strong>巨轮转向的前提: es-adapter</strong></h3><p>我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;<br>如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 “无效” 工作量, 他们一定不会积极配合, 我们将无法推动进展;<br>还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优; 其余的系统必须通过调用其暴露出去的 dubbo 接口间接访问 elasticsearch; 这个系统被命名为 es-adapter;<br>当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: <a href=\"\">apache httpclient 初始化参数设置总结</a>; 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;<br>有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;<br>不得不说, 当系统规模与复杂度发展到了一个 “船大难掉头” 的程度时, es-adapter 就像是《三体》中描述的 “水滴” 一样, 带领整个体系从一个更高的维度完成 “平滑” 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: <a href=\"#search-api-的兼容性\">search api 的兼容性</a>;</p>\n<h3 id=\"升级过渡期-client-端的技术选型\"><a href=\"#升级过渡期-client-端的技术选型\" class=\"headerlink\" title=\"升级过渡期 client 端的技术选型\"></a><strong>升级过渡期 client 端的技术选型</strong></h3><p>关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:</p>\n<blockquote>\n<p>We plan on deprecating the <code>TransportClient</code> in Elasticsearch 7.0 and removing it completely in 8.0.</p>\n</blockquote>\n<p>所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;<br>值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;<br>要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- elasticsearch core --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- low level rest client --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch-rest-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- high level rest client --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;<br>之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: <a href=\"https://github.com/searchbox-io/Jest\" target=\"_blank\" rel=\"noopener\">searchbox-io/Jest</a>), 基本囊括了 elasticsearch 各种类别的请求功能;<br>但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score, aggregations 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;<br>这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;<br>我们经过 demo 快速测试验证, 初步得出了结论:<br>&nbsp;<br><strong>6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;</strong><br>&nbsp;<br>这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html\" target=\"_blank\" rel=\"noopener\">Compatibility</a>;<br>所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;</p>\n<h3 id=\"HighLevelClient-的使用注意事项\"><a href=\"#HighLevelClient-的使用注意事项\" class=\"headerlink\" title=\"HighLevelClient 的使用注意事项\"></a><strong>HighLevelClient 的使用注意事项</strong></h3><p><strong>(1) 初始化的重要选项</strong><br>HighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:</p>\n<ol>\n<li><code>CONNECTION_REQUEST_TIMEOUT</code></li>\n<li><code>CONNECT_TIMEOUT</code></li>\n<li><code>SOCKET_TIMEOUT</code></li>\n<li><code>MAX_CONN_TOTAL</code></li>\n<li><code>MAX_CONN_PER_ROUTE</code></li>\n</ol>\n<p>不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;HttpHost&gt; httpHosts = Lists.newArrayListWithExpectedSize(serverNum);</span><br><span class=\"line\">serverAddressList.forEach((server) -&gt; httpHosts.add(<span class=\"keyword\">new</span> HttpHost(server.getAddr(), server.getPort(), <span class=\"string\">\"http\"</span>)));</span><br><span class=\"line\"><span class=\"keyword\">private</span> RestHighLevelClient highLevelClient = <span class=\"keyword\">new</span> RestHighLevelClient(</span><br><span class=\"line\">        RestClient.builder(httpHosts.toArray(<span class=\"keyword\">new</span> HttpHost[<span class=\"number\">0</span>]))</span><br><span class=\"line\">        <span class=\"comment\">// timeout settings</span></span><br><span class=\"line\">        .setRequestConfigCallback((callback) -&gt; callback</span><br><span class=\"line\">                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)</span><br><span class=\"line\">                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)</span><br><span class=\"line\">                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))</span><br><span class=\"line\">        <span class=\"comment\">// connections total and connections per host</span></span><br><span class=\"line\">        .setHttpClientConfigCallback((callback) -&gt; callback</span><br><span class=\"line\">                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)</span><br><span class=\"line\">                .setMaxConnTotal(MAX_CONN_TOTAL)</span><br><span class=\"line\">        )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) request timeout 的设置</strong><br>对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;<br>这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;<br>那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;<br>首先需要定义一个 response 容器来盛装异步回调里拿到的 result:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseWrapper</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T response;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Exception exception;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getResponse</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> response; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setResponse</span><span class=\"params\">(T response)</span> </span>&#123; <span class=\"keyword\">this</span>.response = response; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Exception <span class=\"title\">getException</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> exception; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Exception exception)</span> </span>&#123; <span class=\"keyword\">this</span>.exception = exception;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* get request with timeout */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ResponseWrapper&lt;GetResponse&gt; wrapper = <span class=\"keyword\">new</span> ResponseWrapper&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">final</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">highLevelClient.getAsync(request, <span class=\"keyword\">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(GetResponse documentFields)</span> </span>&#123;</span><br><span class=\"line\">        wrapper.setResponse(documentFields);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">        wrapper.setException(e);</span><br><span class=\"line\">        wrapper.setResponse(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ElasticsearchTimeoutException(<span class=\"string\">\"timeout\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (wrapper.getResponse() == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 异常处理 &#125; </span></span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123; 处理 wrapper.getResponse() 的返回结果 &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(3) query 请求 dsl 的传参问题</strong><br>es-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"include\"</span>: [ ... ],</span><br><span class=\"line\">        <span class=\"string\">\"exclude\"</span>: [ ... ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"from\"</span>: xxx,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: yyy,</span><br><span class=\"line\">    <span class=\"string\">\"sort\"</span>: [ ... ],</span><br><span class=\"line\">    <span class=\"string\">\"aggs\"</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象;<br>这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;<br>权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String dslStr = <span class=\"string\">\"...\"</span>;</span><br><span class=\"line\">SearchModule searchModule = <span class=\"keyword\">new</span> SearchModule(Settings.EMPTY, <span class=\"keyword\">false</span>, Collections.emptyList());</span><br><span class=\"line\">XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);</span><br><span class=\"line\"></span><br><span class=\"line\">SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);</span><br></pre></td></tr></table></figure></p>\n<p><strong>(4) 无厘头的 <code>adjust_pure_negative</code></strong><br>整个 HighLevelClient 中, 最让人感到费解的一个东西就是一个神秘的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* org.elasticsearch.index.query.BoolQueryBuilder */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ParseField ADJUST_PURE_NEGATIVE = <span class=\"keyword\">new</span> ParseField(<span class=\"string\">\"adjust_pure_negative\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> adjustPureNegative = ADJUST_PURE_NEGATIVE_DEFAULT;</span><br></pre></td></tr></table></figure></p>\n<p>先是看官方文档, 搜不到;<br>然后搜 google, 就找到这么一个稍微相关一点的帖子: <a href=\"https://discuss.elastic.co/t/what-does-adjust-pure-negative-flag-do/92348\" target=\"_blank\" rel=\"noopener\">What does “adjust_pure_negative” flag do?</a>, 而其给出的唯一回复是 “<strong>You can ignore it</strong>“;<br>实在搜不到有效的信息, 我只好去扒源码; 然而, 除了如上所述的 BoolQueryBuilder 中的这坨, 再加上一些测试类, 就再也没在其他地方看到与 <code>adjust_pure_negative</code> 相关的逻辑了;<br>也许真的如 elastic 讨论组中所说的 <em>You can ignore it?</em> 但是现在有一个问题让我无法忽略它: 这个属性无法被 2.4.2 的 elasticsearch 识别, 但在 6.2.2 的 elasticsearch 中, 各个 QueryBuilder 的 toString() 方法会自动将其带上:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"adjust_pure_negative\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"boost\"</span>: <span class=\"number\">1.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上一节中提到, es-adapter 接受业务线传来的 query dsl str, 使用 6.2.2 的 elasticsearch 便会将上述语句传给 es-adapter; 如果其访问的索引已经迁移到 6.2.2 新集群, 那么该语句没问题; 但如果其访问的索引还未来得及迁移到新集群, es-adapter 会将该请求路由到旧的 2.4.2 集群, 接着便会发生语法解析异常;<br>&nbsp;<br><em>这意味着, 在某个系统所需要访问的所有索引迁移到 6.2.2 新集群之前, 其 maven 依赖的 elasticsearch 版本, 不能提前升级到 6.2.2, 以阻止 adjust_pure_negative 的生成;</em><br><em>当然考虑到 major 版本升级所带来的语法规则的巨变已被 es-adapter 缓冲掉了绝大部分, 我相信各业务线也不希望把 elasticsearch 的 maven 版本给直接升上去的; 毕竟那意味着代码将红成一大片, 要花费大量的精力修改代码, 这等于把 es-adapter 原本要替其做的事, 提前自己给办了;</em></p>\n<p><strong>(5) 其他小众的需求</strong><br>以上展示的是业务线普遍会遇到的情况, 然后还有两个比较小众的需求, 在个别系统中会使用到,  也是上面所提到的 nested_filter 和 aggregations;<br>关于 nested_filter 还稍顺利些, api 有一些变化但是新的 api 有新的解决方案:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6.2.2 版本: 构造一个 携带 nested_filter 的 sort</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SortBuilder <span class=\"title\">buildNestedSort</span><span class=\"params\">(NestedSort nestedSort)</span> </span>&#123;</span><br><span class=\"line\">    QueryBuilder termFilter = QueryBuilders.termsQuery(nestedSort.getTermField(), nestedSort.getTermValue());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SortBuilders.fieldSort(nestedSort.getSortName())</span><br><span class=\"line\">            .setNestedSort(<span class=\"keyword\">new</span> NestedSortBuilder(nestedSort.getNestedPath()).setFilter(termFilter))</span><br><span class=\"line\">            .order(nestedSort.getOrder())</span><br><span class=\"line\">            .sortMode(SortMode.fromString(nestedSort.getSortMode()))</span><br><span class=\"line\">            .missing(nestedSort.getMissing());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只不过这种顺利是建立在之前的不顺利基础上的: org.elasticsearch.search.sort.SortBuilders 没有实现 java.io.Serializable 接口, 各业务线的系统没法通过 dubbo 接口把参数传给我, 所以不得不自定义了上面的 NestedSort 类用于盛装 nested sort filter 的相关参数:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sortName; <span class=\"comment\">// 排序用的字段名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SortOrder order = SortOrder.ASC;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String missing; <span class=\"comment\">// _first/_last,如果指定的字段不存在的排序逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sortMode; <span class=\"comment\">// max/min/sum/avg</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nestedPath;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String termField; <span class=\"comment\">// filter对应的 term 的field,现在只支持terms;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Collection&lt;String&gt; termValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好在 nested_filter 相关参数类别可以固化, 比较稳定, 自定义类也算是个解决方案了;<br>&nbsp;<br>但是另一个小众需求就没那么省事了: aggregations; 之前 2.4.2 的 agg api 中, 有一个通用的方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SearchRequestBuilder <span class=\"title\">setAggregations</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] aggregations)</span> </span>&#123;</span><br><span class=\"line\">    sourceBuilder().aggregations(aggregations);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>elasticsearch 聚合的 api 比较丰富自由, 而上面方法中的 aggregations 参数是以字节的形式传过来的, 所以业务线可以自由发挥, 不受 es-adapter 的约束, 但可惜这个方法在 6.2.2 版本中取消了;<br>这样一来不得不回到束缚之中, 针对不同的聚合类型作各自的处理了; 可惜各个聚合类型依然没有实现 java.io.Serializable 接口, 所以还是得自定义类型去盛装参数了; 比如以下是针对分位数的聚合:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PercentileAggregation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String aggName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String aggField;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span>[] percents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PercentilesAggregationBuilder percentileAggBuilder = AggregationBuilders.percentiles(param.getPercentileAggregation().getAggName())</span><br><span class=\"line\">        .field(param.getPercentileAggregation().getAggField())</span><br><span class=\"line\">        .percentiles(param.getPercentileAggregation().getPercents());</span><br><span class=\"line\">searchSourceBuilder.aggregation(percentileAggBuilder)</span><br></pre></td></tr></table></figure>\n<p>其他的聚合类型不再一一列举; 关于 aggregations 的 api 变化着实比较大, 好在使用它的系统比较少, 推动其修改逻辑阻力亦不是很大;<br>&nbsp;<br>HighLevelClient 的使用基本上要解决的就是以上几个问题了; 解决了客户端的问题, 就是解决了 “道” 的问题, 剩下的 “术” 的问题, 都已不是主要矛盾了;</p>\n<h2 id=\"语法兼容性问题\"><a href=\"#语法兼容性问题\" class=\"headerlink\" title=\"语法兼容性问题\"></a><strong>语法兼容性问题</strong></h2><p>语法兼容性问题便是上文所提及 “术” 的问题的主要表现形式; 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;</p>\n<h3 id=\"索引创建的兼容性\"><a href=\"#索引创建的兼容性\" class=\"headerlink\" title=\"索引创建的兼容性\"></a><strong>索引创建的兼容性</strong></h3><p>es 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:<br>&nbsp;<br><strong>首先是 settings 中的区别;</strong><br>&nbsp;<br>部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"settings\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"comment\">// creation_date 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"creation_date\"</span>: <span class=\"string\">\"1502713848656\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"number_of_shards\"</span>:<span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"analysis\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"analyzer\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"comma_analyzer\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>:<span class=\"string\">\"custom\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"tokenizer\"</span>:<span class=\"string\">\"comma_tk\"</span></span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            <span class=\"string\">\"tokenizer\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"comma_tk\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"pattern\"</span>:<span class=\"string\">\",\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>:<span class=\"string\">\"pattern\"</span></span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"number_of_replicas\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// uuid 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"uuid\"</span>:<span class=\"string\">\"Oa0tz0x-SpSfuC591_ASIQ\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// version.create, version.update 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"version\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"created\"</span>:<span class=\"string\">\"1070399\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"upgraded\"</span>:<span class=\"string\">\"2040299\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;</em><br>&nbsp;<br><strong>然后是 mappings 中的区别;</strong><br>&nbsp;<br><strong>(1) 布尔类型的取值内容规范化</strong><br>elasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// elasticsearch 2.4.2</span></span><br><span class=\"line\"><span class=\"comment\">// xxx_idx/_mapping/field/xxx_field</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"xxx_idx\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"mappings\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"xxx_type\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"xxx_field\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"full_name\"</span>:<span class=\"string\">\"xxx_field\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"mapping\"</span>:&#123;</span><br><span class=\"line\">                        <span class=\"string\">\"xxx_field\"</span>:&#123;</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>:<span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"index_name\"</span>:<span class=\"string\">\"xxx_field\"</span>,</span><br><span class=\"line\">                            <span class=\"comment\">// 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义</span></span><br><span class=\"line\">                            <span class=\"string\">\"index\"</span>:<span class=\"string\">\"not_analyzed\"</span>, </span><br><span class=\"line\">                            <span class=\"string\">\"store\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"doc_values\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"term_vector\"</span>:<span class=\"string\">\"no\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"norms\"</span>:&#123;</span><br><span class=\"line\">                                <span class=\"string\">\"enabled\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                            <span class=\"string\">\"null_value\"</span>:<span class=\"literal\">null</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"include_in_all\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: <code>true</code> 或 <code>false</code>;<br><em>从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 <code>index</code> 属性可能会经常用到;</em></p>\n<p><strong>(2) _timestamp 字段被废弃</strong><br><em>这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;</em><br>&nbsp;<br>况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_timestamp\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;</p>\n<p><strong>(3) _all 字段被 deprecated, include_in_all 属性被废弃</strong><br>在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;<br>之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_all\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;<br>与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;<br>elasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 <code>copy_to</code> 属性:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"first_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"copy_to\"</span>: <span class=\"string\">\"full_name\"</span> </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"last_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"copy_to\"</span>: <span class=\"string\">\"full_name\"</span> </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"full_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;<br>&nbsp;<br><em>无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;</em></p>\n<p><strong>(4) 史诗级大改变: string 类型被废弃</strong><br>string 类型被废弃, 代替者是分词的 <code>text</code> 类型和不分词的 <code>keyword</code> 类型;<br>当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;<br>&nbsp;<br><em>不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;</em><br>&nbsp;<br>经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: <a href=\"https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst\" target=\"_blank\" rel=\"noopener\">Changelog</a>;<br>仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;<br>比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"xxx\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"not_analyzed\"</span> <span class=\"comment\">// 不需要分词, 但要索引</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"yyy\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"no\"</span> <span class=\"comment\">// 不需要分词, 也不需要索引</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"zzz\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span> <span class=\"comment\">// 默认情况, 需要索引, 也需要分词</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>index</code> 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 <code>not_analyzed</code>, <code>analyzed</code>, <code>no</code> 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 <code>not_analyzed</code>, <code>no</code> 中作出选择; 不得不说这非常混乱;<br>要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;<br>至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;<br>现在逻辑理清楚了, <code>index</code> 的取值类型, 也就如上一节所说的, 必须要在 <code>true</code> 或 <code>false</code> 中选择, 非常清晰;</p>\n<p><strong>(5) mapping 中取消 multi types</strong><br>从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html\" target=\"_blank\" rel=\"noopener\">Removal of mapping types</a>;<br>由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:</p>\n<blockquote>\n<p>In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.</p>\n</blockquote>\n<p>&nbsp;<br><em>这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;</em></p>\n<h3 id=\"query-dsl-的兼容性\"><a href=\"#query-dsl-的兼容性\" class=\"headerlink\" title=\"query dsl 的兼容性\"></a><strong>query dsl 的兼容性</strong></h3><p>索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;</p>\n<p><strong>(1) filtered query 被废弃</strong><br>其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;<br>filtered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: </p>\n<blockquote>\n<p>Exclude as many document as you can with a filter, then query just the documents that remain.</p>\n</blockquote>\n<p>然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;<br>&nbsp;<br><em>从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:</em><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在 es-adapter 中删除 filtered</span></span><br><span class=\"line\">  <span class=\"string\">\"filtered\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有 filter, 将其移动到 query -&gt; bool 中</span></span><br><span class=\"line\">    <span class=\"string\">\"filter\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) filter context 被限定在 bool query 中使用</strong><br>如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 引入 filter context 作前置过滤</span></span><br><span class=\"line\">      <span class=\"string\">\"filter\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br><em>由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;</em></p>\n<p><strong>(3) and/or/not query 被废弃</strong><br>与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;<br>可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;<br>现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;<br>但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;<br>&nbsp;<br><em>从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;</em></p>\n<p><strong>(4) missing query 被废弃</strong><br>要实现 missing 语义的 query, 现在必须统一使用 must_not exists:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"must_not\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"exists\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">\"field\"</span>: <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;<br>&nbsp;<br><em>这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;</em><br><em>另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;</em><br><em>所以, 关于 missing , 必须由业务线自己来修改相关代码了;</em></p>\n<h3 id=\"search-api-的兼容性\"><a href=\"#search-api-的兼容性\" class=\"headerlink\" title=\"search api 的兼容性\"></a><strong>search api 的兼容性</strong></h3><p>相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;</p>\n<p><strong>(1) search_type <code>scan</code> 被废弃</strong><br>关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);<br>从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num * target_size 数量的结果集大小; 除此之外, 没有其他什么区别;<br>&nbsp;<br><em>然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* es-adapter 的查询服务 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseContent <span class=\"title\">query</span><span class=\"params\">(RequestParam param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scroll(param);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (param.getSearchType().equals(SearchType.COUNT)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count(param);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> normallyQuery(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;</em><br><em>这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;</em></p>\n<p><strong>(2) search_type <code>count</code> 被废弃</strong><br>count 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only counts the results, will still execute aggregations and the like.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@deprecated</span> does not any improvements compared to &#123;<span class=\"doctag\">@link</span> #QUERY_THEN_FETCH&#125; with a `size` of &#123;<span class=\"doctag\">@code</span> 0&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">COUNT((<span class=\"keyword\">byte</span>) <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;<br>&nbsp;<br><em>可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;</em></p>\n<p><strong>(3) search_type <code>query_and_fetch</code> 被 deprecated, <code>dfs_query_and_fetch</code> 被废弃</strong><br>这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;<br>&nbsp;<br><em>所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;</em></p>\n<h2 id=\"底层索引数据兼容性问题\"><a href=\"#底层索引数据兼容性问题\" class=\"headerlink\" title=\"底层索引数据兼容性问题\"></a><strong>底层索引数据兼容性问题</strong></h2><p>根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;<br>背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;</p>\n<ul>\n<li>由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;<br>但是看了官方文档, 这个想法是不可行的: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html\" target=\"_blank\" rel=\"noopener\">Reindex before upgrading</a>; elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;</li>\n<li><p>其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\" target=\"_blank\" rel=\"noopener\">Snapshot And Restore</a>):</p>\n<blockquote>\n<p>A snapshot of an index created in 5.x can be restored to 6.x.<br>A snapshot of an index created in 2.x can be restored to 5.x.<br>A snapshot of an index created in 1.x can be restored to 2.x.</p>\n</blockquote>\n</li>\n<li><p>接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: <code>reindex.remote.whitelist: oldhost:port</code> 以允许连接远程主机作 reindex;<br>以下是 _reindex api 的使用方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST _reindex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"source\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"remote\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"host\"</span>: <span class=\"string\">\"http://oldhost:9273\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"source_idx\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"source_type\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"dest\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"dest_idx\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"dest_type\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;</p>\n</li>\n</ul>\n<h2 id=\"工具兼容性问题\"><a href=\"#工具兼容性问题\" class=\"headerlink\" title=\"工具兼容性问题\"></a><strong>工具兼容性问题</strong></h2><h3 id=\"http-访问工具兼容性\"><a href=\"#http-访问工具兼容性\" class=\"headerlink\" title=\"http 访问工具兼容性\"></a><strong>http 访问工具兼容性</strong></h3><p>目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;<br>关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: <a href=\"https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests\" target=\"_blank\" rel=\"noopener\">Strict Content-Type Checking for Elasticsearch REST Requests</a>;<br>现在所有带 body 的请求都必须要加上 <code>Content-Type</code> 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;<br>&nbsp;<br>目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: <a href=\"https://github.com/yannart/docker-cerebro\" target=\"_blank\" rel=\"noopener\">yannart/docker-cerebro</a>; 经过部署测试, 完全兼容 elasticsearch 6.2.2;<br>不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;<br>&nbsp;<br>没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;<br>首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 <code>Content-Type</code>, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;<br>然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 <code>Content-Type</code> 的时候, 那就指定为 <code>application/json</code> 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;<br>如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">   listen 80;</span><br><span class=\"line\">   server_name esbetae.corp.11bee.com;</span><br><span class=\"line\"></span><br><span class=\"line\">   location / &#123;</span><br><span class=\"line\">      proxy_pass http://l-es5.beta.p1.11bee.com:9273/;</span><br><span class=\"line\"></span><br><span class=\"line\">      proxy_set_header X-Real-Scheme <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">      proxy_set_header Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">      proxy_set_header X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">      proxy_set_header X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">      <span class=\"comment\"># 统一加上 application/json 的 Content-Type</span></span><br><span class=\"line\">      proxy_set_header Content-Type application/json;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;<br>其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;</p>\n<h3 id=\"插件兼容性\"><a href=\"#插件兼容性\" class=\"headerlink\" title=\"插件兼容性\"></a><strong>插件兼容性</strong></h3><p>笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;<br><strong>(1) elasticfence</strong><br>这个插件追踪溯源的话是这个项目: <a href=\"https://github.com/elasticfence/elasticsearch-http-user-auth\" target=\"_blank\" rel=\"noopener\">elasticfence</a>; 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;<br>当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;<br>首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;<br>当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A filter allowing to filter rest operations.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">order</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(RestRequest request, RestChannel channel, RestFilterChain filterChain)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;<br>经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public interface ActionPlugin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a function used to wrap each rest request before handling the request.</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: Only one installed plugin may implement a rest wrapper.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> UnaryOperator&lt;RestHandler&gt; <span class=\"title\">getRestHandlerWrapper</span><span class=\"params\">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public class ElasticfencePlugin extends Plugin implements ActionPlugin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UnaryOperator&lt;RestHandler&gt; <span class=\"title\">getRestHandlerWrapper</span><span class=\"params\">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPluginDisabled()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 透传请求</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (originRestHandler) -&gt; authRestFilter.wrapNone(originRestHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 权限控制</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (originRestHandler) -&gt; authRestFilter.wrap(originRestHandler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;<br>换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制…… 要想使用, 就必须申请权限!<br>当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;<br>然而实际上, 申请权限却不是那么顺利: 我按照官方文档 <a href=\"https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions\" target=\"_blank\" rel=\"noopener\">Help for plugin authors</a> 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;<br>&nbsp;<br>根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!<br>想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;<br>不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;<br>在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;<br>源码中与 java security manager 相关的代码主要有以下几个地方:<br>首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.Elasticsearch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// we want the JVM to think there is a security manager installed so that if internal policy </span></span><br><span class=\"line\">    <span class=\"comment\">// decisions that would be based on the presence of a security manager</span></span><br><span class=\"line\">    <span class=\"comment\">// or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class=\"line\">    System.setSecurityManager(<span class=\"keyword\">new</span> SecurityManager() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkPermission</span><span class=\"params\">(Permission perm)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    LogConfigurator.registerErrorListener();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Elasticsearch elasticsearch = <span class=\"keyword\">new</span> Elasticsearch();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != ExitCodes.OK) &#123;</span><br><span class=\"line\">        exit(status);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着是 Bootstrap 类:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.Bootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">(<span class=\"keyword\">boolean</span> addShutdownHook, Environment environment)</span> <span class=\"keyword\">throws</span> BootstrapException </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// install SM after natives, shutdown hooks, etc.</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BootstrapException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是 BootstrapChecks 类:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.BootstrapChecks</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the list of checks to execute</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> List&lt;BootstrapCheck&gt; <span class=\"title\">checks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;BootstrapCheck&gt; checks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    checks.add(<span class=\"keyword\">new</span> AllPermissionCheck());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.unmodifiableList(checks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllPermissionCheck</span> <span class=\"keyword\">implements</span> <span class=\"title\">BootstrapCheck</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> BootstrapCheckResult <span class=\"title\">check</span><span class=\"params\">(BootstrapContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAllPermissionGranted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> BootstrapCheck.BootstrapCheckResult.failure(<span class=\"string\">\"granting the all permission effectively disables security\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BootstrapCheckResult.success();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAllPermissionGranted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> sm != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            sm.checkPermission(<span class=\"keyword\">new</span> AllPermission());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> SecurityException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;<br>重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动; 尽管这个问题暂时解决了, 但总是 “不太光彩”; 如果有人知道如何通过常规方法解决 security manager 的问题, 还请不吝赐教;</p>\n<p><strong>(2) elasticsearch-analysis-ik</strong><br>这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, <a href=\"https://github.com/medcl\" target=\"_blank\" rel=\"noopener\">medcl</a> 一定会在新版本发布第一时间更新 <a href=\"https://github.com/medcl/elasticsearch-analysis-ik\" target=\"_blank\" rel=\"noopener\">elasticsearch-analysis-ik</a>, 与公司共进退;<br>安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;</p>\n<p><strong>(3) 其余插件</strong><br>在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;</p>\n<h2 id=\"监控体系\"><a href=\"#监控体系\" class=\"headerlink\" title=\"监控体系\"></a><strong>监控体系</strong></h2><h3 id=\"基于-rest-api-graphite-grafana-的方案\"><a href=\"#基于-rest-api-graphite-grafana-的方案\" class=\"headerlink\" title=\"基于 rest api + graphite + grafana 的方案\"></a><strong>基于 rest api + graphite + grafana 的方案</strong></h3><p>基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们监控 elasticsearch 集群健康状况的主力工具 (这篇文章详细介绍了 elasticsearch 各种 rest api 收集到的指标以及将其可视化的方法: <a href=\"\">使用 rest api 可视化监控 elasticsearch 集群</a>);<br>将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现 rest api 有了一些变化;<br>首先是 rest api 调用的参数的细微变化:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数</span></span><br><span class=\"line\">_nodes/stats?all=<span class=\"literal\">true</span></span><br><span class=\"line\">_stats?all=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>all 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;<br>其余的 api 在调用的路径和参数上都没有什么变化, 比较顺利;<br>然后是调用 api 返回的内容有一些细微的变化:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.4.2 的 load 指标</span></span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.load_avergae</span><br><span class=\"line\"><span class=\"comment\"># 6.2.2 的 load 指标</span></span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.1m</span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.5m</span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.15m</span><br></pre></td></tr></table></figure></p>\n<p>6.2.2 的机器 load 指标收集, 随系统细分为了 1min, 5min 和 15min 三种, 也算是更精致了;</p>\n<h3 id=\"elastic-官方组件-x-pack\"><a href=\"#elastic-官方组件-x-pack\" class=\"headerlink\" title=\"elastic 官方组件 x-pack\"></a><strong>elastic 官方组件 x-pack</strong></h3><p>在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;<br>从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png\" alt=\"x-pack-fee-table\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-fee-table</div>\n            </figure><br>对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;<br>我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;<br>可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png\" alt=\"x-pack-monitor\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-monitor</div>\n            </figure><br>另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png\" alt=\"x-pack-search-profiler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-search-profiler</div>\n            </figure><br>除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;<br>以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;</p>\n<h2 id=\"本文总结\"><a href=\"#本文总结\" class=\"headerlink\" title=\"本文总结\"></a><strong>本文总结</strong></h2><p>本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级到 6.2.2 的可行性与兼容性问题;<br><strong>首先是客户端兼容性问题:</strong><br>elastic 公司新推出的 <code>RestHighLevelClient</code> 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 <code>RestHighLevelClient</code> 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利; 对各业务线而言, 只有有限的 (诸如 aggregations) api 被迫需要修改, 其余的都可以延续下去;<br><strong>其次是语法兼容性问题:</strong><br>此处仍需细分为三个方面: <strong>create index</strong>, <strong>query dsl</strong> 和 <strong>search api</strong> ;<br><strong>create index</strong> 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 <code>string</code> 类型, 改而细分出两个司职更明确的类型: <code>text</code> 与 <code>keyword</code>, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;<br><strong>query dsl</strong> 方面, 对我们的影响也在控制范围之内: 只有 <code>missing</code> 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;<br><strong>search api</strong> 方面, 可能影响就比较大了: <code>scan</code> 和 <code>count</code> 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;<br><strong>然后是索引数据迁移兼容性问题:</strong><br>经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;<br><strong>接着是工具兼容性问题:</strong><br>经过不断探索与变通, 最后 <code>cerebro</code>, <code>elasticsearch-head</code>, <code>elasticfence</code>, <code>elasticsearch-analysis-ik</code>, <code>curator</code> 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 “顺利” 实现了对 6.2.2 版本的兼容;<br>这其中, <code>elasticfence</code> 实现兼容的过程比较坎坷, 甚至还重新编译了 elasticsearch 的源码才解决了 security manager 的问题; 如果以后能通过常规方式解决安全的问题, 一定还得弄回去;<br><strong>最后是监控体系兼容性问题:</strong><br>得益于 6.x 版本 rest api 对先前的延续 (除了极个别 api 有细微调整之外), 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;<br>另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;</p>\n<p>&nbsp;<br><strong>以上便是本文的全部内容;</strong></p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">apache httpclient 初始化参数设置总结</a></li>\n<li><a href=\"\">使用 rest api 可视化监控 elasticsearch 集群</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst\" target=\"_blank\" rel=\"noopener\">Changelog</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html\" target=\"_blank\" rel=\"noopener\">Removal of mapping types</a></li>\n<li><a href=\"https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests\" target=\"_blank\" rel=\"noopener\">Strict Content-Type Checking for Elasticsearch REST Requests</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html\" target=\"_blank\" rel=\"noopener\">Compatibility</a></li>\n<li><a href=\"https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients\" target=\"_blank\" rel=\"noopener\">State of the official Elasticsearch Java clients</a></li>\n<li><a href=\"http://blog.csdn.net/napoay/article/details/79135136\" target=\"_blank\" rel=\"noopener\">Elasticsearch 6 新特性与重要变更解读</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions\" target=\"_blank\" rel=\"noopener\">Help for plugin authors</a></li>\n<li><a href=\"https://elasticsearch.cn/article/338\" target=\"_blank\" rel=\"noopener\">Intellij Idea 编译 Elasticsearch 源码</a></li>\n<li><a href=\"https://github.com/elastic/elasticsearch#building-from-source\" target=\"_blank\" rel=\"noopener\">elasticsearch: Building from Source</a></li>\n<li><a href=\"https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0\" target=\"_blank\" rel=\"noopener\">Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You</a></li>\n<li><a href=\"https://www.cnblogs.com/Leo_wl/p/6181563.html\" target=\"_blank\" rel=\"noopener\">Kibana+X-Pack</a></li>\n<li><a href=\"https://www.elastic.co/subscriptions\" target=\"_blank\" rel=\"noopener\">Subscriptions that Go to Work for You</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;<br>在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;<br>希望能给各位读者带来工作上的帮助!</p>\n</blockquote>","more":"<hr>\n<p><strong>万字长文, 高能预警! 如只希望了解最终结论, 请点击:</strong> <em><a href=\"#本文总结\">本文总结</a>;</em><br>&nbsp;<br>戊戌年春, 历时余月, 本文终于迎来了收尾;<br>这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: <a href=\"https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402\" target=\"_blank\" rel=\"noopener\">ES consume high cpu with threadlocal</a>; 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文即是该升级调研的一个总结报告;<br>相比于公司内部发表的版本, 本篇博客对所有涉及公司内部的信息作了脱敏处理, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;</p>\n<h2 id=\"客户端兼容性问题\"><a href=\"#客户端兼容性问题\" class=\"headerlink\" title=\"客户端兼容性问题\"></a><strong>客户端兼容性问题</strong></h2><p>在这篇文章的编排结构中, 我将客户端兼容性问题摆在了第一的位置: 因为不管 rest api 如何变化, 或者如何不变, 都只能算是 “术”; 我们真正跑在生产环境中的系统, 使用的是 elasticsearch java client; client 端的基础兼容性问题才是根本之 “道”;</p>\n<h3 id=\"巨轮转向的前提-es-adapter\"><a href=\"#巨轮转向的前提-es-adapter\" class=\"headerlink\" title=\"巨轮转向的前提: es-adapter\"></a><strong>巨轮转向的前提: es-adapter</strong></h3><p>我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;<br>如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 “无效” 工作量, 他们一定不会积极配合, 我们将无法推动进展;<br>还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优; 其余的系统必须通过调用其暴露出去的 dubbo 接口间接访问 elasticsearch; 这个系统被命名为 es-adapter;<br>当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: <a href=\"\">apache httpclient 初始化参数设置总结</a>; 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;<br>有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;<br>不得不说, 当系统规模与复杂度发展到了一个 “船大难掉头” 的程度时, es-adapter 就像是《三体》中描述的 “水滴” 一样, 带领整个体系从一个更高的维度完成 “平滑” 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: <a href=\"#search-api-的兼容性\">search api 的兼容性</a>;</p>\n<h3 id=\"升级过渡期-client-端的技术选型\"><a href=\"#升级过渡期-client-端的技术选型\" class=\"headerlink\" title=\"升级过渡期 client 端的技术选型\"></a><strong>升级过渡期 client 端的技术选型</strong></h3><p>关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:</p>\n<blockquote>\n<p>We plan on deprecating the <code>TransportClient</code> in Elasticsearch 7.0 and removing it completely in 8.0.</p>\n</blockquote>\n<p>所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;<br>值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;<br>要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- elasticsearch core --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- low level rest client --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch-rest-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- high level rest client --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.elasticsearch.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;<br>之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: <a href=\"https://github.com/searchbox-io/Jest\" target=\"_blank\" rel=\"noopener\">searchbox-io/Jest</a>), 基本囊括了 elasticsearch 各种类别的请求功能;<br>但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score, aggregations 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;<br>这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;<br>我们经过 demo 快速测试验证, 初步得出了结论:<br>&nbsp;<br><strong>6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;</strong><br>&nbsp;<br>这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html\" target=\"_blank\" rel=\"noopener\">Compatibility</a>;<br>所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;</p>\n<h3 id=\"HighLevelClient-的使用注意事项\"><a href=\"#HighLevelClient-的使用注意事项\" class=\"headerlink\" title=\"HighLevelClient 的使用注意事项\"></a><strong>HighLevelClient 的使用注意事项</strong></h3><p><strong>(1) 初始化的重要选项</strong><br>HighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:</p>\n<ol>\n<li><code>CONNECTION_REQUEST_TIMEOUT</code></li>\n<li><code>CONNECT_TIMEOUT</code></li>\n<li><code>SOCKET_TIMEOUT</code></li>\n<li><code>MAX_CONN_TOTAL</code></li>\n<li><code>MAX_CONN_PER_ROUTE</code></li>\n</ol>\n<p>不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;HttpHost&gt; httpHosts = Lists.newArrayListWithExpectedSize(serverNum);</span><br><span class=\"line\">serverAddressList.forEach((server) -&gt; httpHosts.add(<span class=\"keyword\">new</span> HttpHost(server.getAddr(), server.getPort(), <span class=\"string\">\"http\"</span>)));</span><br><span class=\"line\"><span class=\"keyword\">private</span> RestHighLevelClient highLevelClient = <span class=\"keyword\">new</span> RestHighLevelClient(</span><br><span class=\"line\">        RestClient.builder(httpHosts.toArray(<span class=\"keyword\">new</span> HttpHost[<span class=\"number\">0</span>]))</span><br><span class=\"line\">        <span class=\"comment\">// timeout settings</span></span><br><span class=\"line\">        .setRequestConfigCallback((callback) -&gt; callback</span><br><span class=\"line\">                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)</span><br><span class=\"line\">                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)</span><br><span class=\"line\">                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))</span><br><span class=\"line\">        <span class=\"comment\">// connections total and connections per host</span></span><br><span class=\"line\">        .setHttpClientConfigCallback((callback) -&gt; callback</span><br><span class=\"line\">                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)</span><br><span class=\"line\">                .setMaxConnTotal(MAX_CONN_TOTAL)</span><br><span class=\"line\">        )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) request timeout 的设置</strong><br>对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;<br>这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;<br>那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;<br>首先需要定义一个 response 容器来盛装异步回调里拿到的 result:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseWrapper</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T response;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Exception exception;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getResponse</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> response; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setResponse</span><span class=\"params\">(T response)</span> </span>&#123; <span class=\"keyword\">this</span>.response = response; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Exception <span class=\"title\">getException</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> exception; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Exception exception)</span> </span>&#123; <span class=\"keyword\">this</span>.exception = exception;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* get request with timeout */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ResponseWrapper&lt;GetResponse&gt; wrapper = <span class=\"keyword\">new</span> ResponseWrapper&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">final</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">highLevelClient.getAsync(request, <span class=\"keyword\">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(GetResponse documentFields)</span> </span>&#123;</span><br><span class=\"line\">        wrapper.setResponse(documentFields);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">        wrapper.setException(e);</span><br><span class=\"line\">        wrapper.setResponse(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ElasticsearchTimeoutException(<span class=\"string\">\"timeout\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (wrapper.getResponse() == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 异常处理 &#125; </span></span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123; 处理 wrapper.getResponse() 的返回结果 &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(3) query 请求 dsl 的传参问题</strong><br>es-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"include\"</span>: [ ... ],</span><br><span class=\"line\">        <span class=\"string\">\"exclude\"</span>: [ ... ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"from\"</span>: xxx,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: yyy,</span><br><span class=\"line\">    <span class=\"string\">\"sort\"</span>: [ ... ],</span><br><span class=\"line\">    <span class=\"string\">\"aggs\"</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象;<br>这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;<br>权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String dslStr = <span class=\"string\">\"...\"</span>;</span><br><span class=\"line\">SearchModule searchModule = <span class=\"keyword\">new</span> SearchModule(Settings.EMPTY, <span class=\"keyword\">false</span>, Collections.emptyList());</span><br><span class=\"line\">XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);</span><br><span class=\"line\"></span><br><span class=\"line\">SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);</span><br></pre></td></tr></table></figure></p>\n<p><strong>(4) 无厘头的 <code>adjust_pure_negative</code></strong><br>整个 HighLevelClient 中, 最让人感到费解的一个东西就是一个神秘的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* org.elasticsearch.index.query.BoolQueryBuilder */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ParseField ADJUST_PURE_NEGATIVE = <span class=\"keyword\">new</span> ParseField(<span class=\"string\">\"adjust_pure_negative\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> adjustPureNegative = ADJUST_PURE_NEGATIVE_DEFAULT;</span><br></pre></td></tr></table></figure></p>\n<p>先是看官方文档, 搜不到;<br>然后搜 google, 就找到这么一个稍微相关一点的帖子: <a href=\"https://discuss.elastic.co/t/what-does-adjust-pure-negative-flag-do/92348\" target=\"_blank\" rel=\"noopener\">What does “adjust_pure_negative” flag do?</a>, 而其给出的唯一回复是 “<strong>You can ignore it</strong>“;<br>实在搜不到有效的信息, 我只好去扒源码; 然而, 除了如上所述的 BoolQueryBuilder 中的这坨, 再加上一些测试类, 就再也没在其他地方看到与 <code>adjust_pure_negative</code> 相关的逻辑了;<br>也许真的如 elastic 讨论组中所说的 <em>You can ignore it?</em> 但是现在有一个问题让我无法忽略它: 这个属性无法被 2.4.2 的 elasticsearch 识别, 但在 6.2.2 的 elasticsearch 中, 各个 QueryBuilder 的 toString() 方法会自动将其带上:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"adjust_pure_negative\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"boost\"</span>: <span class=\"number\">1.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上一节中提到, es-adapter 接受业务线传来的 query dsl str, 使用 6.2.2 的 elasticsearch 便会将上述语句传给 es-adapter; 如果其访问的索引已经迁移到 6.2.2 新集群, 那么该语句没问题; 但如果其访问的索引还未来得及迁移到新集群, es-adapter 会将该请求路由到旧的 2.4.2 集群, 接着便会发生语法解析异常;<br>&nbsp;<br><em>这意味着, 在某个系统所需要访问的所有索引迁移到 6.2.2 新集群之前, 其 maven 依赖的 elasticsearch 版本, 不能提前升级到 6.2.2, 以阻止 adjust_pure_negative 的生成;</em><br><em>当然考虑到 major 版本升级所带来的语法规则的巨变已被 es-adapter 缓冲掉了绝大部分, 我相信各业务线也不希望把 elasticsearch 的 maven 版本给直接升上去的; 毕竟那意味着代码将红成一大片, 要花费大量的精力修改代码, 这等于把 es-adapter 原本要替其做的事, 提前自己给办了;</em></p>\n<p><strong>(5) 其他小众的需求</strong><br>以上展示的是业务线普遍会遇到的情况, 然后还有两个比较小众的需求, 在个别系统中会使用到,  也是上面所提到的 nested_filter 和 aggregations;<br>关于 nested_filter 还稍顺利些, api 有一些变化但是新的 api 有新的解决方案:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6.2.2 版本: 构造一个 携带 nested_filter 的 sort</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SortBuilder <span class=\"title\">buildNestedSort</span><span class=\"params\">(NestedSort nestedSort)</span> </span>&#123;</span><br><span class=\"line\">    QueryBuilder termFilter = QueryBuilders.termsQuery(nestedSort.getTermField(), nestedSort.getTermValue());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SortBuilders.fieldSort(nestedSort.getSortName())</span><br><span class=\"line\">            .setNestedSort(<span class=\"keyword\">new</span> NestedSortBuilder(nestedSort.getNestedPath()).setFilter(termFilter))</span><br><span class=\"line\">            .order(nestedSort.getOrder())</span><br><span class=\"line\">            .sortMode(SortMode.fromString(nestedSort.getSortMode()))</span><br><span class=\"line\">            .missing(nestedSort.getMissing());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只不过这种顺利是建立在之前的不顺利基础上的: org.elasticsearch.search.sort.SortBuilders 没有实现 java.io.Serializable 接口, 各业务线的系统没法通过 dubbo 接口把参数传给我, 所以不得不自定义了上面的 NestedSort 类用于盛装 nested sort filter 的相关参数:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sortName; <span class=\"comment\">// 排序用的字段名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SortOrder order = SortOrder.ASC;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String missing; <span class=\"comment\">// _first/_last,如果指定的字段不存在的排序逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sortMode; <span class=\"comment\">// max/min/sum/avg</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nestedPath;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String termField; <span class=\"comment\">// filter对应的 term 的field,现在只支持terms;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Collection&lt;String&gt; termValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好在 nested_filter 相关参数类别可以固化, 比较稳定, 自定义类也算是个解决方案了;<br>&nbsp;<br>但是另一个小众需求就没那么省事了: aggregations; 之前 2.4.2 的 agg api 中, 有一个通用的方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SearchRequestBuilder <span class=\"title\">setAggregations</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] aggregations)</span> </span>&#123;</span><br><span class=\"line\">    sourceBuilder().aggregations(aggregations);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>elasticsearch 聚合的 api 比较丰富自由, 而上面方法中的 aggregations 参数是以字节的形式传过来的, 所以业务线可以自由发挥, 不受 es-adapter 的约束, 但可惜这个方法在 6.2.2 版本中取消了;<br>这样一来不得不回到束缚之中, 针对不同的聚合类型作各自的处理了; 可惜各个聚合类型依然没有实现 java.io.Serializable 接口, 所以还是得自定义类型去盛装参数了; 比如以下是针对分位数的聚合:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PercentileAggregation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String aggName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String aggField;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span>[] percents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PercentilesAggregationBuilder percentileAggBuilder = AggregationBuilders.percentiles(param.getPercentileAggregation().getAggName())</span><br><span class=\"line\">        .field(param.getPercentileAggregation().getAggField())</span><br><span class=\"line\">        .percentiles(param.getPercentileAggregation().getPercents());</span><br><span class=\"line\">searchSourceBuilder.aggregation(percentileAggBuilder)</span><br></pre></td></tr></table></figure>\n<p>其他的聚合类型不再一一列举; 关于 aggregations 的 api 变化着实比较大, 好在使用它的系统比较少, 推动其修改逻辑阻力亦不是很大;<br>&nbsp;<br>HighLevelClient 的使用基本上要解决的就是以上几个问题了; 解决了客户端的问题, 就是解决了 “道” 的问题, 剩下的 “术” 的问题, 都已不是主要矛盾了;</p>\n<h2 id=\"语法兼容性问题\"><a href=\"#语法兼容性问题\" class=\"headerlink\" title=\"语法兼容性问题\"></a><strong>语法兼容性问题</strong></h2><p>语法兼容性问题便是上文所提及 “术” 的问题的主要表现形式; 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;</p>\n<h3 id=\"索引创建的兼容性\"><a href=\"#索引创建的兼容性\" class=\"headerlink\" title=\"索引创建的兼容性\"></a><strong>索引创建的兼容性</strong></h3><p>es 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:<br>&nbsp;<br><strong>首先是 settings 中的区别;</strong><br>&nbsp;<br>部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"settings\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"comment\">// creation_date 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"creation_date\"</span>: <span class=\"string\">\"1502713848656\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"number_of_shards\"</span>:<span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"analysis\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"analyzer\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"comma_analyzer\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>:<span class=\"string\">\"custom\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"tokenizer\"</span>:<span class=\"string\">\"comma_tk\"</span></span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            <span class=\"string\">\"tokenizer\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"comma_tk\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"pattern\"</span>:<span class=\"string\">\",\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>:<span class=\"string\">\"pattern\"</span></span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"number_of_replicas\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// uuid 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"uuid\"</span>:<span class=\"string\">\"Oa0tz0x-SpSfuC591_ASIQ\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// version.create, version.update 不能出现在索引创建的定义语句里</span></span><br><span class=\"line\">        <span class=\"string\">\"version\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"created\"</span>:<span class=\"string\">\"1070399\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"upgraded\"</span>:<span class=\"string\">\"2040299\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;</em><br>&nbsp;<br><strong>然后是 mappings 中的区别;</strong><br>&nbsp;<br><strong>(1) 布尔类型的取值内容规范化</strong><br>elasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// elasticsearch 2.4.2</span></span><br><span class=\"line\"><span class=\"comment\">// xxx_idx/_mapping/field/xxx_field</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"xxx_idx\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"mappings\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"xxx_type\"</span>:&#123;</span><br><span class=\"line\">                <span class=\"string\">\"xxx_field\"</span>:&#123;</span><br><span class=\"line\">                    <span class=\"string\">\"full_name\"</span>:<span class=\"string\">\"xxx_field\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"mapping\"</span>:&#123;</span><br><span class=\"line\">                        <span class=\"string\">\"xxx_field\"</span>:&#123;</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>:<span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"index_name\"</span>:<span class=\"string\">\"xxx_field\"</span>,</span><br><span class=\"line\">                            <span class=\"comment\">// 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义</span></span><br><span class=\"line\">                            <span class=\"string\">\"index\"</span>:<span class=\"string\">\"not_analyzed\"</span>, </span><br><span class=\"line\">                            <span class=\"string\">\"store\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"doc_values\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"term_vector\"</span>:<span class=\"string\">\"no\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"norms\"</span>:&#123;</span><br><span class=\"line\">                                <span class=\"string\">\"enabled\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                            <span class=\"string\">\"null_value\"</span>:<span class=\"literal\">null</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"include_in_all\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: <code>true</code> 或 <code>false</code>;<br><em>从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 <code>index</code> 属性可能会经常用到;</em></p>\n<p><strong>(2) _timestamp 字段被废弃</strong><br><em>这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;</em><br>&nbsp;<br>况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_timestamp\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;</p>\n<p><strong>(3) _all 字段被 deprecated, include_in_all 属性被废弃</strong><br>在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;<br>之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_all\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;<br>与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;<br>elasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 <code>copy_to</code> 属性:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"first_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"copy_to\"</span>: <span class=\"string\">\"full_name\"</span> </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"last_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"copy_to\"</span>: <span class=\"string\">\"full_name\"</span> </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"full_name\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;<br>&nbsp;<br><em>无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;</em></p>\n<p><strong>(4) 史诗级大改变: string 类型被废弃</strong><br>string 类型被废弃, 代替者是分词的 <code>text</code> 类型和不分词的 <code>keyword</code> 类型;<br>当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;<br>&nbsp;<br><em>不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;</em><br>&nbsp;<br>经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: <a href=\"https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst\" target=\"_blank\" rel=\"noopener\">Changelog</a>;<br>仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;<br>比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"xxx\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"not_analyzed\"</span> <span class=\"comment\">// 不需要分词, 但要索引</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"yyy\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"no\"</span> <span class=\"comment\">// 不需要分词, 也不需要索引</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"zzz\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"string\"</span> <span class=\"comment\">// 默认情况, 需要索引, 也需要分词</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>index</code> 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 <code>not_analyzed</code>, <code>analyzed</code>, <code>no</code> 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 <code>not_analyzed</code>, <code>no</code> 中作出选择; 不得不说这非常混乱;<br>要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;<br>至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;<br>现在逻辑理清楚了, <code>index</code> 的取值类型, 也就如上一节所说的, 必须要在 <code>true</code> 或 <code>false</code> 中选择, 非常清晰;</p>\n<p><strong>(5) mapping 中取消 multi types</strong><br>从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html\" target=\"_blank\" rel=\"noopener\">Removal of mapping types</a>;<br>由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:</p>\n<blockquote>\n<p>In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.</p>\n</blockquote>\n<p>&nbsp;<br><em>这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;</em></p>\n<h3 id=\"query-dsl-的兼容性\"><a href=\"#query-dsl-的兼容性\" class=\"headerlink\" title=\"query dsl 的兼容性\"></a><strong>query dsl 的兼容性</strong></h3><p>索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;</p>\n<p><strong>(1) filtered query 被废弃</strong><br>其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;<br>filtered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: </p>\n<blockquote>\n<p>Exclude as many document as you can with a filter, then query just the documents that remain.</p>\n</blockquote>\n<p>然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;<br>&nbsp;<br><em>从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:</em><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在 es-adapter 中删除 filtered</span></span><br><span class=\"line\">  <span class=\"string\">\"filtered\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有 filter, 将其移动到 query -&gt; bool 中</span></span><br><span class=\"line\">    <span class=\"string\">\"filter\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) filter context 被限定在 bool query 中使用</strong><br>如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 引入 filter context 作前置过滤</span></span><br><span class=\"line\">      <span class=\"string\">\"filter\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"string\">\"must\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"should\"</span>: &#123; ... &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"must_not\"</span>: &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br><em>由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;</em></p>\n<p><strong>(3) and/or/not query 被废弃</strong><br>与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;<br>可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;<br>现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;<br>但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;<br>&nbsp;<br><em>从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;</em></p>\n<p><strong>(4) missing query 被废弃</strong><br>要实现 missing 语义的 query, 现在必须统一使用 must_not exists:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"must_not\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"exists\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">\"field\"</span>: <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;<br>&nbsp;<br><em>这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;</em><br><em>另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;</em><br><em>所以, 关于 missing , 必须由业务线自己来修改相关代码了;</em></p>\n<h3 id=\"search-api-的兼容性\"><a href=\"#search-api-的兼容性\" class=\"headerlink\" title=\"search api 的兼容性\"></a><strong>search api 的兼容性</strong></h3><p>相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;</p>\n<p><strong>(1) search_type <code>scan</code> 被废弃</strong><br>关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);<br>从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num * target_size 数量的结果集大小; 除此之外, 没有其他什么区别;<br>&nbsp;<br><em>然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* es-adapter 的查询服务 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseContent <span class=\"title\">query</span><span class=\"params\">(RequestParam param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scroll(param);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (param.getSearchType().equals(SearchType.COUNT)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count(param);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> normallyQuery(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;</em><br><em>这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;</em></p>\n<p><strong>(2) search_type <code>count</code> 被废弃</strong><br>count 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only counts the results, will still execute aggregations and the like.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@deprecated</span> does not any improvements compared to &#123;<span class=\"doctag\">@link</span> #QUERY_THEN_FETCH&#125; with a `size` of &#123;<span class=\"doctag\">@code</span> 0&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">COUNT((<span class=\"keyword\">byte</span>) <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;<br>&nbsp;<br><em>可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;</em></p>\n<p><strong>(3) search_type <code>query_and_fetch</code> 被 deprecated, <code>dfs_query_and_fetch</code> 被废弃</strong><br>这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;<br>&nbsp;<br><em>所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;</em></p>\n<h2 id=\"底层索引数据兼容性问题\"><a href=\"#底层索引数据兼容性问题\" class=\"headerlink\" title=\"底层索引数据兼容性问题\"></a><strong>底层索引数据兼容性问题</strong></h2><p>根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;<br>背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;</p>\n<ul>\n<li>由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;<br>但是看了官方文档, 这个想法是不可行的: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html\" target=\"_blank\" rel=\"noopener\">Reindex before upgrading</a>; elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;</li>\n<li><p>其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\" target=\"_blank\" rel=\"noopener\">Snapshot And Restore</a>):</p>\n<blockquote>\n<p>A snapshot of an index created in 5.x can be restored to 6.x.<br>A snapshot of an index created in 2.x can be restored to 5.x.<br>A snapshot of an index created in 1.x can be restored to 2.x.</p>\n</blockquote>\n</li>\n<li><p>接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: <code>reindex.remote.whitelist: oldhost:port</code> 以允许连接远程主机作 reindex;<br>以下是 _reindex api 的使用方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST _reindex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"source\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"remote\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"host\"</span>: <span class=\"string\">\"http://oldhost:9273\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"source_idx\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"source_type\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"dest\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"index\"</span>: <span class=\"string\">\"dest_idx\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"dest_type\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;</p>\n</li>\n</ul>\n<h2 id=\"工具兼容性问题\"><a href=\"#工具兼容性问题\" class=\"headerlink\" title=\"工具兼容性问题\"></a><strong>工具兼容性问题</strong></h2><h3 id=\"http-访问工具兼容性\"><a href=\"#http-访问工具兼容性\" class=\"headerlink\" title=\"http 访问工具兼容性\"></a><strong>http 访问工具兼容性</strong></h3><p>目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;<br>关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: <a href=\"https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests\" target=\"_blank\" rel=\"noopener\">Strict Content-Type Checking for Elasticsearch REST Requests</a>;<br>现在所有带 body 的请求都必须要加上 <code>Content-Type</code> 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;<br>&nbsp;<br>目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: <a href=\"https://github.com/yannart/docker-cerebro\" target=\"_blank\" rel=\"noopener\">yannart/docker-cerebro</a>; 经过部署测试, 完全兼容 elasticsearch 6.2.2;<br>不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;<br>&nbsp;<br>没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;<br>首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 <code>Content-Type</code>, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;<br>然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 <code>Content-Type</code> 的时候, 那就指定为 <code>application/json</code> 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;<br>如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">   listen 80;</span><br><span class=\"line\">   server_name esbetae.corp.11bee.com;</span><br><span class=\"line\"></span><br><span class=\"line\">   location / &#123;</span><br><span class=\"line\">      proxy_pass http://l-es5.beta.p1.11bee.com:9273/;</span><br><span class=\"line\"></span><br><span class=\"line\">      proxy_set_header X-Real-Scheme <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">      proxy_set_header Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">      proxy_set_header X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">      proxy_set_header X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">      <span class=\"comment\"># 统一加上 application/json 的 Content-Type</span></span><br><span class=\"line\">      proxy_set_header Content-Type application/json;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;<br>其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;</p>\n<h3 id=\"插件兼容性\"><a href=\"#插件兼容性\" class=\"headerlink\" title=\"插件兼容性\"></a><strong>插件兼容性</strong></h3><p>笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;<br><strong>(1) elasticfence</strong><br>这个插件追踪溯源的话是这个项目: <a href=\"https://github.com/elasticfence/elasticsearch-http-user-auth\" target=\"_blank\" rel=\"noopener\">elasticfence</a>; 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;<br>当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;<br>首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;<br>当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A filter allowing to filter rest operations.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">order</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(RestRequest request, RestChannel channel, RestFilterChain filterChain)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;<br>经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public interface ActionPlugin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a function used to wrap each rest request before handling the request.</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: Only one installed plugin may implement a rest wrapper.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> UnaryOperator&lt;RestHandler&gt; <span class=\"title\">getRestHandlerWrapper</span><span class=\"params\">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public class ElasticfencePlugin extends Plugin implements ActionPlugin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UnaryOperator&lt;RestHandler&gt; <span class=\"title\">getRestHandlerWrapper</span><span class=\"params\">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPluginDisabled()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 透传请求</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (originRestHandler) -&gt; authRestFilter.wrapNone(originRestHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 权限控制</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (originRestHandler) -&gt; authRestFilter.wrap(originRestHandler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;<br>换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制…… 要想使用, 就必须申请权限!<br>当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;<br>然而实际上, 申请权限却不是那么顺利: 我按照官方文档 <a href=\"https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions\" target=\"_blank\" rel=\"noopener\">Help for plugin authors</a> 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;<br>&nbsp;<br>根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!<br>想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;<br>不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;<br>在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;<br>源码中与 java security manager 相关的代码主要有以下几个地方:<br>首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.Elasticsearch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// we want the JVM to think there is a security manager installed so that if internal policy </span></span><br><span class=\"line\">    <span class=\"comment\">// decisions that would be based on the presence of a security manager</span></span><br><span class=\"line\">    <span class=\"comment\">// or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class=\"line\">    System.setSecurityManager(<span class=\"keyword\">new</span> SecurityManager() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkPermission</span><span class=\"params\">(Permission perm)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    LogConfigurator.registerErrorListener();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Elasticsearch elasticsearch = <span class=\"keyword\">new</span> Elasticsearch();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != ExitCodes.OK) &#123;</span><br><span class=\"line\">        exit(status);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着是 Bootstrap 类:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.Bootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">(<span class=\"keyword\">boolean</span> addShutdownHook, Environment environment)</span> <span class=\"keyword\">throws</span> BootstrapException </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// install SM after natives, shutdown hooks, etc.</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BootstrapException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是 BootstrapChecks 类:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.elasticsearch.bootstrap.BootstrapChecks</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the list of checks to execute</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> List&lt;BootstrapCheck&gt; <span class=\"title\">checks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;BootstrapCheck&gt; checks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    checks.add(<span class=\"keyword\">new</span> AllPermissionCheck());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.unmodifiableList(checks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllPermissionCheck</span> <span class=\"keyword\">implements</span> <span class=\"title\">BootstrapCheck</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> BootstrapCheckResult <span class=\"title\">check</span><span class=\"params\">(BootstrapContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAllPermissionGranted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> BootstrapCheck.BootstrapCheckResult.failure(<span class=\"string\">\"granting the all permission effectively disables security\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BootstrapCheckResult.success();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAllPermissionGranted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> sm != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            sm.checkPermission(<span class=\"keyword\">new</span> AllPermission());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> SecurityException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;<br>重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动; 尽管这个问题暂时解决了, 但总是 “不太光彩”; 如果有人知道如何通过常规方法解决 security manager 的问题, 还请不吝赐教;</p>\n<p><strong>(2) elasticsearch-analysis-ik</strong><br>这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, <a href=\"https://github.com/medcl\" target=\"_blank\" rel=\"noopener\">medcl</a> 一定会在新版本发布第一时间更新 <a href=\"https://github.com/medcl/elasticsearch-analysis-ik\" target=\"_blank\" rel=\"noopener\">elasticsearch-analysis-ik</a>, 与公司共进退;<br>安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;</p>\n<p><strong>(3) 其余插件</strong><br>在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;</p>\n<h2 id=\"监控体系\"><a href=\"#监控体系\" class=\"headerlink\" title=\"监控体系\"></a><strong>监控体系</strong></h2><h3 id=\"基于-rest-api-graphite-grafana-的方案\"><a href=\"#基于-rest-api-graphite-grafana-的方案\" class=\"headerlink\" title=\"基于 rest api + graphite + grafana 的方案\"></a><strong>基于 rest api + graphite + grafana 的方案</strong></h3><p>基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们监控 elasticsearch 集群健康状况的主力工具 (这篇文章详细介绍了 elasticsearch 各种 rest api 收集到的指标以及将其可视化的方法: <a href=\"\">使用 rest api 可视化监控 elasticsearch 集群</a>);<br>将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现 rest api 有了一些变化;<br>首先是 rest api 调用的参数的细微变化:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数</span></span><br><span class=\"line\">_nodes/stats?all=<span class=\"literal\">true</span></span><br><span class=\"line\">_stats?all=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>all 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;<br>其余的 api 在调用的路径和参数上都没有什么变化, 比较顺利;<br>然后是调用 api 返回的内容有一些细微的变化:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.4.2 的 load 指标</span></span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.load_avergae</span><br><span class=\"line\"><span class=\"comment\"># 6.2.2 的 load 指标</span></span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.1m</span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.5m</span><br><span class=\"line\"><span class=\"variable\">$node_name</span>.os.cpu.load_average.15m</span><br></pre></td></tr></table></figure></p>\n<p>6.2.2 的机器 load 指标收集, 随系统细分为了 1min, 5min 和 15min 三种, 也算是更精致了;</p>\n<h3 id=\"elastic-官方组件-x-pack\"><a href=\"#elastic-官方组件-x-pack\" class=\"headerlink\" title=\"elastic 官方组件 x-pack\"></a><strong>elastic 官方组件 x-pack</strong></h3><p>在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;<br>从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png\" alt=\"x-pack-fee-table\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-fee-table</div>\n            </figure><br>对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;<br>我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;<br>可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png\" alt=\"x-pack-monitor\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-monitor</div>\n            </figure><br>另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png\" alt=\"x-pack-search-profiler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">x-pack-search-profiler</div>\n            </figure><br>除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;<br>以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;</p>\n<h2 id=\"本文总结\"><a href=\"#本文总结\" class=\"headerlink\" title=\"本文总结\"></a><strong>本文总结</strong></h2><p>本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级到 6.2.2 的可行性与兼容性问题;<br><strong>首先是客户端兼容性问题:</strong><br>elastic 公司新推出的 <code>RestHighLevelClient</code> 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 <code>RestHighLevelClient</code> 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利; 对各业务线而言, 只有有限的 (诸如 aggregations) api 被迫需要修改, 其余的都可以延续下去;<br><strong>其次是语法兼容性问题:</strong><br>此处仍需细分为三个方面: <strong>create index</strong>, <strong>query dsl</strong> 和 <strong>search api</strong> ;<br><strong>create index</strong> 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 <code>string</code> 类型, 改而细分出两个司职更明确的类型: <code>text</code> 与 <code>keyword</code>, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;<br><strong>query dsl</strong> 方面, 对我们的影响也在控制范围之内: 只有 <code>missing</code> 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;<br><strong>search api</strong> 方面, 可能影响就比较大了: <code>scan</code> 和 <code>count</code> 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;<br><strong>然后是索引数据迁移兼容性问题:</strong><br>经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;<br><strong>接着是工具兼容性问题:</strong><br>经过不断探索与变通, 最后 <code>cerebro</code>, <code>elasticsearch-head</code>, <code>elasticfence</code>, <code>elasticsearch-analysis-ik</code>, <code>curator</code> 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 “顺利” 实现了对 6.2.2 版本的兼容;<br>这其中, <code>elasticfence</code> 实现兼容的过程比较坎坷, 甚至还重新编译了 elasticsearch 的源码才解决了 security manager 的问题; 如果以后能通过常规方式解决安全的问题, 一定还得弄回去;<br><strong>最后是监控体系兼容性问题:</strong><br>得益于 6.x 版本 rest api 对先前的延续 (除了极个别 api 有细微调整之外), 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;<br>另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;</p>\n<p>&nbsp;<br><strong>以上便是本文的全部内容;</strong></p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">apache httpclient 初始化参数设置总结</a></li>\n<li><a href=\"\">使用 rest api 可视化监控 elasticsearch 集群</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst\" target=\"_blank\" rel=\"noopener\">Changelog</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html\" target=\"_blank\" rel=\"noopener\">Removal of mapping types</a></li>\n<li><a href=\"https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests\" target=\"_blank\" rel=\"noopener\">Strict Content-Type Checking for Elasticsearch REST Requests</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html\" target=\"_blank\" rel=\"noopener\">Compatibility</a></li>\n<li><a href=\"https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients\" target=\"_blank\" rel=\"noopener\">State of the official Elasticsearch Java clients</a></li>\n<li><a href=\"http://blog.csdn.net/napoay/article/details/79135136\" target=\"_blank\" rel=\"noopener\">Elasticsearch 6 新特性与重要变更解读</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions\" target=\"_blank\" rel=\"noopener\">Help for plugin authors</a></li>\n<li><a href=\"https://elasticsearch.cn/article/338\" target=\"_blank\" rel=\"noopener\">Intellij Idea 编译 Elasticsearch 源码</a></li>\n<li><a href=\"https://github.com/elastic/elasticsearch#building-from-source\" target=\"_blank\" rel=\"noopener\">elasticsearch: Building from Source</a></li>\n<li><a href=\"https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0\" target=\"_blank\" rel=\"noopener\">Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You</a></li>\n<li><a href=\"https://www.cnblogs.com/Leo_wl/p/6181563.html\" target=\"_blank\" rel=\"noopener\">Kibana+X-Pack</a></li>\n<li><a href=\"https://www.elastic.co/subscriptions\" target=\"_blank\" rel=\"noopener\">Subscriptions that Go to Work for You</a></li>\n</ul>"},{"title":"bash 数组与映射","date":"2017-10-22T15:32:19.000Z","_content":"\n> 注: bash 映射 (map) 在文档里叫做 `关联数组 (associated array)`, 使用关联数组的最低 bash 版本是 4.1.2;\n\n<!--more-->\n\n## **数组/关联数组 的创建**\n### **静态创建**\n使用类型限定 declare 定义:\n``` bash\n# 数组\ndeclare -a array1=('a' 'b' 'c')\ndeclare -a array2=(a b c)\n# 关联数组\ndeclare -A map1=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\ndeclare -A map2=([a]=aa [b]=bb [c]=cc)\n```\n如果不带类型限定, bash 不会自动推断 关联数组 类型:\n``` bash\nobject1=(a b c)\nobject2=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\n```\n对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [\"a\"]=\"aa\", [\"b\"]=\"bb\" 与 [\"c\"]=\"cc\";\n\n### **动态创建**\n以上展示了 数组/动态数组 的静态创建方式;\n更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:\n``` bash\npair_array=(`sed -n -e '6,/}/p' -e '$d' ${formatted_curl_response_file} | awk -F ':' '{\n    log_length = length($1);\n    app_code_length = length($2);\n    log_path = substr($1, 2, log_length - 2);\n    app_code = substr($2, 2, app_code_length - 2);\n    map[log_path] = app_code\n} END {\n    for (key in map) {\n        printf (\"%10s=%10s \", key, map[key])\n    }\n}'`)\n```\n以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;\n但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;\n&nbsp;\n另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:\n``` bash\n> declare -A map=(`last -n 1 | head -n 1 | awk '{map[$1]=$3} END{for (key in map) {printf (\"[%10s]=%10s \", key, map[key])}}'`)\n# 以上语句会报如下错误:\n-bash: map: [: must use subscript when assigning associative array\n-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array\n```\n因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;\n显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;\n\n## **数组/关联数组 的使用**\n单独赋值:\n``` bash\nmap['a']='aaa'\narray[0]=aaa\n```\n获取数据:\n``` bash\n# 获得所有 values\necho ${map[@]}\necho ${array[@]}\n# 获得某个单独的值\nvar=${map['a']}\nvar=${array[0]}\n# 获得所有 keys (对于数组而言, 就是获得所有的索引下标)\nfor key in ${!map[@]}; do\n    ...\ndone\nfor key in ${!array[@]}; do\n    ...\ndone\n```\n\n## **参考链接**\n- [shell中的map使用](http://blog.csdn.net/adermxl/article/details/41145019)\n\n","source":"_posts/linux-shell--bash数组与映射.md","raw":"---\ntitle: bash 数组与映射\ndate: 2017-10-22 23:32:19\ncategories:\n  - linux\n  - shell\ntags:\n  - linux:shell\n---\n\n> 注: bash 映射 (map) 在文档里叫做 `关联数组 (associated array)`, 使用关联数组的最低 bash 版本是 4.1.2;\n\n<!--more-->\n\n## **数组/关联数组 的创建**\n### **静态创建**\n使用类型限定 declare 定义:\n``` bash\n# 数组\ndeclare -a array1=('a' 'b' 'c')\ndeclare -a array2=(a b c)\n# 关联数组\ndeclare -A map1=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\ndeclare -A map2=([a]=aa [b]=bb [c]=cc)\n```\n如果不带类型限定, bash 不会自动推断 关联数组 类型:\n``` bash\nobject1=(a b c)\nobject2=([\"a\"]=\"aa\" [\"b\"]=\"bb\" [\"c\"]=\"cc\")\n```\n对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [\"a\"]=\"aa\", [\"b\"]=\"bb\" 与 [\"c\"]=\"cc\";\n\n### **动态创建**\n以上展示了 数组/动态数组 的静态创建方式;\n更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:\n``` bash\npair_array=(`sed -n -e '6,/}/p' -e '$d' ${formatted_curl_response_file} | awk -F ':' '{\n    log_length = length($1);\n    app_code_length = length($2);\n    log_path = substr($1, 2, log_length - 2);\n    app_code = substr($2, 2, app_code_length - 2);\n    map[log_path] = app_code\n} END {\n    for (key in map) {\n        printf (\"%10s=%10s \", key, map[key])\n    }\n}'`)\n```\n以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;\n但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;\n&nbsp;\n另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:\n``` bash\n> declare -A map=(`last -n 1 | head -n 1 | awk '{map[$1]=$3} END{for (key in map) {printf (\"[%10s]=%10s \", key, map[key])}}'`)\n# 以上语句会报如下错误:\n-bash: map: [: must use subscript when assigning associative array\n-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array\n```\n因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;\n显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;\n\n## **数组/关联数组 的使用**\n单独赋值:\n``` bash\nmap['a']='aaa'\narray[0]=aaa\n```\n获取数据:\n``` bash\n# 获得所有 values\necho ${map[@]}\necho ${array[@]}\n# 获得某个单独的值\nvar=${map['a']}\nvar=${array[0]}\n# 获得所有 keys (对于数组而言, 就是获得所有的索引下标)\nfor key in ${!map[@]}; do\n    ...\ndone\nfor key in ${!array[@]}; do\n    ...\ndone\n```\n\n## **参考链接**\n- [shell中的map使用](http://blog.csdn.net/adermxl/article/details/41145019)\n\n","slug":"linux-shell--bash数组与映射","published":1,"updated":"2018-01-03T15:18:11.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5l000bj1jxoek3fwgd","content":"<blockquote>\n<p>注: bash 映射 (map) 在文档里叫做 <code>关联数组 (associated array)</code>, 使用关联数组的最低 bash 版本是 4.1.2;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"数组-关联数组-的创建\"><a href=\"#数组-关联数组-的创建\" class=\"headerlink\" title=\"数组/关联数组 的创建\"></a><strong>数组/关联数组 的创建</strong></h2><h3 id=\"静态创建\"><a href=\"#静态创建\" class=\"headerlink\" title=\"静态创建\"></a><strong>静态创建</strong></h3><p>使用类型限定 declare 定义:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array1=(<span class=\"string\">'a'</span> <span class=\"string\">'b'</span> <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array2=(a b c)</span><br><span class=\"line\"><span class=\"comment\"># 关联数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map1=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map2=([a]=aa [b]=bb [c]=cc)</span><br></pre></td></tr></table></figure></p>\n<p>如果不带类型限定, bash 不会自动推断 关联数组 类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object1=(a b c)</span><br><span class=\"line\">object2=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [“a”]=”aa”, [“b”]=”bb” 与 [“c”]=”cc”;</p>\n<h3 id=\"动态创建\"><a href=\"#动态创建\" class=\"headerlink\" title=\"动态创建\"></a><strong>动态创建</strong></h3><p>以上展示了 数组/动态数组 的静态创建方式;<br>更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_array=(`sed -n -e <span class=\"string\">'6,/&#125;/p'</span> -e <span class=\"string\">'$d'</span> <span class=\"variable\">$&#123;formatted_curl_response_file&#125;</span> | awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_length = length($1);</span></span><br><span class=\"line\"><span class=\"string\">    app_code_length = length($2);</span></span><br><span class=\"line\"><span class=\"string\">    log_path = substr($1, 2, log_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    app_code = substr($2, 2, app_code_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    map[log_path] = app_code</span></span><br><span class=\"line\"><span class=\"string\">&#125; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">    for (key in map) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf (\"%10s=%10s \", key, map[key])</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span>`)</span><br></pre></td></tr></table></figure></p>\n<p>以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;<br>但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;<br>&nbsp;<br>另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">declare</span> -A map=(`last -n 1 | head -n 1 | awk <span class=\"string\">'&#123;map[$1]=$3&#125; END&#123;for (key in map) &#123;printf (\"[%10s]=%10s \", key, map[key])&#125;&#125;'</span>`)</span><br><span class=\"line\"><span class=\"comment\"># 以上语句会报如下错误:</span></span><br><span class=\"line\">-bash: map: [: must use subscript when assigning associative array</span><br><span class=\"line\">-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array</span><br></pre></td></tr></table></figure></p>\n<p>因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;<br>显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;</p>\n<h2 id=\"数组-关联数组-的使用\"><a href=\"#数组-关联数组-的使用\" class=\"headerlink\" title=\"数组/关联数组 的使用\"></a><strong>数组/关联数组 的使用</strong></h2><p>单独赋值:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[<span class=\"string\">'a'</span>]=<span class=\"string\">'aaa'</span></span><br><span class=\"line\">array[0]=aaa</span><br></pre></td></tr></table></figure></p>\n<p>获取数据:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获得所有 values</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;map[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[@]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得某个单独的值</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;map['a']&#125;</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得所有 keys (对于数组而言, 就是获得所有的索引下标)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!map[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!array[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/adermxl/article/details/41145019\" target=\"_blank\" rel=\"noopener\">shell中的map使用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>注: bash 映射 (map) 在文档里叫做 <code>关联数组 (associated array)</code>, 使用关联数组的最低 bash 版本是 4.1.2;</p>\n</blockquote>","more":"<h2 id=\"数组-关联数组-的创建\"><a href=\"#数组-关联数组-的创建\" class=\"headerlink\" title=\"数组/关联数组 的创建\"></a><strong>数组/关联数组 的创建</strong></h2><h3 id=\"静态创建\"><a href=\"#静态创建\" class=\"headerlink\" title=\"静态创建\"></a><strong>静态创建</strong></h3><p>使用类型限定 declare 定义:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array1=(<span class=\"string\">'a'</span> <span class=\"string\">'b'</span> <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a array2=(a b c)</span><br><span class=\"line\"><span class=\"comment\"># 关联数组</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map1=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">declare</span> -A map2=([a]=aa [b]=bb [c]=cc)</span><br></pre></td></tr></table></figure></p>\n<p>如果不带类型限定, bash 不会自动推断 关联数组 类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object1=(a b c)</span><br><span class=\"line\">object2=([<span class=\"string\">\"a\"</span>]=<span class=\"string\">\"aa\"</span> [<span class=\"string\">\"b\"</span>]=<span class=\"string\">\"bb\"</span> [<span class=\"string\">\"c\"</span>]=<span class=\"string\">\"cc\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于以上两者, bash 都将推断为 普通数组 类型, 其中 object2 中有三个 string 元素: [“a”]=”aa”, [“b”]=”bb” 与 [“c”]=”cc”;</p>\n<h3 id=\"动态创建\"><a href=\"#动态创建\" class=\"headerlink\" title=\"动态创建\"></a><strong>动态创建</strong></h3><p>以上展示了 数组/动态数组 的静态创建方式;<br>更复杂的场景是, 由一段其他复杂命令的输出, 赋值构建一个数组类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_array=(`sed -n -e <span class=\"string\">'6,/&#125;/p'</span> -e <span class=\"string\">'$d'</span> <span class=\"variable\">$&#123;formatted_curl_response_file&#125;</span> | awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_length = length($1);</span></span><br><span class=\"line\"><span class=\"string\">    app_code_length = length($2);</span></span><br><span class=\"line\"><span class=\"string\">    log_path = substr($1, 2, log_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    app_code = substr($2, 2, app_code_length - 2);</span></span><br><span class=\"line\"><span class=\"string\">    map[log_path] = app_code</span></span><br><span class=\"line\"><span class=\"string\">&#125; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">    for (key in map) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf (\"%10s=%10s \", key, map[key])</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span>`)</span><br></pre></td></tr></table></figure></p>\n<p>以上逻辑, 由 sed 与 awk 两重管道输出目标内容, 作为创建数组的参数, 以达到动态创建的目的;<br>但是, 以上方式只适用于创建 数组, 而不适用于创建 关联数组, 原因与上一节 静态创建数组 中所表述的相同: 即使输出格式符合定义规范, bash 并不会自动推断为 关联数组;<br>&nbsp;<br>另外, 企图通过 declare 强制限定类型去动态创建, 也是不合法的:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">declare</span> -A map=(`last -n 1 | head -n 1 | awk <span class=\"string\">'&#123;map[$1]=$3&#125; END&#123;for (key in map) &#123;printf (\"[%10s]=%10s \", key, map[key])&#125;&#125;'</span>`)</span><br><span class=\"line\"><span class=\"comment\"># 以上语句会报如下错误:</span></span><br><span class=\"line\">-bash: map: [: must use subscript when assigning associative array</span><br><span class=\"line\">-bash: map: zshell.z]=113.44.125.146: must use subscript when assigning associative array</span><br></pre></td></tr></table></figure></p>\n<p>因为, 通过 ``, $() 等命令代换, [zshell.z]=113.44.125.146 这样的输出内容被当作命令执行, 而 [ 这是一个 bash 的内置命令, 用于条件判断;<br>显然 zshell.z]=113.44.125.146 这样的语句是不符合条件判断的参数输入的;</p>\n<h2 id=\"数组-关联数组-的使用\"><a href=\"#数组-关联数组-的使用\" class=\"headerlink\" title=\"数组/关联数组 的使用\"></a><strong>数组/关联数组 的使用</strong></h2><p>单独赋值:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[<span class=\"string\">'a'</span>]=<span class=\"string\">'aaa'</span></span><br><span class=\"line\">array[0]=aaa</span><br></pre></td></tr></table></figure></p>\n<p>获取数据:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获得所有 values</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;map[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[@]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得某个单独的值</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;map['a']&#125;</span></span><br><span class=\"line\">var=<span class=\"variable\">$&#123;array[0]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 获得所有 keys (对于数组而言, 就是获得所有的索引下标)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!map[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;!array[@]&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/adermxl/article/details/41145019\" target=\"_blank\" rel=\"noopener\">shell中的map使用</a></li>\n</ul>"},{"title":"lsof 札记","date":"2017-01-06T07:17:04.000Z","_content":"\n> 第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: [netstat/ss 使用对比]() );\n使用之后, 发现 lsof 被人称为 `神器`, 还是有一定道理的; 在任何资源都被抽象为 `文件` 的 linux 中, 一个面向 `文件` 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;\n本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;\n\n<!--more-->\n\n------\n\n## **lsof 命令的输出结构**\n``` bash\n# COMMAND   启动进程的命令\n# PID       进程号\n# TID       线程号\n# USER      用户\n# FD        文件描述符\n# TYPE      文件类型\n# DEVICE    磁盘名称\n# SIZE      文件大小\n# NODE      inode 号\n# NAME      文件资源的名称\n> sudo lsof | head -n 2\nCOMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME\nsystemd       1            root  cwd       DIR              253,1        4096        128 /\n```\n\n### **各字段的不同输出含义**\nFD: 文件描述符 file description\n``` bash\n# 任何进程都必须有的\n0:      标准输入流\n1:      标准输出流\n2:      标准错误流\n\n# 几种特殊的保留 fd\ncwd:    current work directory, 应用程序启动的目录\ntxt:    二进制可执行文件或共享库\nrtd:    root directory, 根目录\nmem:    memory mapped file, 内存映射文件\nmmap:   memory-mapped device, 内存映射设备\n\n# 整数后面跟着的字母\nu:      可读可写模式\nr:      只读模式\nw:      只写模式\n```\nTYPE: 文件类型\n``` bash\nDIR:    目录文件\nREG:    普通文件\nCHR:    char, 字符设备文件\nBLK:    block, 块设备文件\nIPV4:   ipv4 socket 套接字文件\nIPV6:   ipv6 socket 套接字文件\n```\nDEVICE:\n``` bash\ntodo\n```\nSIZE: 文件大小\n``` bash\n# 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size\n0t0:    套接字文件的默认占位\n```\n&nbsp;\n## **lsof 的日常应用**\n### **lsof 网络 相关的应用**\n``` bash\n# 显示所有网络连接\nsudo lsof -i\n# 只显示 ipv6 的连接\nsudo lsof -i 6\n# 只显示 tcp 协议的连接\nsudo lsof -i TCP\n# 指定端口号\nsudo lsof -i:port\n# 指定主机(与端口)\nsudo lsof -i@l-tracer15.tc.cn2.xx.com:9999\n```\n\n### **lsof 用户 相关的应用**\n``` bash\n# 显示某用户所打开的文件\nsudo lsof -u zshell.zhang\nsudo lsof -u ^zshell.zhang (排除此用户)\n```\n\n### **lsof 命令/进程 相关的应用**\n``` bash\n# 只显示 pid\nsudo lsof -t\n# 只显示指定的命令打开的文件\nsudo lsof -c nginx\n# 只显示指定 pid 的进程打开的文件\nsudo lsof -p pid\n```\n\n### **lsof 文件/目录 相关的应用**\n``` bash\n# 搜索与指定路径相关的一切资源(user, process 等)\nsudo lsof /target_path\n# +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)\nsudo lsof +d /target_path\nsudo lsof +D /target_path\n```\n\n### **lsof 的选项组合及实践技巧**\n上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;\nlsof 与(and) 的逻辑运算关系如下:\n``` bash\n# 使用 -a 达到 与(and) 的效果\n# 必须同时满足三个条件: \n#   1. 是用户 zshell.zhang 启动的进程;\n#   2. 是套接字文件, 且连接的主机是 10.64.4.11;\n#   3. 该进程命令是 java;\nsudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java\n```\nlsof 常用的组合及实践:\n``` bash\n# 寻找已删除但未释放文件句柄的幽灵文件\nsudo lsof | grep deleted\n# 杀死所有匹配一定文件打开条件的进程\nsudo kill `sudo lsof -t -c java` # 杀死所有 java 进程\nsudo kill `sudo lsof -t -u zshell.zhang` # 杀死所有 zshell.zhang 的用户进程\n# 恢复删除的文件\n# 找到误删文件被什么进程持有, 获得 pid 和 fd\n1. sudo lsof /target_deleted_file\n# /proc/{pid}/fd/{fd_num} 的内容即为误删内容, 重定向到误删文件中即可\n2. cat /proc/{pid}/fd/{fd_num} > /target_deleted_file\n```\n另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/);\n\n## **站内相关文章**\n- [netstat/ss 使用对比]()\n- [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/)\n\n## **参考链接**\n- [linux lsof详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n- [每天一个Linux命令（45）lsof命令](http://www.cnblogs.com/MenAngel/p/5575479.html)\n- [Linux 命令神器: lsof 入门](https://linux.cn/article-4099-1.html)\n- [what-does-the-fd-column-of-pipes-listed-by-lsof-mean](https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean)\n\n","source":"_posts/linux-other--lsof札记.md","raw":"---\ntitle: lsof 札记\ndate: 2017-01-06 15:17:04\ncategories:\n  - linux\n  - other\ntags:\n  - linux:net\n  - linux:disk\n---\n\n> 第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: [netstat/ss 使用对比]() );\n使用之后, 发现 lsof 被人称为 `神器`, 还是有一定道理的; 在任何资源都被抽象为 `文件` 的 linux 中, 一个面向 `文件` 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;\n本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;\n\n<!--more-->\n\n------\n\n## **lsof 命令的输出结构**\n``` bash\n# COMMAND   启动进程的命令\n# PID       进程号\n# TID       线程号\n# USER      用户\n# FD        文件描述符\n# TYPE      文件类型\n# DEVICE    磁盘名称\n# SIZE      文件大小\n# NODE      inode 号\n# NAME      文件资源的名称\n> sudo lsof | head -n 2\nCOMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME\nsystemd       1            root  cwd       DIR              253,1        4096        128 /\n```\n\n### **各字段的不同输出含义**\nFD: 文件描述符 file description\n``` bash\n# 任何进程都必须有的\n0:      标准输入流\n1:      标准输出流\n2:      标准错误流\n\n# 几种特殊的保留 fd\ncwd:    current work directory, 应用程序启动的目录\ntxt:    二进制可执行文件或共享库\nrtd:    root directory, 根目录\nmem:    memory mapped file, 内存映射文件\nmmap:   memory-mapped device, 内存映射设备\n\n# 整数后面跟着的字母\nu:      可读可写模式\nr:      只读模式\nw:      只写模式\n```\nTYPE: 文件类型\n``` bash\nDIR:    目录文件\nREG:    普通文件\nCHR:    char, 字符设备文件\nBLK:    block, 块设备文件\nIPV4:   ipv4 socket 套接字文件\nIPV6:   ipv6 socket 套接字文件\n```\nDEVICE:\n``` bash\ntodo\n```\nSIZE: 文件大小\n``` bash\n# 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size\n0t0:    套接字文件的默认占位\n```\n&nbsp;\n## **lsof 的日常应用**\n### **lsof 网络 相关的应用**\n``` bash\n# 显示所有网络连接\nsudo lsof -i\n# 只显示 ipv6 的连接\nsudo lsof -i 6\n# 只显示 tcp 协议的连接\nsudo lsof -i TCP\n# 指定端口号\nsudo lsof -i:port\n# 指定主机(与端口)\nsudo lsof -i@l-tracer15.tc.cn2.xx.com:9999\n```\n\n### **lsof 用户 相关的应用**\n``` bash\n# 显示某用户所打开的文件\nsudo lsof -u zshell.zhang\nsudo lsof -u ^zshell.zhang (排除此用户)\n```\n\n### **lsof 命令/进程 相关的应用**\n``` bash\n# 只显示 pid\nsudo lsof -t\n# 只显示指定的命令打开的文件\nsudo lsof -c nginx\n# 只显示指定 pid 的进程打开的文件\nsudo lsof -p pid\n```\n\n### **lsof 文件/目录 相关的应用**\n``` bash\n# 搜索与指定路径相关的一切资源(user, process 等)\nsudo lsof /target_path\n# +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)\nsudo lsof +d /target_path\nsudo lsof +D /target_path\n```\n\n### **lsof 的选项组合及实践技巧**\n上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;\nlsof 与(and) 的逻辑运算关系如下:\n``` bash\n# 使用 -a 达到 与(and) 的效果\n# 必须同时满足三个条件: \n#   1. 是用户 zshell.zhang 启动的进程;\n#   2. 是套接字文件, 且连接的主机是 10.64.4.11;\n#   3. 该进程命令是 java;\nsudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java\n```\nlsof 常用的组合及实践:\n``` bash\n# 寻找已删除但未释放文件句柄的幽灵文件\nsudo lsof | grep deleted\n# 杀死所有匹配一定文件打开条件的进程\nsudo kill `sudo lsof -t -c java` # 杀死所有 java 进程\nsudo kill `sudo lsof -t -u zshell.zhang` # 杀死所有 zshell.zhang 的用户进程\n# 恢复删除的文件\n# 找到误删文件被什么进程持有, 获得 pid 和 fd\n1. sudo lsof /target_deleted_file\n# /proc/{pid}/fd/{fd_num} 的内容即为误删内容, 重定向到误删文件中即可\n2. cat /proc/{pid}/fd/{fd_num} > /target_deleted_file\n```\n另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/);\n\n## **站内相关文章**\n- [netstat/ss 使用对比]()\n- [du / df 使用及其区别](https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/)\n\n## **参考链接**\n- [linux lsof详解](http://blog.csdn.net/guoguo1980/article/details/2324454)\n- [每天一个Linux命令（45）lsof命令](http://www.cnblogs.com/MenAngel/p/5575479.html)\n- [Linux 命令神器: lsof 入门](https://linux.cn/article-4099-1.html)\n- [what-does-the-fd-column-of-pipes-listed-by-lsof-mean](https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean)\n\n","slug":"linux-other--lsof札记","published":1,"updated":"2018-01-20T13:26:42.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5n000cj1jx31txzd10","content":"<blockquote>\n<p>第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: <a href=\"\">netstat/ss 使用对比</a> );<br>使用之后, 发现 lsof 被人称为 <code>神器</code>, 还是有一定道理的; 在任何资源都被抽象为 <code>文件</code> 的 linux 中, 一个面向 <code>文件</code> 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;<br>本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"lsof-命令的输出结构\"><a href=\"#lsof-命令的输出结构\" class=\"headerlink\" title=\"lsof 命令的输出结构\"></a><strong>lsof 命令的输出结构</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># COMMAND   启动进程的命令</span></span><br><span class=\"line\"><span class=\"comment\"># PID       进程号</span></span><br><span class=\"line\"><span class=\"comment\"># TID       线程号</span></span><br><span class=\"line\"><span class=\"comment\"># USER      用户</span></span><br><span class=\"line\"><span class=\"comment\"># FD        文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"># TYPE      文件类型</span></span><br><span class=\"line\"><span class=\"comment\"># DEVICE    磁盘名称</span></span><br><span class=\"line\"><span class=\"comment\"># SIZE      文件大小</span></span><br><span class=\"line\"><span class=\"comment\"># NODE      inode 号</span></span><br><span class=\"line\"><span class=\"comment\"># NAME      文件资源的名称</span></span><br><span class=\"line\">&gt; sudo lsof | head -n 2</span><br><span class=\"line\">COMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class=\"line\">systemd       1            root  cwd       DIR              253,1        4096        128 /</span><br></pre></td></tr></table></figure>\n<h3 id=\"各字段的不同输出含义\"><a href=\"#各字段的不同输出含义\" class=\"headerlink\" title=\"各字段的不同输出含义\"></a><strong>各字段的不同输出含义</strong></h3><p>FD: 文件描述符 file description<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任何进程都必须有的</span></span><br><span class=\"line\">0:      标准输入流</span><br><span class=\"line\">1:      标准输出流</span><br><span class=\"line\">2:      标准错误流</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 几种特殊的保留 fd</span></span><br><span class=\"line\">cwd:    current work directory, 应用程序启动的目录</span><br><span class=\"line\">txt:    二进制可执行文件或共享库</span><br><span class=\"line\">rtd:    root directory, 根目录</span><br><span class=\"line\">mem:    memory mapped file, 内存映射文件</span><br><span class=\"line\">mmap:   memory-mapped device, 内存映射设备</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整数后面跟着的字母</span></span><br><span class=\"line\">u:      可读可写模式</span><br><span class=\"line\">r:      只读模式</span><br><span class=\"line\">w:      只写模式</span><br></pre></td></tr></table></figure></p>\n<p>TYPE: 文件类型<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DIR:    目录文件</span><br><span class=\"line\">REG:    普通文件</span><br><span class=\"line\">CHR:    char, 字符设备文件</span><br><span class=\"line\">BLK:    block, 块设备文件</span><br><span class=\"line\">IPV4:   ipv4 socket 套接字文件</span><br><span class=\"line\">IPV6:   ipv6 socket 套接字文件</span><br></pre></td></tr></table></figure></p>\n<p>DEVICE:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todo</span><br></pre></td></tr></table></figure></p>\n<p>SIZE: 文件大小<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size</span></span><br><span class=\"line\">0t0:    套接字文件的默认占位</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h2 id=\"lsof-的日常应用\"><a href=\"#lsof-的日常应用\" class=\"headerlink\" title=\"lsof 的日常应用\"></a><strong>lsof 的日常应用</strong></h2><h3 id=\"lsof-网络-相关的应用\"><a href=\"#lsof-网络-相关的应用\" class=\"headerlink\" title=\"lsof 网络 相关的应用\"></a><strong>lsof 网络 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有网络连接</span></span><br><span class=\"line\">sudo lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 只显示 ipv6 的连接</span></span><br><span class=\"line\">sudo lsof -i 6</span><br><span class=\"line\"><span class=\"comment\"># 只显示 tcp 协议的连接</span></span><br><span class=\"line\">sudo lsof -i TCP</span><br><span class=\"line\"><span class=\"comment\"># 指定端口号</span></span><br><span class=\"line\">sudo lsof -i:port</span><br><span class=\"line\"><span class=\"comment\"># 指定主机(与端口)</span></span><br><span class=\"line\">sudo lsof -i@l-tracer15.tc.cn2.xx.com:9999</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-用户-相关的应用\"><a href=\"#lsof-用户-相关的应用\" class=\"headerlink\" title=\"lsof 用户 相关的应用\"></a><strong>lsof 用户 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某用户所打开的文件</span></span><br><span class=\"line\">sudo lsof -u zshell.zhang</span><br><span class=\"line\">sudo lsof -u ^zshell.zhang (排除此用户)</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-命令-进程-相关的应用\"><a href=\"#lsof-命令-进程-相关的应用\" class=\"headerlink\" title=\"lsof 命令/进程 相关的应用\"></a><strong>lsof 命令/进程 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只显示 pid</span></span><br><span class=\"line\">sudo lsof -t</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定的命令打开的文件</span></span><br><span class=\"line\">sudo lsof -c nginx</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定 pid 的进程打开的文件</span></span><br><span class=\"line\">sudo lsof -p pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-文件-目录-相关的应用\"><a href=\"#lsof-文件-目录-相关的应用\" class=\"headerlink\" title=\"lsof 文件/目录 相关的应用\"></a><strong>lsof 文件/目录 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索与指定路径相关的一切资源(user, process 等)</span></span><br><span class=\"line\">sudo lsof /target_path</span><br><span class=\"line\"><span class=\"comment\"># +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)</span></span><br><span class=\"line\">sudo lsof +d /target_path</span><br><span class=\"line\">sudo lsof +D /target_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-的选项组合及实践技巧\"><a href=\"#lsof-的选项组合及实践技巧\" class=\"headerlink\" title=\"lsof 的选项组合及实践技巧\"></a><strong>lsof 的选项组合及实践技巧</strong></h3><p>上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;<br>lsof 与(and) 的逻辑运算关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 -a 达到 与(and) 的效果</span></span><br><span class=\"line\"><span class=\"comment\"># 必须同时满足三个条件: </span></span><br><span class=\"line\"><span class=\"comment\">#   1. 是用户 zshell.zhang 启动的进程;</span></span><br><span class=\"line\"><span class=\"comment\">#   2. 是套接字文件, 且连接的主机是 10.64.4.11;</span></span><br><span class=\"line\"><span class=\"comment\">#   3. 该进程命令是 java;</span></span><br><span class=\"line\">sudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java</span><br></pre></td></tr></table></figure></p>\n<p>lsof 常用的组合及实践:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 寻找已删除但未释放文件句柄的幽灵文件</span></span><br><span class=\"line\">sudo lsof | grep deleted</span><br><span class=\"line\"><span class=\"comment\"># 杀死所有匹配一定文件打开条件的进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -c java` <span class=\"comment\"># 杀死所有 java 进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -u zshell.zhang` <span class=\"comment\"># 杀死所有 zshell.zhang 的用户进程</span></span><br><span class=\"line\"><span class=\"comment\"># 恢复删除的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 找到误删文件被什么进程持有, 获得 pid 和 fd</span></span><br><span class=\"line\">1. sudo lsof /target_deleted_file</span><br><span class=\"line\"><span class=\"comment\"># /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; 的内容即为误删内容, 重定向到误删文件中即可</span></span><br><span class=\"line\">2. cat /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; &gt; /target_deleted_file</span><br></pre></td></tr></table></figure></p>\n<p>另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: <a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\" target=\"_blank\" rel=\"noopener\">du / df 使用及其区别</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">netstat/ss 使用对比</a></li>\n<li><a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\" target=\"_blank\" rel=\"noopener\">du / df 使用及其区别</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof详解</a></li>\n<li><a href=\"http://www.cnblogs.com/MenAngel/p/5575479.html\" target=\"_blank\" rel=\"noopener\">每天一个Linux命令（45）lsof命令</a></li>\n<li><a href=\"https://linux.cn/article-4099-1.html\" target=\"_blank\" rel=\"noopener\">Linux 命令神器: lsof 入门</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean\" target=\"_blank\" rel=\"noopener\">what-does-the-fd-column-of-pipes-listed-by-lsof-mean</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>第一次接触到 lsof 命令, 是因为偶然间发现 netstat 命令已经落伍了(与此同时, 还发现了 ss 命令, 详见另一篇文章: <a href=\"\">netstat/ss 使用对比</a> );<br>使用之后, 发现 lsof 被人称为 <code>神器</code>, 还是有一定道理的; 在任何资源都被抽象为 <code>文件</code> 的 linux 中, 一个面向 <code>文件</code> 的管理工具, 自然辖域辽阔, 神通广大, 再加上与其他命令的巧妙组合, 更如虎添翼, 在工作实践中独当一面;<br>本文参考了一些实用资料, 结合自己的经验, 对 lsof 命令的使用略作整理;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"lsof-命令的输出结构\"><a href=\"#lsof-命令的输出结构\" class=\"headerlink\" title=\"lsof 命令的输出结构\"></a><strong>lsof 命令的输出结构</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># COMMAND   启动进程的命令</span></span><br><span class=\"line\"><span class=\"comment\"># PID       进程号</span></span><br><span class=\"line\"><span class=\"comment\"># TID       线程号</span></span><br><span class=\"line\"><span class=\"comment\"># USER      用户</span></span><br><span class=\"line\"><span class=\"comment\"># FD        文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"># TYPE      文件类型</span></span><br><span class=\"line\"><span class=\"comment\"># DEVICE    磁盘名称</span></span><br><span class=\"line\"><span class=\"comment\"># SIZE      文件大小</span></span><br><span class=\"line\"><span class=\"comment\"># NODE      inode 号</span></span><br><span class=\"line\"><span class=\"comment\"># NAME      文件资源的名称</span></span><br><span class=\"line\">&gt; sudo lsof | head -n 2</span><br><span class=\"line\">COMMAND     PID   TID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class=\"line\">systemd       1            root  cwd       DIR              253,1        4096        128 /</span><br></pre></td></tr></table></figure>\n<h3 id=\"各字段的不同输出含义\"><a href=\"#各字段的不同输出含义\" class=\"headerlink\" title=\"各字段的不同输出含义\"></a><strong>各字段的不同输出含义</strong></h3><p>FD: 文件描述符 file description<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任何进程都必须有的</span></span><br><span class=\"line\">0:      标准输入流</span><br><span class=\"line\">1:      标准输出流</span><br><span class=\"line\">2:      标准错误流</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 几种特殊的保留 fd</span></span><br><span class=\"line\">cwd:    current work directory, 应用程序启动的目录</span><br><span class=\"line\">txt:    二进制可执行文件或共享库</span><br><span class=\"line\">rtd:    root directory, 根目录</span><br><span class=\"line\">mem:    memory mapped file, 内存映射文件</span><br><span class=\"line\">mmap:   memory-mapped device, 内存映射设备</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 整数后面跟着的字母</span></span><br><span class=\"line\">u:      可读可写模式</span><br><span class=\"line\">r:      只读模式</span><br><span class=\"line\">w:      只写模式</span><br></pre></td></tr></table></figure></p>\n<p>TYPE: 文件类型<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DIR:    目录文件</span><br><span class=\"line\">REG:    普通文件</span><br><span class=\"line\">CHR:    char, 字符设备文件</span><br><span class=\"line\">BLK:    block, 块设备文件</span><br><span class=\"line\">IPV4:   ipv4 socket 套接字文件</span><br><span class=\"line\">IPV6:   ipv6 socket 套接字文件</span><br></pre></td></tr></table></figure></p>\n<p>DEVICE:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todo</span><br></pre></td></tr></table></figure></p>\n<p>SIZE: 文件大小<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 套接字文件的文件大小比较特殊, 其没有大小, 用特殊字符占位, 其余则正常显示 size</span></span><br><span class=\"line\">0t0:    套接字文件的默认占位</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h2 id=\"lsof-的日常应用\"><a href=\"#lsof-的日常应用\" class=\"headerlink\" title=\"lsof 的日常应用\"></a><strong>lsof 的日常应用</strong></h2><h3 id=\"lsof-网络-相关的应用\"><a href=\"#lsof-网络-相关的应用\" class=\"headerlink\" title=\"lsof 网络 相关的应用\"></a><strong>lsof 网络 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示所有网络连接</span></span><br><span class=\"line\">sudo lsof -i</span><br><span class=\"line\"><span class=\"comment\"># 只显示 ipv6 的连接</span></span><br><span class=\"line\">sudo lsof -i 6</span><br><span class=\"line\"><span class=\"comment\"># 只显示 tcp 协议的连接</span></span><br><span class=\"line\">sudo lsof -i TCP</span><br><span class=\"line\"><span class=\"comment\"># 指定端口号</span></span><br><span class=\"line\">sudo lsof -i:port</span><br><span class=\"line\"><span class=\"comment\"># 指定主机(与端口)</span></span><br><span class=\"line\">sudo lsof -i@l-tracer15.tc.cn2.xx.com:9999</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-用户-相关的应用\"><a href=\"#lsof-用户-相关的应用\" class=\"headerlink\" title=\"lsof 用户 相关的应用\"></a><strong>lsof 用户 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示某用户所打开的文件</span></span><br><span class=\"line\">sudo lsof -u zshell.zhang</span><br><span class=\"line\">sudo lsof -u ^zshell.zhang (排除此用户)</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-命令-进程-相关的应用\"><a href=\"#lsof-命令-进程-相关的应用\" class=\"headerlink\" title=\"lsof 命令/进程 相关的应用\"></a><strong>lsof 命令/进程 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 只显示 pid</span></span><br><span class=\"line\">sudo lsof -t</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定的命令打开的文件</span></span><br><span class=\"line\">sudo lsof -c nginx</span><br><span class=\"line\"><span class=\"comment\"># 只显示指定 pid 的进程打开的文件</span></span><br><span class=\"line\">sudo lsof -p pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-文件-目录-相关的应用\"><a href=\"#lsof-文件-目录-相关的应用\" class=\"headerlink\" title=\"lsof 文件/目录 相关的应用\"></a><strong>lsof 文件/目录 相关的应用</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索与指定路径相关的一切资源(user, process 等)</span></span><br><span class=\"line\">sudo lsof /target_path</span><br><span class=\"line\"><span class=\"comment\"># +d: 搜索与指定的一级目录下所有的文件相关的一切资源; +D: 递归操作(往下所有层级目录)</span></span><br><span class=\"line\">sudo lsof +d /target_path</span><br><span class=\"line\">sudo lsof +D /target_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"lsof-的选项组合及实践技巧\"><a href=\"#lsof-的选项组合及实践技巧\" class=\"headerlink\" title=\"lsof 的选项组合及实践技巧\"></a><strong>lsof 的选项组合及实践技巧</strong></h3><p>上述的 lsof 操作, 对于多种选项的组合, 其默认是 或(or) 的关系, 即满足其中之一便会打印出来;<br>lsof 与(and) 的逻辑运算关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 -a 达到 与(and) 的效果</span></span><br><span class=\"line\"><span class=\"comment\"># 必须同时满足三个条件: </span></span><br><span class=\"line\"><span class=\"comment\">#   1. 是用户 zshell.zhang 启动的进程;</span></span><br><span class=\"line\"><span class=\"comment\">#   2. 是套接字文件, 且连接的主机是 10.64.4.11;</span></span><br><span class=\"line\"><span class=\"comment\">#   3. 该进程命令是 java;</span></span><br><span class=\"line\">sudo lsof -a -u zshell.zhang -i@10.64.4.11 -c java</span><br></pre></td></tr></table></figure></p>\n<p>lsof 常用的组合及实践:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 寻找已删除但未释放文件句柄的幽灵文件</span></span><br><span class=\"line\">sudo lsof | grep deleted</span><br><span class=\"line\"><span class=\"comment\"># 杀死所有匹配一定文件打开条件的进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -c java` <span class=\"comment\"># 杀死所有 java 进程</span></span><br><span class=\"line\">sudo <span class=\"built_in\">kill</span> `sudo lsof -t -u zshell.zhang` <span class=\"comment\"># 杀死所有 zshell.zhang 的用户进程</span></span><br><span class=\"line\"><span class=\"comment\"># 恢复删除的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 找到误删文件被什么进程持有, 获得 pid 和 fd</span></span><br><span class=\"line\">1. sudo lsof /target_deleted_file</span><br><span class=\"line\"><span class=\"comment\"># /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; 的内容即为误删内容, 重定向到误删文件中即可</span></span><br><span class=\"line\">2. cat /proc/&#123;pid&#125;/fd/&#123;fd_num&#125; &gt; /target_deleted_file</span><br></pre></td></tr></table></figure></p>\n<p>另外, lsof 还可以被运用于找出系统中的幽灵文件, 详见: <a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\" target=\"_blank\" rel=\"noopener\">du / df 使用及其区别</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">netstat/ss 使用对比</a></li>\n<li><a href=\"https://zshell-zhang.github.io/2017/04/07/linux-other--du,df使用及其区别/\" target=\"_blank\" rel=\"noopener\">du / df 使用及其区别</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://blog.csdn.net/guoguo1980/article/details/2324454\" target=\"_blank\" rel=\"noopener\">linux lsof详解</a></li>\n<li><a href=\"http://www.cnblogs.com/MenAngel/p/5575479.html\" target=\"_blank\" rel=\"noopener\">每天一个Linux命令（45）lsof命令</a></li>\n<li><a href=\"https://linux.cn/article-4099-1.html\" target=\"_blank\" rel=\"noopener\">Linux 命令神器: lsof 入门</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25140730/what-does-the-fd-column-of-pipes-listed-by-lsof-mean\" target=\"_blank\" rel=\"noopener\">what-does-the-fd-column-of-pipes-listed-by-lsof-mean</a></li>\n</ul>"},{"title":"cli 控制字符","date":"2016-11-17T13:11:33.000Z","_content":"\n> cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;\n另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: [linux signals 总体认识](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/);\n本文总结一些常用的 cli 控制字符的使用及技巧;\n\n<!--more-->\n\n------\n\n### **简单的 cli 控制字符**\n``` bash\n# 发送 SIGINT 中断信号\nctrl + c\n# 清屏\nctrl + l\n# reverse-i-search 搜索历史命令\nctrl + r\n# 从机器上 logout\nctrl + d\n# 暂停控制台标准输出 / 恢复控制台标准输出\nctrl + s / ctrl + q\n# 发送 SIGQUIT 信号给前台进程, 并生成 core dump\nctrl + /\n# 向前删除到第一个空格\nctrl + w\n# 向后删除到第一个空格\n alt + d\n# 向后删除所有的内容\nctrl + k\n# 撤销上一步操作\nctrl + ?\n# 光标快速跃进\nctrl + 方向键\n# 补全命令/文件\ntab\n```\n\n### **与其他命令组合的 cli 控制字符 **\n``` bash\n# 发送 SIGTSTP 信号, 挂起前台进程\nctrl + z\n# ctrl + z 的输出\n[1]+  Stopped                 sudo vim /etc/profile\n```\n此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;\n接下来可以有以下配套操作:\n``` bash\n# 查看后台任务\n> jobs\n[1]+  Stopped                 sudo vim /etc/profile\n# 查看后台任务的 pid\njobs -p\n\n# 将后台作业 1 恢复到前台\nfg 1\nfg %1\n# 将后台作业 1 恢复到后台\nbg 1\nbg %1\n```\n要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:\n``` bash\nkill -9 %1\nkill -9 `jobs -p`\n```\n还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:\n``` bash\n# 当任务被唤醒, 将接收到 SIGTERM 信号并终止\nkill %1 && fg\nkill %1 && bg\nkill `jobs -p` && bg\nkill `jobs -p` && fg\n```\n\n### **控制字符的管理与设置**\n``` bash\n# 打印所有控制字符的设置 (--all)\n> stty -a\nspeed 38400 baud; rows 60; columns 211; line = 0;\nintr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;\n-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr\n-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8\nopost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke\n```\n\n### **参考链接**\n- [Bg, Fg, &, Ctrl-Z – 5 Examples to Manage Unix Background Jobs](http://www.thegeekstuff.com/2010/05/unix-background-job/)\n- [Linux中 ctrl-c, ctrl-z, ctrl-d 区别](http://blog.csdn.net/mylizh/article/details/38385739)\n\n","source":"_posts/linux-other--cli控制字符.md","raw":"---\ntitle: cli 控制字符\ndate: 2016-11-17 21:11:33\ncategories:\n - linux\n - other\ntags:\n - cheat sheet\n---\n\n> cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;\n另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: [linux signals 总体认识](https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/);\n本文总结一些常用的 cli 控制字符的使用及技巧;\n\n<!--more-->\n\n------\n\n### **简单的 cli 控制字符**\n``` bash\n# 发送 SIGINT 中断信号\nctrl + c\n# 清屏\nctrl + l\n# reverse-i-search 搜索历史命令\nctrl + r\n# 从机器上 logout\nctrl + d\n# 暂停控制台标准输出 / 恢复控制台标准输出\nctrl + s / ctrl + q\n# 发送 SIGQUIT 信号给前台进程, 并生成 core dump\nctrl + /\n# 向前删除到第一个空格\nctrl + w\n# 向后删除到第一个空格\n alt + d\n# 向后删除所有的内容\nctrl + k\n# 撤销上一步操作\nctrl + ?\n# 光标快速跃进\nctrl + 方向键\n# 补全命令/文件\ntab\n```\n\n### **与其他命令组合的 cli 控制字符 **\n``` bash\n# 发送 SIGTSTP 信号, 挂起前台进程\nctrl + z\n# ctrl + z 的输出\n[1]+  Stopped                 sudo vim /etc/profile\n```\n此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;\n接下来可以有以下配套操作:\n``` bash\n# 查看后台任务\n> jobs\n[1]+  Stopped                 sudo vim /etc/profile\n# 查看后台任务的 pid\njobs -p\n\n# 将后台作业 1 恢复到前台\nfg 1\nfg %1\n# 将后台作业 1 恢复到后台\nbg 1\nbg %1\n```\n要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:\n``` bash\nkill -9 %1\nkill -9 `jobs -p`\n```\n还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:\n``` bash\n# 当任务被唤醒, 将接收到 SIGTERM 信号并终止\nkill %1 && fg\nkill %1 && bg\nkill `jobs -p` && bg\nkill `jobs -p` && fg\n```\n\n### **控制字符的管理与设置**\n``` bash\n# 打印所有控制字符的设置 (--all)\n> stty -a\nspeed 38400 baud; rows 60; columns 211; line = 0;\nintr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;\n-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr\n-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8\nopost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke\n```\n\n### **参考链接**\n- [Bg, Fg, &, Ctrl-Z – 5 Examples to Manage Unix Background Jobs](http://www.thegeekstuff.com/2010/05/unix-background-job/)\n- [Linux中 ctrl-c, ctrl-z, ctrl-d 区别](http://blog.csdn.net/mylizh/article/details/38385739)\n\n","slug":"linux-other--cli控制字符","published":1,"updated":"2018-01-07T13:13:21.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5p000fj1jxyqyjlm8z","content":"<blockquote>\n<p>cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;<br>另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识</a>;<br>本文总结一些常用的 cli 控制字符的使用及技巧;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"简单的-cli-控制字符\"><a href=\"#简单的-cli-控制字符\" class=\"headerlink\" title=\"简单的 cli 控制字符\"></a><strong>简单的 cli 控制字符</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGINT 中断信号</span></span><br><span class=\"line\">ctrl + c</span><br><span class=\"line\"><span class=\"comment\"># 清屏</span></span><br><span class=\"line\">ctrl + l</span><br><span class=\"line\"><span class=\"comment\"># reverse-i-search 搜索历史命令</span></span><br><span class=\"line\">ctrl + r</span><br><span class=\"line\"><span class=\"comment\"># 从机器上 logout</span></span><br><span class=\"line\">ctrl + d</span><br><span class=\"line\"><span class=\"comment\"># 暂停控制台标准输出 / 恢复控制台标准输出</span></span><br><span class=\"line\">ctrl + s / ctrl + q</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGQUIT 信号给前台进程, 并生成 core dump</span></span><br><span class=\"line\">ctrl + /</span><br><span class=\"line\"><span class=\"comment\"># 向前删除到第一个空格</span></span><br><span class=\"line\">ctrl + w</span><br><span class=\"line\"><span class=\"comment\"># 向后删除到第一个空格</span></span><br><span class=\"line\"> alt + d</span><br><span class=\"line\"><span class=\"comment\"># 向后删除所有的内容</span></span><br><span class=\"line\">ctrl + k</span><br><span class=\"line\"><span class=\"comment\"># 撤销上一步操作</span></span><br><span class=\"line\">ctrl + ?</span><br><span class=\"line\"><span class=\"comment\"># 光标快速跃进</span></span><br><span class=\"line\">ctrl + 方向键</span><br><span class=\"line\"><span class=\"comment\"># 补全命令/文件</span></span><br><span class=\"line\">tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"与其他命令组合的-cli-控制字符\"><a href=\"#与其他命令组合的-cli-控制字符\" class=\"headerlink\" title=\"与其他命令组合的 cli 控制字符 \"></a><strong>与其他命令组合的 cli 控制字符 </strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGTSTP 信号, 挂起前台进程</span></span><br><span class=\"line\">ctrl + z</span><br><span class=\"line\"><span class=\"comment\"># ctrl + z 的输出</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br></pre></td></tr></table></figure>\n<p>此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;<br>接下来可以有以下配套操作:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看后台任务</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">jobs</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 查看后台任务的 pid</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span> -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到前台</span></span><br><span class=\"line\"><span class=\"built_in\">fg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">fg</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到后台</span></span><br><span class=\"line\"><span class=\"built_in\">bg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">bg</span> %1</span><br></pre></td></tr></table></figure></p>\n<p>要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 %1</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `<span class=\"built_in\">jobs</span> -p`</span><br></pre></td></tr></table></figure></p>\n<p>还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当任务被唤醒, 将接收到 SIGTERM 信号并终止</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">fg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">fg</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制字符的管理与设置\"><a href=\"#控制字符的管理与设置\" class=\"headerlink\" title=\"控制字符的管理与设置\"></a><strong>控制字符的管理与设置</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印所有控制字符的设置 (--all)</span></span><br><span class=\"line\">&gt; stty -a</span><br><span class=\"line\">speed 38400 baud; rows 60; columns 211; line = 0;</span><br><span class=\"line\">intr = ^C; quit = ^\\; erase = ^?; <span class=\"built_in\">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</span><br><span class=\"line\">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr</span><br><span class=\"line\">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8</span><br><span class=\"line\">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class=\"line\">isig icanon iexten <span class=\"built_in\">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.thegeekstuff.com/2010/05/unix-background-job/\" target=\"_blank\" rel=\"noopener\">Bg, Fg, &amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs</a></li>\n<li><a href=\"http://blog.csdn.net/mylizh/article/details/38385739\" target=\"_blank\" rel=\"noopener\">Linux中 ctrl-c, ctrl-z, ctrl-d 区别</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>cli 控制字符是终端操作中非常实用, 也极其频繁使用的快捷键; 使用得好可以加快敲命令的速度, 提升敲命令的准确性, 为工作带来极大便利; 同时, 这也是我们对 linux 爱不释手, 难以回到 windows 的原因之一;<br>另外, 很多 cli 控制字符本质上是向 linux 或进程发送特定的信号, 关于 linux 信号的介绍, 本站有另外一篇文章: <a href=\"https://zshell-zhang.github.io/2017/04/05/linux-process--linux_signals%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/\" target=\"_blank\" rel=\"noopener\">linux signals 总体认识</a>;<br>本文总结一些常用的 cli 控制字符的使用及技巧;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"简单的-cli-控制字符\"><a href=\"#简单的-cli-控制字符\" class=\"headerlink\" title=\"简单的 cli 控制字符\"></a><strong>简单的 cli 控制字符</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGINT 中断信号</span></span><br><span class=\"line\">ctrl + c</span><br><span class=\"line\"><span class=\"comment\"># 清屏</span></span><br><span class=\"line\">ctrl + l</span><br><span class=\"line\"><span class=\"comment\"># reverse-i-search 搜索历史命令</span></span><br><span class=\"line\">ctrl + r</span><br><span class=\"line\"><span class=\"comment\"># 从机器上 logout</span></span><br><span class=\"line\">ctrl + d</span><br><span class=\"line\"><span class=\"comment\"># 暂停控制台标准输出 / 恢复控制台标准输出</span></span><br><span class=\"line\">ctrl + s / ctrl + q</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGQUIT 信号给前台进程, 并生成 core dump</span></span><br><span class=\"line\">ctrl + /</span><br><span class=\"line\"><span class=\"comment\"># 向前删除到第一个空格</span></span><br><span class=\"line\">ctrl + w</span><br><span class=\"line\"><span class=\"comment\"># 向后删除到第一个空格</span></span><br><span class=\"line\"> alt + d</span><br><span class=\"line\"><span class=\"comment\"># 向后删除所有的内容</span></span><br><span class=\"line\">ctrl + k</span><br><span class=\"line\"><span class=\"comment\"># 撤销上一步操作</span></span><br><span class=\"line\">ctrl + ?</span><br><span class=\"line\"><span class=\"comment\"># 光标快速跃进</span></span><br><span class=\"line\">ctrl + 方向键</span><br><span class=\"line\"><span class=\"comment\"># 补全命令/文件</span></span><br><span class=\"line\">tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"与其他命令组合的-cli-控制字符\"><a href=\"#与其他命令组合的-cli-控制字符\" class=\"headerlink\" title=\"与其他命令组合的 cli 控制字符 \"></a><strong>与其他命令组合的 cli 控制字符 </strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送 SIGTSTP 信号, 挂起前台进程</span></span><br><span class=\"line\">ctrl + z</span><br><span class=\"line\"><span class=\"comment\"># ctrl + z 的输出</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br></pre></td></tr></table></figure>\n<p>此时该前台进程被挂起, 操作系统将不会调度任何 cpu time 给此进程;<br>接下来可以有以下配套操作:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看后台任务</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">jobs</span></span><br><span class=\"line\">[1]+  Stopped                 sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 查看后台任务的 pid</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span> -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到前台</span></span><br><span class=\"line\"><span class=\"built_in\">fg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">fg</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 将后台作业 1 恢复到后台</span></span><br><span class=\"line\"><span class=\"built_in\">bg</span> 1</span><br><span class=\"line\"><span class=\"built_in\">bg</span> %1</span><br></pre></td></tr></table></figure></p>\n<p>要杀死被挂起的后台任务有一些麻烦, 因为该任务处于 suspend 状态, 无法主动响应 SIGTERM, SIGINT 等相对柔和的信号, 但可以被 SIGKILL 这种强力的信号直接杀死:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 %1</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `<span class=\"built_in\">jobs</span> -p`</span><br></pre></td></tr></table></figure></p>\n<p>还有一种比较讨巧的方法是结合 fg/bg 等唤醒后台任务的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当任务被唤醒, 将接收到 SIGTERM 信号并终止</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">fg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1 &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">bg</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> `<span class=\"built_in\">jobs</span> -p` &amp;&amp; <span class=\"built_in\">fg</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制字符的管理与设置\"><a href=\"#控制字符的管理与设置\" class=\"headerlink\" title=\"控制字符的管理与设置\"></a><strong>控制字符的管理与设置</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印所有控制字符的设置 (--all)</span></span><br><span class=\"line\">&gt; stty -a</span><br><span class=\"line\">speed 38400 baud; rows 60; columns 211; line = 0;</span><br><span class=\"line\">intr = ^C; quit = ^\\; erase = ^?; <span class=\"built_in\">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</span><br><span class=\"line\">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr</span><br><span class=\"line\">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8</span><br><span class=\"line\">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class=\"line\">isig icanon iexten <span class=\"built_in\">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.thegeekstuff.com/2010/05/unix-background-job/\" target=\"_blank\" rel=\"noopener\">Bg, Fg, &amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs</a></li>\n<li><a href=\"http://blog.csdn.net/mylizh/article/details/38385739\" target=\"_blank\" rel=\"noopener\">Linux中 ctrl-c, ctrl-z, ctrl-d 区别</a></li>\n</ul>"},{"title":"linux signals 总体认识","date":"2017-04-05T15:24:22.000Z","_content":"\n> linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;\n不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;\n本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;\n\n<!--more-->\n\n## **linux signals 总览**\nlinux siginal 可分为如下几大类:\n\n1. 系统错误信号\n2. 进程终止信号\n3. 作业控制信号\n4. AIO 信号\n5. 定时器信号\n6. 操作错误信号\n7. 其他信号\n\n&nbsp;\nlinux signals 的产生源一般分为三类: 硬件方式(除数为 0, 内存非法访问等), IO 方式(键盘事件), 以及软件方式: kill 命令, alarm 定时器等;\n其中我们最熟悉的莫不过 kill 命令了, 详情请见: [kill 命令族及其选项]();\n\n&nbsp;\n使用 kill -l 查看所有信号分布:\n``` bash\n> kill -l\n 1) SIGHUP\t     2) SIGINT\t    \t 3) SIGQUIT\t     4) SIGILL\t    \t 5) SIGTRAP\n 6) SIGABRT\t     7) SIGBUS\t    \t 8) SIGFPE\t     9) SIGKILL\t    \t10) SIGUSR1\n11) SIGSEGV\t    12) SIGUSR2\t    \t13) SIGPIPE\t    14) SIGALRM\t    \t15) SIGTERM\n16) SIGSTKFLT\t    17) SIGCHLD\t    \t18) SIGCONT\t    19) SIGSTOP\t    \t20) SIGTSTP\n21) SIGTTIN\t    22) SIGTTOU\t    \t23) SIGURG\t    24) SIGXCPU\t    \t25) SIGXFSZ\n26) SIGVTALRM\t    27) SIGPROF\t    \t28) SIGWINCH        29) SIGIO\t    \t30) SIGPWR\n31) SIGSYS\t    34) SIGRTMIN    \t35) SIGRTMIN+1      36) SIGRTMIN+2  \t37) SIGRTMIN+3\n38) SIGRTMIN+4\t    39) SIGRTMIN+5  \t40) SIGRTMIN+6      41) SIGRTMIN+7  \t42) SIGRTMIN+8\n43) SIGRTMIN+9\t    44) SIGRTMIN+10 \t45) SIGRTMIN+11     46) SIGRTMIN+12 \t47) SIGRTMIN+13\n48) SIGRTMIN+14\t    49) SIGRTMIN+15 \t50) SIGRTMAX-14     51) SIGRTMAX-13 \t52) SIGRTMAX-12\n53) SIGRTMAX-11\t    54) SIGRTMAX-10 \t55) SIGRTMAX-9      56) SIGRTMAX-8  \t57) SIGRTMAX-7\n58) SIGRTMAX-6\t    59) SIGRTMAX-5  \t60) SIGRTMAX-4      61) SIGRTMAX-3  \t62) SIGRTMAX-2\n63) SIGRTMAX-1\t    64) SIGRTMAX\n```\n\n## **各类别信号整理**\n\n### **进程终止信号**\n进程终止信号是我们日常操作中最常用的一类信号;\n进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;\n``` bash\n# terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;\nSIGTERM\n# interrupt, ctrl + c 发出的信号, 默认处理是终止进程;\nSIGINT\n# quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:\n# 1. 终止进程; 2. 产生进程 core dump 文件;\nSIGQUIT\n# kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理\n# 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用\nSIGKILL\n# hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session\n# session 接收该信号并将其发送给子进程\nSIGHUP\n```\n另外一篇详细梳理与 SIGHUP 相关知识点的链接: [SIGHUP 相关全梳理]();\n该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;\n\n### **任务控制信号**\n\n### **其他信号**\n其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;\n&nbsp;\n(1) 用户自定义信号: SIGUSR1 / SIGUSR2\n这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;\nSIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;\n以下是 SIGUSR1 / SIGUSR2 的具体使用场景:\n``` bash\n# 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志\nkill -USR1 `cat /var/run/nginx.pid`\n# 通知 nginx 平滑升级 二进制可执行程序\nkill -s SIGUSR2 `cat /var/run/nginx.pid`\n```\n&nbsp;\n(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;\n以下是 SIGWINCH 的具体使用场景:\n``` bash\n# 通知 nginx worker process 不再接受新 request, 并从容关闭\nkill -WINCH `cat /var/run/nginx.pid`\n```\n当然, 通知 worker process 不再接受新请求, nginx 并不需要使用者直接在 linux signals 层面直接处理, nginx 本身提供了平滑重启命令 `sbin/nginx -c conf/nginx.conf -s reload`, SIGWINCH 信号的发送封装在了该命令里;\n&nbsp;\n关于 nginx 与 linux signals 的关系, 在本站另一篇文章中有详细介绍: [nginx signals 处理]();\n\n## **站内相关文章**\n- [kill 命令族及其选项]()\n- [SIGHUP 相关全梳理]()\n- [nginx signals 处理]()\n\n## **参考链接**\n- [24.2.2 Termination Signals](http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals)\n- [24.2.5 Job Control Signals](http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html)\n- [24.2.7 Miscellaneous Signals](http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals)\n- [Difference between SIGUSR1 and SIGUSR2](https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2)\n- [linux kill 命令 以及 USR1 信号 解释](http://blog.csdn.net/fuming0210sc/article/details/50906372)\n- [Linux 信号入门详解](http://blog.csdn.net/lisongjia123/article/details/50471854)\n- [文章3: Nginx中与信号有关的内容](http://blog.csdn.net/yankai0219/article/details/8453261)\n\n","source":"_posts/linux-process--linux_signals总体认识.md","raw":"---\ntitle: linux signals 总体认识\ndate: 2017-04-05 23:24:22\ncategories:\n  - linux\n  - process\ntags:\n  - linux:process\n---\n\n> linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;\n不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;\n本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;\n\n<!--more-->\n\n## **linux signals 总览**\nlinux siginal 可分为如下几大类:\n\n1. 系统错误信号\n2. 进程终止信号\n3. 作业控制信号\n4. AIO 信号\n5. 定时器信号\n6. 操作错误信号\n7. 其他信号\n\n&nbsp;\nlinux signals 的产生源一般分为三类: 硬件方式(除数为 0, 内存非法访问等), IO 方式(键盘事件), 以及软件方式: kill 命令, alarm 定时器等;\n其中我们最熟悉的莫不过 kill 命令了, 详情请见: [kill 命令族及其选项]();\n\n&nbsp;\n使用 kill -l 查看所有信号分布:\n``` bash\n> kill -l\n 1) SIGHUP\t     2) SIGINT\t    \t 3) SIGQUIT\t     4) SIGILL\t    \t 5) SIGTRAP\n 6) SIGABRT\t     7) SIGBUS\t    \t 8) SIGFPE\t     9) SIGKILL\t    \t10) SIGUSR1\n11) SIGSEGV\t    12) SIGUSR2\t    \t13) SIGPIPE\t    14) SIGALRM\t    \t15) SIGTERM\n16) SIGSTKFLT\t    17) SIGCHLD\t    \t18) SIGCONT\t    19) SIGSTOP\t    \t20) SIGTSTP\n21) SIGTTIN\t    22) SIGTTOU\t    \t23) SIGURG\t    24) SIGXCPU\t    \t25) SIGXFSZ\n26) SIGVTALRM\t    27) SIGPROF\t    \t28) SIGWINCH        29) SIGIO\t    \t30) SIGPWR\n31) SIGSYS\t    34) SIGRTMIN    \t35) SIGRTMIN+1      36) SIGRTMIN+2  \t37) SIGRTMIN+3\n38) SIGRTMIN+4\t    39) SIGRTMIN+5  \t40) SIGRTMIN+6      41) SIGRTMIN+7  \t42) SIGRTMIN+8\n43) SIGRTMIN+9\t    44) SIGRTMIN+10 \t45) SIGRTMIN+11     46) SIGRTMIN+12 \t47) SIGRTMIN+13\n48) SIGRTMIN+14\t    49) SIGRTMIN+15 \t50) SIGRTMAX-14     51) SIGRTMAX-13 \t52) SIGRTMAX-12\n53) SIGRTMAX-11\t    54) SIGRTMAX-10 \t55) SIGRTMAX-9      56) SIGRTMAX-8  \t57) SIGRTMAX-7\n58) SIGRTMAX-6\t    59) SIGRTMAX-5  \t60) SIGRTMAX-4      61) SIGRTMAX-3  \t62) SIGRTMAX-2\n63) SIGRTMAX-1\t    64) SIGRTMAX\n```\n\n## **各类别信号整理**\n\n### **进程终止信号**\n进程终止信号是我们日常操作中最常用的一类信号;\n进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;\n``` bash\n# terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;\nSIGTERM\n# interrupt, ctrl + c 发出的信号, 默认处理是终止进程;\nSIGINT\n# quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:\n# 1. 终止进程; 2. 产生进程 core dump 文件;\nSIGQUIT\n# kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理\n# 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用\nSIGKILL\n# hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session\n# session 接收该信号并将其发送给子进程\nSIGHUP\n```\n另外一篇详细梳理与 SIGHUP 相关知识点的链接: [SIGHUP 相关全梳理]();\n该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;\n\n### **任务控制信号**\n\n### **其他信号**\n其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;\n&nbsp;\n(1) 用户自定义信号: SIGUSR1 / SIGUSR2\n这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;\nSIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;\n以下是 SIGUSR1 / SIGUSR2 的具体使用场景:\n``` bash\n# 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志\nkill -USR1 `cat /var/run/nginx.pid`\n# 通知 nginx 平滑升级 二进制可执行程序\nkill -s SIGUSR2 `cat /var/run/nginx.pid`\n```\n&nbsp;\n(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;\n以下是 SIGWINCH 的具体使用场景:\n``` bash\n# 通知 nginx worker process 不再接受新 request, 并从容关闭\nkill -WINCH `cat /var/run/nginx.pid`\n```\n当然, 通知 worker process 不再接受新请求, nginx 并不需要使用者直接在 linux signals 层面直接处理, nginx 本身提供了平滑重启命令 `sbin/nginx -c conf/nginx.conf -s reload`, SIGWINCH 信号的发送封装在了该命令里;\n&nbsp;\n关于 nginx 与 linux signals 的关系, 在本站另一篇文章中有详细介绍: [nginx signals 处理]();\n\n## **站内相关文章**\n- [kill 命令族及其选项]()\n- [SIGHUP 相关全梳理]()\n- [nginx signals 处理]()\n\n## **参考链接**\n- [24.2.2 Termination Signals](http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals)\n- [24.2.5 Job Control Signals](http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html)\n- [24.2.7 Miscellaneous Signals](http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals)\n- [Difference between SIGUSR1 and SIGUSR2](https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2)\n- [linux kill 命令 以及 USR1 信号 解释](http://blog.csdn.net/fuming0210sc/article/details/50906372)\n- [Linux 信号入门详解](http://blog.csdn.net/lisongjia123/article/details/50471854)\n- [文章3: Nginx中与信号有关的内容](http://blog.csdn.net/yankai0219/article/details/8453261)\n\n","slug":"linux-process--linux_signals总体认识","published":1,"updated":"2018-01-20T12:10:14.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5q000gj1jxcj9qjmz2","content":"<blockquote>\n<p>linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;<br>不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;<br>本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"linux-signals-总览\"><a href=\"#linux-signals-总览\" class=\"headerlink\" title=\"linux signals 总览\"></a><strong>linux signals 总览</strong></h2><p>linux siginal 可分为如下几大类:</p>\n<ol>\n<li>系统错误信号</li>\n<li>进程终止信号</li>\n<li>作业控制信号</li>\n<li>AIO 信号</li>\n<li>定时器信号</li>\n<li>操作错误信号</li>\n<li>其他信号</li>\n</ol>\n<p>&nbsp;<br>linux signals 的产生源一般分为三类: 硬件方式(除数为 0, 内存非法访问等), IO 方式(键盘事件), 以及软件方式: kill 命令, alarm 定时器等;<br>其中我们最熟悉的莫不过 kill 命令了, 详情请见: <a href=\"\">kill 命令族及其选项</a>;</p>\n<p>&nbsp;<br>使用 kill -l 查看所有信号分布:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">kill</span> -l</span><br><span class=\"line\"> 1) SIGHUP\t     2) SIGINT\t    \t 3) SIGQUIT\t     4) SIGILL\t    \t 5) SIGTRAP</span><br><span class=\"line\"> 6) SIGABRT\t     7) SIGBUS\t    \t 8) SIGFPE\t     9) SIGKILL\t    \t10) SIGUSR1</span><br><span class=\"line\">11) SIGSEGV\t    12) SIGUSR2\t    \t13) SIGPIPE\t    14) SIGALRM\t    \t15) SIGTERM</span><br><span class=\"line\">16) SIGSTKFLT\t    17) SIGCHLD\t    \t18) SIGCONT\t    19) SIGSTOP\t    \t20) SIGTSTP</span><br><span class=\"line\">21) SIGTTIN\t    22) SIGTTOU\t    \t23) SIGURG\t    24) SIGXCPU\t    \t25) SIGXFSZ</span><br><span class=\"line\">26) SIGVTALRM\t    27) SIGPROF\t    \t28) SIGWINCH        29) SIGIO\t    \t30) SIGPWR</span><br><span class=\"line\">31) SIGSYS\t    34) SIGRTMIN    \t35) SIGRTMIN+1      36) SIGRTMIN+2  \t37) SIGRTMIN+3</span><br><span class=\"line\">38) SIGRTMIN+4\t    39) SIGRTMIN+5  \t40) SIGRTMIN+6      41) SIGRTMIN+7  \t42) SIGRTMIN+8</span><br><span class=\"line\">43) SIGRTMIN+9\t    44) SIGRTMIN+10 \t45) SIGRTMIN+11     46) SIGRTMIN+12 \t47) SIGRTMIN+13</span><br><span class=\"line\">48) SIGRTMIN+14\t    49) SIGRTMIN+15 \t50) SIGRTMAX-14     51) SIGRTMAX-13 \t52) SIGRTMAX-12</span><br><span class=\"line\">53) SIGRTMAX-11\t    54) SIGRTMAX-10 \t55) SIGRTMAX-9      56) SIGRTMAX-8  \t57) SIGRTMAX-7</span><br><span class=\"line\">58) SIGRTMAX-6\t    59) SIGRTMAX-5  \t60) SIGRTMAX-4      61) SIGRTMAX-3  \t62) SIGRTMAX-2</span><br><span class=\"line\">63) SIGRTMAX-1\t    64) SIGRTMAX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"各类别信号整理\"><a href=\"#各类别信号整理\" class=\"headerlink\" title=\"各类别信号整理\"></a><strong>各类别信号整理</strong></h2><h3 id=\"进程终止信号\"><a href=\"#进程终止信号\" class=\"headerlink\" title=\"进程终止信号\"></a><strong>进程终止信号</strong></h3><p>进程终止信号是我们日常操作中最常用的一类信号;<br>进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGTERM</span><br><span class=\"line\"><span class=\"comment\"># interrupt, ctrl + c 发出的信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGINT</span><br><span class=\"line\"><span class=\"comment\"># quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 终止进程; 2. 产生进程 core dump 文件;</span></span><br><span class=\"line\">SIGQUIT</span><br><span class=\"line\"><span class=\"comment\"># kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理</span></span><br><span class=\"line\"><span class=\"comment\"># 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用</span></span><br><span class=\"line\">SIGKILL</span><br><span class=\"line\"><span class=\"comment\"># hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session</span></span><br><span class=\"line\"><span class=\"comment\"># session 接收该信号并将其发送给子进程</span></span><br><span class=\"line\">SIGHUP</span><br></pre></td></tr></table></figure></p>\n<p>另外一篇详细梳理与 SIGHUP 相关知识点的链接: <a href=\"\">SIGHUP 相关全梳理</a>;<br>该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &amp;,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;</p>\n<h3 id=\"任务控制信号\"><a href=\"#任务控制信号\" class=\"headerlink\" title=\"任务控制信号\"></a><strong>任务控制信号</strong></h3><h3 id=\"其他信号\"><a href=\"#其他信号\" class=\"headerlink\" title=\"其他信号\"></a><strong>其他信号</strong></h3><p>其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;<br>&nbsp;<br>(1) 用户自定义信号: SIGUSR1 / SIGUSR2<br>这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;<br>SIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;<br>以下是 SIGUSR1 / SIGUSR2 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat /var/run/nginx.pid`</span><br><span class=\"line\"><span class=\"comment\"># 通知 nginx 平滑升级 二进制可执行程序</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -s SIGUSR2 `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;<br>以下是 SIGWINCH 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx worker process 不再接受新 request, 并从容关闭</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -WINCH `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>当然, 通知 worker process 不再接受新请求, nginx 并不需要使用者直接在 linux signals 层面直接处理, nginx 本身提供了平滑重启命令 <code>sbin/nginx -c conf/nginx.conf -s reload</code>, SIGWINCH 信号的发送封装在了该命令里;<br>&nbsp;<br>关于 nginx 与 linux signals 的关系, 在本站另一篇文章中有详细介绍: <a href=\"\">nginx signals 处理</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">kill 命令族及其选项</a></li>\n<li><a href=\"\">SIGHUP 相关全梳理</a></li>\n<li><a href=\"\">nginx signals 处理</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals\" target=\"_blank\" rel=\"noopener\">24.2.2 Termination Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html\" target=\"_blank\" rel=\"noopener\">24.2.5 Job Control Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals\" target=\"_blank\" rel=\"noopener\">24.2.7 Miscellaneous Signals</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2\" target=\"_blank\" rel=\"noopener\">Difference between SIGUSR1 and SIGUSR2</a></li>\n<li><a href=\"http://blog.csdn.net/fuming0210sc/article/details/50906372\" target=\"_blank\" rel=\"noopener\">linux kill 命令 以及 USR1 信号 解释</a></li>\n<li><a href=\"http://blog.csdn.net/lisongjia123/article/details/50471854\" target=\"_blank\" rel=\"noopener\">Linux 信号入门详解</a></li>\n<li><a href=\"http://blog.csdn.net/yankai0219/article/details/8453261\" target=\"_blank\" rel=\"noopener\">文章3: Nginx中与信号有关的内容</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>linux 的信号系统其实是一个非常重要的概念, 进程间通信的常用方法之一;<br>不过长期以来, 我们对 linux 信号的直观认识, 只有 kill (SIGTERM), ctrl + c (SIGINT) 和 kill -9 等进程终止信号; 而 linux 的信号系统中存在 64 种各司其职的信号, 适用于各种各样的场景; 很多信号在实际工作中有着妙用;<br>本文正是想对 linux 世界中林林总总的 signals 作一次梳理, 总结一些日常工作中频繁使用以及不太接触但十分有用的信号;</p>\n</blockquote>","more":"<h2 id=\"linux-signals-总览\"><a href=\"#linux-signals-总览\" class=\"headerlink\" title=\"linux signals 总览\"></a><strong>linux signals 总览</strong></h2><p>linux siginal 可分为如下几大类:</p>\n<ol>\n<li>系统错误信号</li>\n<li>进程终止信号</li>\n<li>作业控制信号</li>\n<li>AIO 信号</li>\n<li>定时器信号</li>\n<li>操作错误信号</li>\n<li>其他信号</li>\n</ol>\n<p>&nbsp;<br>linux signals 的产生源一般分为三类: 硬件方式(除数为 0, 内存非法访问等), IO 方式(键盘事件), 以及软件方式: kill 命令, alarm 定时器等;<br>其中我们最熟悉的莫不过 kill 命令了, 详情请见: <a href=\"\">kill 命令族及其选项</a>;</p>\n<p>&nbsp;<br>使用 kill -l 查看所有信号分布:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">kill</span> -l</span><br><span class=\"line\"> 1) SIGHUP\t     2) SIGINT\t    \t 3) SIGQUIT\t     4) SIGILL\t    \t 5) SIGTRAP</span><br><span class=\"line\"> 6) SIGABRT\t     7) SIGBUS\t    \t 8) SIGFPE\t     9) SIGKILL\t    \t10) SIGUSR1</span><br><span class=\"line\">11) SIGSEGV\t    12) SIGUSR2\t    \t13) SIGPIPE\t    14) SIGALRM\t    \t15) SIGTERM</span><br><span class=\"line\">16) SIGSTKFLT\t    17) SIGCHLD\t    \t18) SIGCONT\t    19) SIGSTOP\t    \t20) SIGTSTP</span><br><span class=\"line\">21) SIGTTIN\t    22) SIGTTOU\t    \t23) SIGURG\t    24) SIGXCPU\t    \t25) SIGXFSZ</span><br><span class=\"line\">26) SIGVTALRM\t    27) SIGPROF\t    \t28) SIGWINCH        29) SIGIO\t    \t30) SIGPWR</span><br><span class=\"line\">31) SIGSYS\t    34) SIGRTMIN    \t35) SIGRTMIN+1      36) SIGRTMIN+2  \t37) SIGRTMIN+3</span><br><span class=\"line\">38) SIGRTMIN+4\t    39) SIGRTMIN+5  \t40) SIGRTMIN+6      41) SIGRTMIN+7  \t42) SIGRTMIN+8</span><br><span class=\"line\">43) SIGRTMIN+9\t    44) SIGRTMIN+10 \t45) SIGRTMIN+11     46) SIGRTMIN+12 \t47) SIGRTMIN+13</span><br><span class=\"line\">48) SIGRTMIN+14\t    49) SIGRTMIN+15 \t50) SIGRTMAX-14     51) SIGRTMAX-13 \t52) SIGRTMAX-12</span><br><span class=\"line\">53) SIGRTMAX-11\t    54) SIGRTMAX-10 \t55) SIGRTMAX-9      56) SIGRTMAX-8  \t57) SIGRTMAX-7</span><br><span class=\"line\">58) SIGRTMAX-6\t    59) SIGRTMAX-5  \t60) SIGRTMAX-4      61) SIGRTMAX-3  \t62) SIGRTMAX-2</span><br><span class=\"line\">63) SIGRTMAX-1\t    64) SIGRTMAX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"各类别信号整理\"><a href=\"#各类别信号整理\" class=\"headerlink\" title=\"各类别信号整理\"></a><strong>各类别信号整理</strong></h2><h3 id=\"进程终止信号\"><a href=\"#进程终止信号\" class=\"headerlink\" title=\"进程终止信号\"></a><strong>进程终止信号</strong></h3><p>进程终止信号是我们日常操作中最常用的一类信号;<br>进程终止信号共有五个, 其中除了 SIGKILL 之外, 其他信号都是 可阻塞, 可忽略, 可处理的;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># terminate, kill 不加任何选项的默认信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGTERM</span><br><span class=\"line\"><span class=\"comment\"># interrupt, ctrl + c 发出的信号, 默认处理是终止进程;</span></span><br><span class=\"line\">SIGINT</span><br><span class=\"line\"><span class=\"comment\"># quit, ctrl + / 发出的信号, 与 SIGINT 类似, 不过其默认处理相比 SIGINT 还增加了一项:</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 终止进程; 2. 产生进程 core dump 文件;</span></span><br><span class=\"line\">SIGQUIT</span><br><span class=\"line\"><span class=\"comment\"># kill, 不可阻塞, 不可忽略, 最强力的终止信号, 通常会导致进程立即终止, 其占有的资源无法释放清理</span></span><br><span class=\"line\"><span class=\"comment\"># 一般需要在 SIGTERM/SIGINT/SIGQUIT 等信号无法响应之后, 才最后使用</span></span><br><span class=\"line\">SIGKILL</span><br><span class=\"line\"><span class=\"comment\"># hang up, 通常在用户退出终端断开 sessiion 时由系统发出该信号给 session</span></span><br><span class=\"line\"><span class=\"comment\"># session 接收该信号并将其发送给子进程</span></span><br><span class=\"line\">SIGHUP</span><br></pre></td></tr></table></figure></p>\n<p>另外一篇详细梳理与 SIGHUP 相关知识点的链接: <a href=\"\">SIGHUP 相关全梳理</a>;<br>该文章主要涉及 SIGHUP 信号发生的条件, 传导, 与 SIGHUP 相关的 nohup, &amp;,  shopt huponexit, disown 等概念, 并包括一些 SIGHUP 的自定义应用;</p>\n<h3 id=\"任务控制信号\"><a href=\"#任务控制信号\" class=\"headerlink\" title=\"任务控制信号\"></a><strong>任务控制信号</strong></h3><h3 id=\"其他信号\"><a href=\"#其他信号\" class=\"headerlink\" title=\"其他信号\"></a><strong>其他信号</strong></h3><p>其他信号是指未在上述分类中的一些小众信号, 这些信号本身并未有太多关联, 不能用一个类别去统一描述它们;<br>&nbsp;<br>(1) 用户自定义信号: SIGUSR1 / SIGUSR2<br>这两个信号, linux 保证系统自身不会向进程发送, 完全由使用者自己定义该信号的语义以及处理逻辑;<br>SIGUSR1 与 SIGUSR2, 在系统层面完全没有区别, 如果可以, linux 其实能再定义一个 SIGUSR3; 所以用户自定义信号的预留数量, 本身是一个模糊的界定;<br>以下是 SIGUSR1 / SIGUSR2 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx 关闭当前句柄, 重新打开日志文件, 用于 logrotate 切割日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat /var/run/nginx.pid`</span><br><span class=\"line\"><span class=\"comment\"># 通知 nginx 平滑升级 二进制可执行程序</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -s SIGUSR2 `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>(2) SIGWINCH (winch 译作: 吊车, 摇柄), 默认处理是忽略该信号;<br>以下是 SIGWINCH 的具体使用场景:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通知 nginx worker process 不再接受新 request, 并从容关闭</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -WINCH `cat /var/run/nginx.pid`</span><br></pre></td></tr></table></figure></p>\n<p>当然, 通知 worker process 不再接受新请求, nginx 并不需要使用者直接在 linux signals 层面直接处理, nginx 本身提供了平滑重启命令 <code>sbin/nginx -c conf/nginx.conf -s reload</code>, SIGWINCH 信号的发送封装在了该命令里;<br>&nbsp;<br>关于 nginx 与 linux signals 的关系, 在本站另一篇文章中有详细介绍: <a href=\"\">nginx signals 处理</a>;</p>\n<h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">kill 命令族及其选项</a></li>\n<li><a href=\"\">SIGHUP 相关全梳理</a></li>\n<li><a href=\"\">nginx signals 处理</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals\" target=\"_blank\" rel=\"noopener\">24.2.2 Termination Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html\" target=\"_blank\" rel=\"noopener\">24.2.5 Job Control Signals</a></li>\n<li><a href=\"http://www.gnu.org/software/libc/manual/html_node/Miscellaneous-Signals.html#Miscellaneous-Signals\" target=\"_blank\" rel=\"noopener\">24.2.7 Miscellaneous Signals</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27403641/difference-between-sigusr1-and-sigusr2\" target=\"_blank\" rel=\"noopener\">Difference between SIGUSR1 and SIGUSR2</a></li>\n<li><a href=\"http://blog.csdn.net/fuming0210sc/article/details/50906372\" target=\"_blank\" rel=\"noopener\">linux kill 命令 以及 USR1 信号 解释</a></li>\n<li><a href=\"http://blog.csdn.net/lisongjia123/article/details/50471854\" target=\"_blank\" rel=\"noopener\">Linux 信号入门详解</a></li>\n<li><a href=\"http://blog.csdn.net/yankai0219/article/details/8453261\" target=\"_blank\" rel=\"noopener\">文章3: Nginx中与信号有关的内容</a></li>\n</ul>"},{"title":"sed 命令整理","date":"2016-11-04T14:56:47.000Z","_content":"\n> stream editor: 流式文本编辑器;\nsed 命令的侧重点在于对文本的编辑;\n\n<!--more-->\n\n### **sed 的基本模式**\n``` bash\n# 标准模式: 选项, 目标行范围, 命令\nsed  [-nefri] '[target line]command' $file_path\n# 正则模式: 选项, 正则匹配式, 命令\nsed  [-nefri] '/regex/command' $file_path\n# 混合模式: 选项, 目标行与正则式组合范围, 命令\nsed [-nefri] 'line,/regex/command' $file_path\n```\n### **sed 的常用选项**\n``` bash\n1. -n:  silent 静默模式, 只输出被 sed 处理过的行;\n2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:\n        sed -e '$d' -e '/regex/p' $file_path\n3. -f:  执行给定文件里的命令;\n4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:\n        +, ?, |, ()\n        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;\n5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;\n```\n### **sed 的 command**\n``` bash\n1. i:   insert 到 目标行的上一行\n2. a:   append 到 目标行的下一行 \n3. c:   replace, 不能使用正则表达式\n4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:\n        s/regex/new_str/g, 替换文件中所有的 regex;\n        s/regex/new_str, 只替换每行第一个被匹配上的 regex;\n        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;\n5. d:   delete\n6. p:   print, 一般需要与 -n 选项一同使用, 否则看不出打印效果\n7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/\n```\n### **典型示例**\n``` bash\n# 打印最后一行\nsed -n '$p' $file_path\n# 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串\nsed -i -e '9,$d' -e '1,3a append' $file_path\n# 正则表达式替换(替换全部 regex)\nsed -ri 's/^(test|ping)[a-z]+.$/kill/g' $file_path\n# 打印从第9行开始到以 test 结尾的行之间的每一行\nsed -n '9,/test$/p' $file_path\n```\n``` bash\n# 结合变量, 往最后一行添加一行内容\n# 需使用\"\", 同时表示最后一行的 $ 需要转义\ncron_str='5 * * * *  sh /home/q/tools/bin/log_collect.sh 1>/dev/null'\nsed \"\\$a ${cron_str}\" /var/spool/cron/root\n```\n\n### **参考链接**\n- [linux之sed用法](http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html)\n- [linux sed命令详解](http://www.iteye.com/topic/587673)\n\n","source":"_posts/linux-text-sed命令整理.md","raw":"---\ntitle: sed 命令整理\ndate: 2016-11-04 22:56:47\ncategories:\n  - linux\n  - text\ntags:\n  - linux:text\n---\n\n> stream editor: 流式文本编辑器;\nsed 命令的侧重点在于对文本的编辑;\n\n<!--more-->\n\n### **sed 的基本模式**\n``` bash\n# 标准模式: 选项, 目标行范围, 命令\nsed  [-nefri] '[target line]command' $file_path\n# 正则模式: 选项, 正则匹配式, 命令\nsed  [-nefri] '/regex/command' $file_path\n# 混合模式: 选项, 目标行与正则式组合范围, 命令\nsed [-nefri] 'line,/regex/command' $file_path\n```\n### **sed 的常用选项**\n``` bash\n1. -n:  silent 静默模式, 只输出被 sed 处理过的行;\n2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:\n        sed -e '$d' -e '/regex/p' $file_path\n3. -f:  执行给定文件里的命令;\n4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:\n        +, ?, |, ()\n        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;\n5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;\n```\n### **sed 的 command**\n``` bash\n1. i:   insert 到 目标行的上一行\n2. a:   append 到 目标行的下一行 \n3. c:   replace, 不能使用正则表达式\n4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:\n        s/regex/new_str/g, 替换文件中所有的 regex;\n        s/regex/new_str, 只替换每行第一个被匹配上的 regex;\n        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;\n5. d:   delete\n6. p:   print, 一般需要与 -n 选项一同使用, 否则看不出打印效果\n7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/\n```\n### **典型示例**\n``` bash\n# 打印最后一行\nsed -n '$p' $file_path\n# 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串\nsed -i -e '9,$d' -e '1,3a append' $file_path\n# 正则表达式替换(替换全部 regex)\nsed -ri 's/^(test|ping)[a-z]+.$/kill/g' $file_path\n# 打印从第9行开始到以 test 结尾的行之间的每一行\nsed -n '9,/test$/p' $file_path\n```\n``` bash\n# 结合变量, 往最后一行添加一行内容\n# 需使用\"\", 同时表示最后一行的 $ 需要转义\ncron_str='5 * * * *  sh /home/q/tools/bin/log_collect.sh 1>/dev/null'\nsed \"\\$a ${cron_str}\" /var/spool/cron/root\n```\n\n### **参考链接**\n- [linux之sed用法](http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html)\n- [linux sed命令详解](http://www.iteye.com/topic/587673)\n\n","slug":"linux-text-sed命令整理","published":1,"updated":"2018-01-04T14:58:47.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5s000jj1jxvh981tm6","content":"<blockquote>\n<p>stream editor: 流式文本编辑器;<br>sed 命令的侧重点在于对文本的编辑;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"sed-的基本模式\"><a href=\"#sed-的基本模式\" class=\"headerlink\" title=\"sed 的基本模式\"></a><strong>sed 的基本模式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标准模式: 选项, 目标行范围, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'[target line]command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则模式: 选项, 正则匹配式, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'/regex/command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 混合模式: 选项, 目标行与正则式组合范围, 命令</span></span><br><span class=\"line\">sed [-nefri] <span class=\"string\">'line,/regex/command'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的常用选项\"><a href=\"#sed-的常用选项\" class=\"headerlink\" title=\"sed 的常用选项\"></a><strong>sed 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. -n:  silent 静默模式, 只输出被 sed 处理过的行;</span><br><span class=\"line\">2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:</span><br><span class=\"line\">        sed -e <span class=\"string\">'$d'</span> -e <span class=\"string\">'/regex/p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\">3. -f:  执行给定文件里的命令;</span><br><span class=\"line\">4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:</span><br><span class=\"line\">        +, ?, |, ()</span><br><span class=\"line\">        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;</span><br><span class=\"line\">5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的-command\"><a href=\"#sed-的-command\" class=\"headerlink\" title=\"sed 的 command\"></a><strong>sed 的 command</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. i:   insert 到 目标行的上一行</span><br><span class=\"line\">2. a:   append 到 目标行的下一行 </span><br><span class=\"line\">3. c:   replace, 不能使用正则表达式</span><br><span class=\"line\">4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:</span><br><span class=\"line\">        s/regex/new_str/g, 替换文件中所有的 regex;</span><br><span class=\"line\">        s/regex/new_str, 只替换每行第一个被匹配上的 regex;</span><br><span class=\"line\">        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;</span><br><span class=\"line\">5. d:   delete</span><br><span class=\"line\">6. p:   <span class=\"built_in\">print</span>, 一般需要与 -n 选项一同使用, 否则看不出打印效果</span><br><span class=\"line\">7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/</span><br></pre></td></tr></table></figure>\n<h3 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a><strong>典型示例</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印最后一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'$p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串</span></span><br><span class=\"line\">sed -i -e <span class=\"string\">'9,$d'</span> -e <span class=\"string\">'1,3a append'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则表达式替换(替换全部 regex)</span></span><br><span class=\"line\">sed -ri <span class=\"string\">'s/^(test|ping)[a-z]+.$/kill/g'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 打印从第9行开始到以 test 结尾的行之间的每一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'9,/test$/p'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 结合变量, 往最后一行添加一行内容</span></span><br><span class=\"line\"><span class=\"comment\"># 需使用\"\", 同时表示最后一行的 $ 需要转义</span></span><br><span class=\"line\">cron_str=<span class=\"string\">'5 * * * *  sh /home/q/tools/bin/log_collect.sh 1&gt;/dev/null'</span></span><br><span class=\"line\">sed <span class=\"string\">\"\\$a <span class=\"variable\">$&#123;cron_str&#125;</span>\"</span> /var/spool/cron/root</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html\" target=\"_blank\" rel=\"noopener\">linux之sed用法</a></li>\n<li><a href=\"http://www.iteye.com/topic/587673\" target=\"_blank\" rel=\"noopener\">linux sed命令详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>stream editor: 流式文本编辑器;<br>sed 命令的侧重点在于对文本的编辑;</p>\n</blockquote>","more":"<h3 id=\"sed-的基本模式\"><a href=\"#sed-的基本模式\" class=\"headerlink\" title=\"sed 的基本模式\"></a><strong>sed 的基本模式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标准模式: 选项, 目标行范围, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'[target line]command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则模式: 选项, 正则匹配式, 命令</span></span><br><span class=\"line\">sed  [-nefri] <span class=\"string\">'/regex/command'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 混合模式: 选项, 目标行与正则式组合范围, 命令</span></span><br><span class=\"line\">sed [-nefri] <span class=\"string\">'line,/regex/command'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的常用选项\"><a href=\"#sed-的常用选项\" class=\"headerlink\" title=\"sed 的常用选项\"></a><strong>sed 的常用选项</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. -n:  silent 静默模式, 只输出被 sed 处理过的行;</span><br><span class=\"line\">2. -e:  --expression, 指定命令, 可以使用多个 -e 执行多个命令:</span><br><span class=\"line\">        sed -e <span class=\"string\">'$d'</span> -e <span class=\"string\">'/regex/p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\">3. -f:  执行给定文件里的命令;</span><br><span class=\"line\">4. -r:  --regexp-extended, 使 sed 支持拓展的正则表达式语法, 拓展的正则表达式较常规的正则表达式增加支持了如下语法:</span><br><span class=\"line\">        +, ?, |, ()</span><br><span class=\"line\">        由于这些拓展语法也非常常见, 所以推荐若使用 sed 的 regex 功能时带上 -r 选项;</span><br><span class=\"line\">5. -i:  直接在指定的文件里修改编辑, stdout 不输出任何内容;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sed-的-command\"><a href=\"#sed-的-command\" class=\"headerlink\" title=\"sed 的 command\"></a><strong>sed 的 command</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. i:   insert 到 目标行的上一行</span><br><span class=\"line\">2. a:   append 到 目标行的下一行 </span><br><span class=\"line\">3. c:   replace, 不能使用正则表达式</span><br><span class=\"line\">4. s:   replace, 使用正则表达式, 一般需要与 -r 配合使用, 模式为:</span><br><span class=\"line\">        s/regex/new_str/g, 替换文件中所有的 regex;</span><br><span class=\"line\">        s/regex/new_str, 只替换每行第一个被匹配上的 regex;</span><br><span class=\"line\">        s/regex/new_str/p, 如果某行被匹配上了就打印出来, 常与 -n 选项一同使用;</span><br><span class=\"line\">5. d:   delete</span><br><span class=\"line\">6. p:   <span class=\"built_in\">print</span>, 一般需要与 -n 选项一同使用, 否则看不出打印效果</span><br><span class=\"line\">7. y:   按每个字符映射, 模式案例: y/1234567890/ABCDEFGHIJ/</span><br></pre></td></tr></table></figure>\n<h3 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a><strong>典型示例</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印最后一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'$p'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 指定两种操作, 删除9到最后一行, 以及向1到3行后追加 'append' 字符串</span></span><br><span class=\"line\">sed -i -e <span class=\"string\">'9,$d'</span> -e <span class=\"string\">'1,3a append'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 正则表达式替换(替换全部 regex)</span></span><br><span class=\"line\">sed -ri <span class=\"string\">'s/^(test|ping)[a-z]+.$/kill/g'</span> <span class=\"variable\">$file_path</span></span><br><span class=\"line\"><span class=\"comment\"># 打印从第9行开始到以 test 结尾的行之间的每一行</span></span><br><span class=\"line\">sed -n <span class=\"string\">'9,/test$/p'</span> <span class=\"variable\">$file_path</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 结合变量, 往最后一行添加一行内容</span></span><br><span class=\"line\"><span class=\"comment\"># 需使用\"\", 同时表示最后一行的 $ 需要转义</span></span><br><span class=\"line\">cron_str=<span class=\"string\">'5 * * * *  sh /home/q/tools/bin/log_collect.sh 1&gt;/dev/null'</span></span><br><span class=\"line\">sed <span class=\"string\">\"\\$a <span class=\"variable\">$&#123;cron_str&#125;</span>\"</span> /var/spool/cron/root</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html\" target=\"_blank\" rel=\"noopener\">linux之sed用法</a></li>\n<li><a href=\"http://www.iteye.com/topic/587673\" target=\"_blank\" rel=\"noopener\">linux sed命令详解</a></li>\n</ul>"},{"title":"bash 条件判断全梳理","date":"2016-09-01T09:52:36.000Z","_content":"\n> 本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)\n\n<!--more-->\n\n## **bash 条件判断 的类型与逻辑运算符**\n\n### **字符串比较**\n1. `=`同`==`, 相同为真;\n2. `!=`, 不相同为真;\n3. `-z`, 长度为0(空)为真;\n4. `-n`, 长度不为0(非空)为真;\n5. `<`, 按字典序小于为真;\n6. `>`, 按字典序大于为真;\n\n### **整数比较**\n1. `-eq`, equals, 相等为真;\n2. `-ne`, not equals, 不相等为真;\n3. `-gt`, greater than, 大于为真;\n4. `-ge`, greater equals, 大于等于为真;\n5. `-lt`, less than, 小于为真;\n6. `-le`, less equals, 小于等于为真;\n7. `>`, 大于;\n8. `>=`, 大于等于;\n9. `<`, 小于;\n10. `<=`, 小于等于;\n11. `==`, 等于;\n12. `!=`, 不等于;\n\n### **文件比较**\n1. `-e`, exists, 文件存在为真\n2. `-r`, read, 用户可读为真 \n3. `-w`, write, 用户可写为真 \n4. `-x`, execute, 用户可执行为真 \n5. `-f`, file, 文件为正规文件为真 \n6. `-d`, directory, 文件为目录为真\n7. `-L`, link, 文件为链接文件为真\n8. `-c`, char, 文件为字符特殊文件为真 \n9. `-b`, block, 文件为块特殊文件为真 \n10. `-s`, 文件大小非0时为真 \n11. `-t`, 当文件描述符(默认为1)指定的设备为终端时为真\n12. `-nt`, newer than, 更新时间更晚为真;\n13. `-ot`, older than, 更新时间更早为真;\n\n### **逻辑比较**\n1. `-a`, and, 逻辑与;\n2. `-o`, or, 逻辑或;\n3. `!`, 逻辑非;\n4. `&&`, 逻辑与( 支持短路 );\n5. `||`, 逻辑或( 支持短路 );\n\n&nbsp;\n## **bash 条件判断 的命令(关键字)与语法**\n\n### **test 与 [ ]**\n`test` 与 `[` 是 shell 的内置命令;\n`test` 和 `[]` 可以用于比较字符串, 整数, 文件, `test expr `与`[ expr ]`有等价的效果;\n\n#### **字符串比较**\n`test`可以使用`=`, `==`, `!=`比较, bash 4.1版本下也能使用`-n`, `-z`比较字符串( 旧版本可能不支持该方式 );\n`[]`可以使用上述全部的比较符号;\n``` bash\nif !test $str1 == $str2; then ... ; fi\nif ! [ $str1 == $str2 ]; then ... ; fi\n```\n`test` 与 `[]` 也可以使用 `<` 和 `>` 作字符串比较; 但是有一点要注意, `test`和`[`是 shell 的内置命令, 使用 `<` 和 `>` 需要转义, 否则会被当成重定向; \n#### **整数比较**\n`test`和`[]`均可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符;\n使用`<`,`>`,`==`,`!=`虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;\n``` bash\nif test $1 -le 0; then ... ; fi\nif [ $1 -le 0 ]; then ... ; fi\n```\n#### **文件比较**\n`test`和`[]`均可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n``` bash\nif test -e /usr/local/localtime; then ... ; fi\nif [ -e /usr/local/localtime ]; then ... ; fi\n```\n#### **逻辑比较**\n`test`和`[]`只能使用`-a`, `-o`和`!`运算符, 但`-a`和`-o` 不支持逻辑短路;\n``` bash\nif !test $str1 == $str2 -a -n $str3; then ... ; fi\nif [ $str1 == $str2 -a -n $str3 ]; then ... ; fi\n```\n#### **test的返回值**\n`test`可以独立于`if`使用, 其执行结果( 0为真, 1为假 )可以使用`$?`来接收;\n``` bash\ntest -z \"$1\"; echo \"$?\"\n```\n\n### **bash关键字 [[ ]] ( 推荐使用 )**\n`[[` 是 bash 的关键字, 而不是命令;\n`[[ ]]` 比 `[]` 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 `[[ ]]`;\n\n#### **字符串比较**\n`[[ ]]` 除了可以使用基本的 `=`, `==`, `!=`, `-n`, `-z` 之外, 其 `=`,`==` 和 `!=`还有通配符模式匹配的功能:\n``` bash\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" == t* ]]; then ... ; fi\n```\n`[[ ]]` 还可以使用支持正则表达式的 `=~` 运算符:\n``` bash\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" =~ ^t[a-z].t$ ]]; then ... ; fi\n```\n`[[ ]]`也可以使用`<`和`>`作字符串比较; 由于`[[`是bash内置的关键字, `<`和`>`并不会被当成重定向, 所以可以不需要转义;\n#### **整数比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);\n#### **算术拓展**\n`[[]]`支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:\n``` bash\nif [[ 1+1 -eq 2 ]]; then ... ; fi\n```\n此功能不推荐使用;\n#### **文件比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n#### **逻辑比较**\n`[[ ]]`只能使用`&&`, `||`, `!`运算符, 且`&&`和`||`支持逻辑短路;\n\n### **(( ))的使用场景**\n无论是`test`, `[]`还是`[[ ]]`, 都不能很好地使用`<`和`>`处理整数的比较运算;\n所以通常使用`(())`来处理整数的比较运算;\n`(())`可以使用`>`, `>=`, `<`, `<=`,`==`,`!=`运算符;\n``` bash\nif (( 1 + 1 == 2 )); then ... ; fi\n```\n使用`(())`的时候, 如果使用到了变量, 可以不需要加上`$`符号;\n\n&nbsp;\n## **总结**\n\n|-           | test 与 [ ]                                          | [[ ]]                                                | (( ))                 |\n|:----------:|:----------------------------------------------------:|:----------------------------------------------------:|:---------------------:|\n| 字符串比较 | =, ==, !=, -n, -z, \\\\<, \\\\>                          | =, ==, !=, -n, -z, <, >                              | 不支持                |\n| 整数比较   | -eq, -gt, -ge, -lt, -le, -ne                         | -eq, -gt, -ge, -lt, -le, -ne                         | \\>, >=, <, <=, ==, != |\n| 文件比较   | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | 不支持                |\n| 逻辑比较   | -a, -o, !                                            | &&, &#124;&#124;, !                                  | &&, &#124;&#124;, !   |\n\n&nbsp;\n## **参考链接**\n","source":"_posts/linux-shell--bash条件判断全梳理.md","raw":"---\ntitle: bash 条件判断全梳理\ndate: 2016-09-01 17:52:36\ntags: \n  - linux:shell\ncategories:\n  - linux\n  - shell\n---\n\n> 本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)\n\n<!--more-->\n\n## **bash 条件判断 的类型与逻辑运算符**\n\n### **字符串比较**\n1. `=`同`==`, 相同为真;\n2. `!=`, 不相同为真;\n3. `-z`, 长度为0(空)为真;\n4. `-n`, 长度不为0(非空)为真;\n5. `<`, 按字典序小于为真;\n6. `>`, 按字典序大于为真;\n\n### **整数比较**\n1. `-eq`, equals, 相等为真;\n2. `-ne`, not equals, 不相等为真;\n3. `-gt`, greater than, 大于为真;\n4. `-ge`, greater equals, 大于等于为真;\n5. `-lt`, less than, 小于为真;\n6. `-le`, less equals, 小于等于为真;\n7. `>`, 大于;\n8. `>=`, 大于等于;\n9. `<`, 小于;\n10. `<=`, 小于等于;\n11. `==`, 等于;\n12. `!=`, 不等于;\n\n### **文件比较**\n1. `-e`, exists, 文件存在为真\n2. `-r`, read, 用户可读为真 \n3. `-w`, write, 用户可写为真 \n4. `-x`, execute, 用户可执行为真 \n5. `-f`, file, 文件为正规文件为真 \n6. `-d`, directory, 文件为目录为真\n7. `-L`, link, 文件为链接文件为真\n8. `-c`, char, 文件为字符特殊文件为真 \n9. `-b`, block, 文件为块特殊文件为真 \n10. `-s`, 文件大小非0时为真 \n11. `-t`, 当文件描述符(默认为1)指定的设备为终端时为真\n12. `-nt`, newer than, 更新时间更晚为真;\n13. `-ot`, older than, 更新时间更早为真;\n\n### **逻辑比较**\n1. `-a`, and, 逻辑与;\n2. `-o`, or, 逻辑或;\n3. `!`, 逻辑非;\n4. `&&`, 逻辑与( 支持短路 );\n5. `||`, 逻辑或( 支持短路 );\n\n&nbsp;\n## **bash 条件判断 的命令(关键字)与语法**\n\n### **test 与 [ ]**\n`test` 与 `[` 是 shell 的内置命令;\n`test` 和 `[]` 可以用于比较字符串, 整数, 文件, `test expr `与`[ expr ]`有等价的效果;\n\n#### **字符串比较**\n`test`可以使用`=`, `==`, `!=`比较, bash 4.1版本下也能使用`-n`, `-z`比较字符串( 旧版本可能不支持该方式 );\n`[]`可以使用上述全部的比较符号;\n``` bash\nif !test $str1 == $str2; then ... ; fi\nif ! [ $str1 == $str2 ]; then ... ; fi\n```\n`test` 与 `[]` 也可以使用 `<` 和 `>` 作字符串比较; 但是有一点要注意, `test`和`[`是 shell 的内置命令, 使用 `<` 和 `>` 需要转义, 否则会被当成重定向; \n#### **整数比较**\n`test`和`[]`均可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符;\n使用`<`,`>`,`==`,`!=`虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;\n``` bash\nif test $1 -le 0; then ... ; fi\nif [ $1 -le 0 ]; then ... ; fi\n```\n#### **文件比较**\n`test`和`[]`均可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n``` bash\nif test -e /usr/local/localtime; then ... ; fi\nif [ -e /usr/local/localtime ]; then ... ; fi\n```\n#### **逻辑比较**\n`test`和`[]`只能使用`-a`, `-o`和`!`运算符, 但`-a`和`-o` 不支持逻辑短路;\n``` bash\nif !test $str1 == $str2 -a -n $str3; then ... ; fi\nif [ $str1 == $str2 -a -n $str3 ]; then ... ; fi\n```\n#### **test的返回值**\n`test`可以独立于`if`使用, 其执行结果( 0为真, 1为假 )可以使用`$?`来接收;\n``` bash\ntest -z \"$1\"; echo \"$?\"\n```\n\n### **bash关键字 [[ ]] ( 推荐使用 )**\n`[[` 是 bash 的关键字, 而不是命令;\n`[[ ]]` 比 `[]` 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 `[[ ]]`;\n\n#### **字符串比较**\n`[[ ]]` 除了可以使用基本的 `=`, `==`, `!=`, `-n`, `-z` 之外, 其 `=`,`==` 和 `!=`还有通配符模式匹配的功能:\n``` bash\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" == t* ]]; then ... ; fi\n```\n`[[ ]]` 还可以使用支持正则表达式的 `=~` 运算符:\n``` bash\n# 模式串不能加双引号, 否则会被当作普通串\nif [[ \"test\" =~ ^t[a-z].t$ ]]; then ... ; fi\n```\n`[[ ]]`也可以使用`<`和`>`作字符串比较; 由于`[[`是bash内置的关键字, `<`和`>`并不会被当成重定向, 所以可以不需要转义;\n#### **整数比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-eq`, `-gt`, `-ge`, `-lt`, `-le`, `-ne` 作整数比较, 但不能使用 `>`, `>=`, `<`, `<=`,`==`,`!=` 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);\n#### **算术拓展**\n`[[]]`支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:\n``` bash\nif [[ 1+1 -eq 2 ]]; then ... ; fi\n```\n此功能不推荐使用;\n#### **文件比较**\n和`test`, `[]`一样, `[[ ]]`可以使用`-e`, `-r`, `-w`, `-x`等文件比较逻辑;\n#### **逻辑比较**\n`[[ ]]`只能使用`&&`, `||`, `!`运算符, 且`&&`和`||`支持逻辑短路;\n\n### **(( ))的使用场景**\n无论是`test`, `[]`还是`[[ ]]`, 都不能很好地使用`<`和`>`处理整数的比较运算;\n所以通常使用`(())`来处理整数的比较运算;\n`(())`可以使用`>`, `>=`, `<`, `<=`,`==`,`!=`运算符;\n``` bash\nif (( 1 + 1 == 2 )); then ... ; fi\n```\n使用`(())`的时候, 如果使用到了变量, 可以不需要加上`$`符号;\n\n&nbsp;\n## **总结**\n\n|-           | test 与 [ ]                                          | [[ ]]                                                | (( ))                 |\n|:----------:|:----------------------------------------------------:|:----------------------------------------------------:|:---------------------:|\n| 字符串比较 | =, ==, !=, -n, -z, \\\\<, \\\\>                          | =, ==, !=, -n, -z, <, >                              | 不支持                |\n| 整数比较   | -eq, -gt, -ge, -lt, -le, -ne                         | -eq, -gt, -ge, -lt, -le, -ne                         | \\>, >=, <, <=, ==, != |\n| 文件比较   | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | -e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot | 不支持                |\n| 逻辑比较   | -a, -o, !                                            | &&, &#124;&#124;, !                                  | &&, &#124;&#124;, !   |\n\n&nbsp;\n## **参考链接**\n","slug":"linux-shell--bash条件判断全梳理","published":1,"updated":"2018-01-20T13:10:27.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5t000lj1jxfiitwb80","content":"<blockquote>\n<p>本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"bash-条件判断-的类型与逻辑运算符\"><a href=\"#bash-条件判断-的类型与逻辑运算符\" class=\"headerlink\" title=\"bash 条件判断 的类型与逻辑运算符\"></a><strong>bash 条件判断 的类型与逻辑运算符</strong></h2><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h3><ol>\n<li><code>=</code>同<code>==</code>, 相同为真;</li>\n<li><code>!=</code>, 不相同为真;</li>\n<li><code>-z</code>, 长度为0(空)为真;</li>\n<li><code>-n</code>, 长度不为0(非空)为真;</li>\n<li><code>&lt;</code>, 按字典序小于为真;</li>\n<li><code>&gt;</code>, 按字典序大于为真;</li>\n</ol>\n<h3 id=\"整数比较\"><a href=\"#整数比较\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h3><ol>\n<li><code>-eq</code>, equals, 相等为真;</li>\n<li><code>-ne</code>, not equals, 不相等为真;</li>\n<li><code>-gt</code>, greater than, 大于为真;</li>\n<li><code>-ge</code>, greater equals, 大于等于为真;</li>\n<li><code>-lt</code>, less than, 小于为真;</li>\n<li><code>-le</code>, less equals, 小于等于为真;</li>\n<li><code>&gt;</code>, 大于;</li>\n<li><code>&gt;=</code>, 大于等于;</li>\n<li><code>&lt;</code>, 小于;</li>\n<li><code>&lt;=</code>, 小于等于;</li>\n<li><code>==</code>, 等于;</li>\n<li><code>!=</code>, 不等于;</li>\n</ol>\n<h3 id=\"文件比较\"><a href=\"#文件比较\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h3><ol>\n<li><code>-e</code>, exists, 文件存在为真</li>\n<li><code>-r</code>, read, 用户可读为真 </li>\n<li><code>-w</code>, write, 用户可写为真 </li>\n<li><code>-x</code>, execute, 用户可执行为真 </li>\n<li><code>-f</code>, file, 文件为正规文件为真 </li>\n<li><code>-d</code>, directory, 文件为目录为真</li>\n<li><code>-L</code>, link, 文件为链接文件为真</li>\n<li><code>-c</code>, char, 文件为字符特殊文件为真 </li>\n<li><code>-b</code>, block, 文件为块特殊文件为真 </li>\n<li><code>-s</code>, 文件大小非0时为真 </li>\n<li><code>-t</code>, 当文件描述符(默认为1)指定的设备为终端时为真</li>\n<li><code>-nt</code>, newer than, 更新时间更晚为真;</li>\n<li><code>-ot</code>, older than, 更新时间更早为真;</li>\n</ol>\n<h3 id=\"逻辑比较\"><a href=\"#逻辑比较\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h3><ol>\n<li><code>-a</code>, and, 逻辑与;</li>\n<li><code>-o</code>, or, 逻辑或;</li>\n<li><code>!</code>, 逻辑非;</li>\n<li><code>&amp;&amp;</code>, 逻辑与( 支持短路 );</li>\n<li><code>||</code>, 逻辑或( 支持短路 );</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"bash-条件判断-的命令-关键字-与语法\"><a href=\"#bash-条件判断-的命令-关键字-与语法\" class=\"headerlink\" title=\"bash 条件判断 的命令(关键字)与语法\"></a><strong>bash 条件判断 的命令(关键字)与语法</strong></h2><h3 id=\"test-与\"><a href=\"#test-与\" class=\"headerlink\" title=\"test 与 [ ]\"></a><strong>test 与 [ ]</strong></h3><p><code>test</code> 与 <code>[</code> 是 shell 的内置命令;<br><code>test</code> 和 <code>[]</code> 可以用于比较字符串, 整数, 文件, <code>test expr</code>与<code>[ expr ]</code>有等价的效果;</p>\n<h4 id=\"字符串比较-1\"><a href=\"#字符串比较-1\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>test</code>可以使用<code>=</code>, <code>==</code>, <code>!=</code>比较, bash 4.1版本下也能使用<code>-n</code>, <code>-z</code>比较字符串( 旧版本可能不支持该方式 );<br><code>[]</code>可以使用上述全部的比较符号;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> !<span class=\"built_in\">test</span> <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span>; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ! [ <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>test</code> 与 <code>[]</code> 也可以使用 <code>&lt;</code> 和 <code>&gt;</code> 作字符串比较; 但是有一点要注意, <code>test</code>和<code>[</code>是 shell 的内置命令, 使用 <code>&lt;</code> 和 <code>&gt;</code> 需要转义, 否则会被当成重定向; </p>\n<h4 id=\"整数比较-1\"><a href=\"#整数比较-1\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符;<br>使用<code>&lt;</code>,<code>&gt;</code>,<code>==</code>,<code>!=</code>虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> <span class=\"variable\">$1</span> -le 0; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -le 0 ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件比较-1\"><a href=\"#文件比较-1\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> -e /usr/<span class=\"built_in\">local</span>/localtime; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -e /usr/<span class=\"built_in\">local</span>/localtime ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"逻辑比较-1\"><a href=\"#逻辑比较-1\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>test</code>和<code>[]</code>只能使用<code>-a</code>, <code>-o</code>和<code>!</code>运算符, 但<code>-a</code>和<code>-o</code> 不支持逻辑短路;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> !<span class=\"built_in\">test</span> <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> -a -n <span class=\"variable\">$str3</span>; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> -a -n <span class=\"variable\">$str3</span> ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"test的返回值\"><a href=\"#test的返回值\" class=\"headerlink\" title=\"test的返回值\"></a><strong>test的返回值</strong></h4><p><code>test</code>可以独立于<code>if</code>使用, 其执行结果( 0为真, 1为假 )可以使用<code>$?</code>来接收;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> -z <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>; <span class=\"built_in\">echo</span> <span class=\"string\">\"$?\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash关键字-推荐使用\"><a href=\"#bash关键字-推荐使用\" class=\"headerlink\" title=\"bash关键字 [[ ]] ( 推荐使用 )\"></a><strong>bash关键字 [[ ]] ( 推荐使用 )</strong></h3><p><code>[[</code> 是 bash 的关键字, 而不是命令;<br><code>[[ ]]</code> 比 <code>[]</code> 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 <code>[[ ]]</code>;</p>\n<h4 id=\"字符串比较-2\"><a href=\"#字符串比较-2\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>[[ ]]</code> 除了可以使用基本的 <code>=</code>, <code>==</code>, <code>!=</code>, <code>-n</code>, <code>-z</code> 之外, 其 <code>=</code>,<code>==</code> 和 <code>!=</code>还有通配符模式匹配的功能:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模式串不能加双引号, 否则会被当作普通串</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"test\"</span> == t* ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code> 还可以使用支持正则表达式的 <code>=~</code> 运算符:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模式串不能加双引号, 否则会被当作普通串</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"test\"</span> =~ ^t[a-z].t$ ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code>也可以使用<code>&lt;</code>和<code>&gt;</code>作字符串比较; 由于<code>[[</code>是bash内置的关键字, <code>&lt;</code>和<code>&gt;</code>并不会被当成重定向, 所以可以不需要转义;</p>\n<h4 id=\"整数比较-2\"><a href=\"#整数比较-2\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);</p>\n<h4 id=\"算术拓展\"><a href=\"#算术拓展\" class=\"headerlink\" title=\"算术拓展\"></a><strong>算术拓展</strong></h4><p><code>[[]]</code>支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [[ 1+1 -eq 2 ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p>此功能不推荐使用;</p>\n<h4 id=\"文件比较-2\"><a href=\"#文件比较-2\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;</p>\n<h4 id=\"逻辑比较-2\"><a href=\"#逻辑比较-2\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>[[ ]]</code>只能使用<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>运算符, 且<code>&amp;&amp;</code>和<code>||</code>支持逻辑短路;</p>\n<h3 id=\"的使用场景\"><a href=\"#的使用场景\" class=\"headerlink\" title=\"(( ))的使用场景\"></a><strong>(( ))的使用场景</strong></h3><p>无论是<code>test</code>, <code>[]</code>还是<code>[[ ]]</code>, 都不能很好地使用<code>&lt;</code>和<code>&gt;</code>处理整数的比较运算;<br>所以通常使用<code>(())</code>来处理整数的比较运算;<br><code>(())</code>可以使用<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code>运算符;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (( 1 + 1 == 2 )); <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p>使用<code>(())</code>的时候, 如果使用到了变量, 可以不需要加上<code>$</code>符号;</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">-</th>\n<th style=\"text-align:center\">test 与 [ ]</th>\n<th style=\"text-align:center\">[[ ]]</th>\n<th style=\"text-align:center\">(( ))</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">字符串比较</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, \\&lt;, \\&gt;</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, &lt;, &gt;</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">整数比较</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">>, &gt;=, &lt;, &lt;=, ==, !=</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文件比较</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">逻辑比较</td>\n<td style=\"text-align:center\">-a, -o, !</td>\n<td style=\"text-align:center\">&amp;&amp;, &#124;&#124;, !</td>\n<td style=\"text-align:center\">&amp;&amp;, &#124;&#124;, !</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2>","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文基于 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)</p>\n</blockquote>","more":"<h2 id=\"bash-条件判断-的类型与逻辑运算符\"><a href=\"#bash-条件判断-的类型与逻辑运算符\" class=\"headerlink\" title=\"bash 条件判断 的类型与逻辑运算符\"></a><strong>bash 条件判断 的类型与逻辑运算符</strong></h2><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h3><ol>\n<li><code>=</code>同<code>==</code>, 相同为真;</li>\n<li><code>!=</code>, 不相同为真;</li>\n<li><code>-z</code>, 长度为0(空)为真;</li>\n<li><code>-n</code>, 长度不为0(非空)为真;</li>\n<li><code>&lt;</code>, 按字典序小于为真;</li>\n<li><code>&gt;</code>, 按字典序大于为真;</li>\n</ol>\n<h3 id=\"整数比较\"><a href=\"#整数比较\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h3><ol>\n<li><code>-eq</code>, equals, 相等为真;</li>\n<li><code>-ne</code>, not equals, 不相等为真;</li>\n<li><code>-gt</code>, greater than, 大于为真;</li>\n<li><code>-ge</code>, greater equals, 大于等于为真;</li>\n<li><code>-lt</code>, less than, 小于为真;</li>\n<li><code>-le</code>, less equals, 小于等于为真;</li>\n<li><code>&gt;</code>, 大于;</li>\n<li><code>&gt;=</code>, 大于等于;</li>\n<li><code>&lt;</code>, 小于;</li>\n<li><code>&lt;=</code>, 小于等于;</li>\n<li><code>==</code>, 等于;</li>\n<li><code>!=</code>, 不等于;</li>\n</ol>\n<h3 id=\"文件比较\"><a href=\"#文件比较\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h3><ol>\n<li><code>-e</code>, exists, 文件存在为真</li>\n<li><code>-r</code>, read, 用户可读为真 </li>\n<li><code>-w</code>, write, 用户可写为真 </li>\n<li><code>-x</code>, execute, 用户可执行为真 </li>\n<li><code>-f</code>, file, 文件为正规文件为真 </li>\n<li><code>-d</code>, directory, 文件为目录为真</li>\n<li><code>-L</code>, link, 文件为链接文件为真</li>\n<li><code>-c</code>, char, 文件为字符特殊文件为真 </li>\n<li><code>-b</code>, block, 文件为块特殊文件为真 </li>\n<li><code>-s</code>, 文件大小非0时为真 </li>\n<li><code>-t</code>, 当文件描述符(默认为1)指定的设备为终端时为真</li>\n<li><code>-nt</code>, newer than, 更新时间更晚为真;</li>\n<li><code>-ot</code>, older than, 更新时间更早为真;</li>\n</ol>\n<h3 id=\"逻辑比较\"><a href=\"#逻辑比较\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h3><ol>\n<li><code>-a</code>, and, 逻辑与;</li>\n<li><code>-o</code>, or, 逻辑或;</li>\n<li><code>!</code>, 逻辑非;</li>\n<li><code>&amp;&amp;</code>, 逻辑与( 支持短路 );</li>\n<li><code>||</code>, 逻辑或( 支持短路 );</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"bash-条件判断-的命令-关键字-与语法\"><a href=\"#bash-条件判断-的命令-关键字-与语法\" class=\"headerlink\" title=\"bash 条件判断 的命令(关键字)与语法\"></a><strong>bash 条件判断 的命令(关键字)与语法</strong></h2><h3 id=\"test-与\"><a href=\"#test-与\" class=\"headerlink\" title=\"test 与 [ ]\"></a><strong>test 与 [ ]</strong></h3><p><code>test</code> 与 <code>[</code> 是 shell 的内置命令;<br><code>test</code> 和 <code>[]</code> 可以用于比较字符串, 整数, 文件, <code>test expr</code>与<code>[ expr ]</code>有等价的效果;</p>\n<h4 id=\"字符串比较-1\"><a href=\"#字符串比较-1\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>test</code>可以使用<code>=</code>, <code>==</code>, <code>!=</code>比较, bash 4.1版本下也能使用<code>-n</code>, <code>-z</code>比较字符串( 旧版本可能不支持该方式 );<br><code>[]</code>可以使用上述全部的比较符号;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> !<span class=\"built_in\">test</span> <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span>; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ! [ <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>test</code> 与 <code>[]</code> 也可以使用 <code>&lt;</code> 和 <code>&gt;</code> 作字符串比较; 但是有一点要注意, <code>test</code>和<code>[</code>是 shell 的内置命令, 使用 <code>&lt;</code> 和 <code>&gt;</code> 需要转义, 否则会被当成重定向; </p>\n<h4 id=\"整数比较-1\"><a href=\"#整数比较-1\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符;<br>使用<code>&lt;</code>,<code>&gt;</code>,<code>==</code>,<code>!=</code>虽然语法不会报错, 但是会被当成字符串以字典序比较, 不能确保结果的正确性;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> <span class=\"variable\">$1</span> -le 0; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -le 0 ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件比较-1\"><a href=\"#文件比较-1\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p><code>test</code>和<code>[]</code>均可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">test</span> -e /usr/<span class=\"built_in\">local</span>/localtime; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -e /usr/<span class=\"built_in\">local</span>/localtime ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"逻辑比较-1\"><a href=\"#逻辑比较-1\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>test</code>和<code>[]</code>只能使用<code>-a</code>, <code>-o</code>和<code>!</code>运算符, 但<code>-a</code>和<code>-o</code> 不支持逻辑短路;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> !<span class=\"built_in\">test</span> <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> -a -n <span class=\"variable\">$str3</span>; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$str1</span> == <span class=\"variable\">$str2</span> -a -n <span class=\"variable\">$str3</span> ]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"test的返回值\"><a href=\"#test的返回值\" class=\"headerlink\" title=\"test的返回值\"></a><strong>test的返回值</strong></h4><p><code>test</code>可以独立于<code>if</code>使用, 其执行结果( 0为真, 1为假 )可以使用<code>$?</code>来接收;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">test</span> -z <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>; <span class=\"built_in\">echo</span> <span class=\"string\">\"$?\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash关键字-推荐使用\"><a href=\"#bash关键字-推荐使用\" class=\"headerlink\" title=\"bash关键字 [[ ]] ( 推荐使用 )\"></a><strong>bash关键字 [[ ]] ( 推荐使用 )</strong></h3><p><code>[[</code> 是 bash 的关键字, 而不是命令;<br><code>[[ ]]</code> 比 <code>[]</code> 更通用, 更安全, 功能更强大; 在生产环境中, 推荐使用 <code>[[ ]]</code>;</p>\n<h4 id=\"字符串比较-2\"><a href=\"#字符串比较-2\" class=\"headerlink\" title=\"字符串比较\"></a><strong>字符串比较</strong></h4><p><code>[[ ]]</code> 除了可以使用基本的 <code>=</code>, <code>==</code>, <code>!=</code>, <code>-n</code>, <code>-z</code> 之外, 其 <code>=</code>,<code>==</code> 和 <code>!=</code>还有通配符模式匹配的功能:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模式串不能加双引号, 否则会被当作普通串</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"test\"</span> == t* ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code> 还可以使用支持正则表达式的 <code>=~</code> 运算符:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模式串不能加双引号, 否则会被当作普通串</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"test\"</span> =~ ^t[a-z].t$ ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p><code>[[ ]]</code>也可以使用<code>&lt;</code>和<code>&gt;</code>作字符串比较; 由于<code>[[</code>是bash内置的关键字, <code>&lt;</code>和<code>&gt;</code>并不会被当成重定向, 所以可以不需要转义;</p>\n<h4 id=\"整数比较-2\"><a href=\"#整数比较-2\" class=\"headerlink\" title=\"整数比较\"></a><strong>整数比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-eq</code>, <code>-gt</code>, <code>-ge</code>, <code>-lt</code>, <code>-le</code>, <code>-ne</code> 作整数比较, 但不能使用 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code> 等比较运算符; 不能使用的原因也是一样的(当成字符串来处理了);</p>\n<h4 id=\"算术拓展\"><a href=\"#算术拓展\" class=\"headerlink\" title=\"算术拓展\"></a><strong>算术拓展</strong></h4><p><code>[[]]</code>支持算术拓展, 但是其对整数比较支持度较差, 算术拓展可能是一个鸡肋功能, 而且运算符与运算数之间不能有空格:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [[ 1+1 -eq 2 ]]; <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p>此功能不推荐使用;</p>\n<h4 id=\"文件比较-2\"><a href=\"#文件比较-2\" class=\"headerlink\" title=\"文件比较\"></a><strong>文件比较</strong></h4><p>和<code>test</code>, <code>[]</code>一样, <code>[[ ]]</code>可以使用<code>-e</code>, <code>-r</code>, <code>-w</code>, <code>-x</code>等文件比较逻辑;</p>\n<h4 id=\"逻辑比较-2\"><a href=\"#逻辑比较-2\" class=\"headerlink\" title=\"逻辑比较\"></a><strong>逻辑比较</strong></h4><p><code>[[ ]]</code>只能使用<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>运算符, 且<code>&amp;&amp;</code>和<code>||</code>支持逻辑短路;</p>\n<h3 id=\"的使用场景\"><a href=\"#的使用场景\" class=\"headerlink\" title=\"(( ))的使用场景\"></a><strong>(( ))的使用场景</strong></h3><p>无论是<code>test</code>, <code>[]</code>还是<code>[[ ]]</code>, 都不能很好地使用<code>&lt;</code>和<code>&gt;</code>处理整数的比较运算;<br>所以通常使用<code>(())</code>来处理整数的比较运算;<br><code>(())</code>可以使用<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,<code>==</code>,<code>!=</code>运算符;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (( 1 + 1 == 2 )); <span class=\"keyword\">then</span> ... ; <span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p>使用<code>(())</code>的时候, 如果使用到了变量, 可以不需要加上<code>$</code>符号;</p>\n<p>&nbsp;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">-</th>\n<th style=\"text-align:center\">test 与 [ ]</th>\n<th style=\"text-align:center\">[[ ]]</th>\n<th style=\"text-align:center\">(( ))</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">字符串比较</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, \\&lt;, \\&gt;</td>\n<td style=\"text-align:center\">=, ==, !=, -n, -z, &lt;, &gt;</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">整数比较</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">-eq, -gt, -ge, -lt, -le, -ne</td>\n<td style=\"text-align:center\">>, &gt;=, &lt;, &lt;=, ==, !=</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文件比较</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">-e, -r, -w, -x, -f, -d, -L, -s, -b, -c, -t, -nt, -ot</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">逻辑比较</td>\n<td style=\"text-align:center\">-a, -o, !</td>\n<td style=\"text-align:center\">&amp;&amp;, &#124;&#124;, !</td>\n<td style=\"text-align:center\">&amp;&amp;, &#124;&#124;, !</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2>"},{"title":"python 模块导入: 相关基础知识梳理","date":"2017-03-12T13:35:04.000Z","_content":"\n> python 有一个关键字和 java 一样: `import`, 其功能也类似: 在代码中引入其他的依赖(模块)以使用;\n不过, 不像 java 那么单纯, python 还要区分为 import module 和 import names 两大类; 作为一个 python 新手, 这些使用上的区别有时会令人感到迷惑;\npython 包和 java 包在概念上也有类似之处, 不过 python 的 \\__init\\__.py 规范更讲究一些, java 的 package-info.java 重要性没有那么强, python 初学者在此也很容易栽跟头;\n在使用了一段时间的 python 之后, 我突然发现, 关于模块引入相关的知识, 我还从来没有过一个系统性的整理; 故作此文以备将来查阅;\n\n<!--more-->\n\n------\n\n下面所示的是一个 python 工程结构, 包括了一个父 package 和其下的子 package , 结构比较完整; 本文将以此工程结构为例, 展开内容;\n``` python\nMyPackage\n    ├── connections.py\n    ├── constants\n    │   ├── CLIENT.py\n    │   ├── CR.py\n    │   ├── ER.py\n    │   ├── FIELD_TYPE.py\n    │   ├── FLAG.py\n    │   ├── __init__.py\n    │   ├── REFRESH.py\n    ├── converters.py\n    ├── cursors.py\n    ├── __init__.py\n    ├── release.py\n    ├── times.py\n```\n其中, 假设 connections.py 中定义了 Connection 类:\n``` python\n# connections.py\nimport _mysql\nclass Connection(_mysql.connection):\n    def __init__(self, *args, **kwargs):\n        ...\n```\n下面开始本文的内容;\n\n### **基础预备知识**\n#### **对象的 \\__name\\__ 字段**\n所有 python 程序的执行必须要有一个入口, 而我们经常见到的入口会有这么一行代码:\n``` python\nif __name__ == '__main__':\n```\n这里面涉及到了一个模块的属性: `__name__`:\n当一个模块以主模块被执行时, 该模块的 \\__name\\__ 就被解释器设定为 '\\__main\\__';\n当一个模块被其他模块引入时, 该模块的 \\__name\\__ 就被解释器设定为 '该模块的文件名';\n\n#### **内建方法: dir()**\npython 中有一个全局内建方法 `dir(p_object=None)` 可以返回目标作用域里所有的成员 (names);\n当方法参数 p_object 为 None 时, 默认返回当前作用域内的所有成员:\n``` python\n# 在 python shell 里执行, 作用域为主模块, 展示模块属性\n>>> import MyPackage\n>>> dir()\n['MyPackage', '__builtins__', '__doc__', '__name__', '__package__']\n```\n\n``` python\n# 在方法内部执行, 作用域为方法内, 展示方法的字段\ndef print_dir(num=1, str=None):\n    print dir()\n    \nif __name__ == '__main__':\n    print_dir()\n\noutput:\n['num', 'str']\n```\n如果指定了目标作用域(对象), 则无论在哪里指定 dir () 方法, 都只打印指定目标的成员;\n``` python\nfrom MyPackage.connections import Connection\n# 指定作用域\ndef print_dir(obj=None):\n    print dir(obj)\n\nif __name__ == '__main__':\n    conn = Connection()\n    print_dir(conn)\n\noutput:\n['__doc__', '__init__', '__module__']\n```\n\n#### **import 的规则语法**\npython 导入其他模块分为两种: import module/package 与 import names (包括变量, 函数, 类等);\nimport module/package 的语法如下:\n``` python\nimport MyPackage\nimport MyPackage.connections\n```\nimport names 的语法如下:\n``` python\n# 引入类\nfrom MyPackage.connections import Connection\n# 引入方法\nfrom MyPackage.connections import numeric_part\n# 引入 __all__ 指定的所有 names\nfrom MyPackage import *\n```\n对于不同的 package, 不同的 \\__init\\__.py 文件, 这些 import 语句所产生的效果都不尽相同, 详细的区别将在下一节描述;\n\n### **\\__init\\__.py 文件的功能**\n对于 python 的每一个包来说, \\__init\\__.py 是必须的, 它控制着包的导入行为, 并可以表达非常丰富的信息; 如果没有 \\__init\\__.py 文件, 那这个包只能算是一个普通目录, 目录下的任何 python 文件都不能作为模块被导入;\n以下是几种常见的 \\__init\\__.py 文件的内容:\n\n#### **\\__init\\__.py 文件内容为空**\n\\__init\\__.py 文件必须有, 但可以是空文件, 这将是最简单的形式, 当然其所提供的功能也最简单: 标识这是一个 python 包, 仅此而已;\n如果将该包作为一个模块导入, 其实是等于什么都没导入:\n``` python\n>>> import MyPackage\n>>> dir()\n['MyPackage', '__builtins__', '__doc__', '__name__', '__package__']\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__']\n```\n通过 dir() 内建方法可以发现, 无论是当前主模块, 还是 MyPackage 包, 除了一些保留 names, 不再有其他任何自定义符号, 这时将无法直接使用 MyPackage 下的任何模块:\n``` python\n# 直接 使用 connections.py 下的 Connection 类\n>>> conn = MyPackage.connections.Connection()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'MyPackage' is not defined\n```\n\n不过, 既然 \\__init\\__.py 已经标识了这是一个 python 包, 所以对于包下所有其他的模块文件, 我们可以主动引入它们, 这算是空 \\__init\\__.py 的唯一作用:\n``` python\n# 主动引入模块\n>>> import MyPackage.connections\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n>>> dir(MyPackage.connections)\n['Connection', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'numeric_part']\n```\n这时可以发现, dir(MyPackage) 列表里有了 connections 模块, dir(MyPackage.connections) 列表里有了 Connection 类; 这时带着 python 路径, 就可以使用 target name 了:\n``` python\n>>> conn = MyPackage.connections.Connection()\n```\n另外, 如果使用 from ... import ... 主动引入目标符号:\n``` python\n>>> from MyPackage.connections import Connection\n>>> dir()\n['Connection', '__builtins__', '__doc__', '__name__', '__package__']\n```\n便可以直接将目标符号引入当前作用域, 不需要使用模块路径, 就可以直接使用:\n``` python\n>>> conn = Connection()\n```\n\n#### **在 \\__init\\__.py 中 import 其他模块**\n\\__init\\__.py 中自己主动 import 第三方模块是一种常见的操作:\n``` python\n# __init__.py\nimport connections\n```\n``` python\n>>> import MyPackage\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n# 路径是 MyPackage.connections\n>>> conn = MyPackage.connections.Connection()\n```\n或者使用 from ... import ... 语法:\n``` python\n# __init__.py\nfrom connections import Connection\n```\n``` python\n>>> import MyPackage\n>>> dir(MyPackage)\n['Connection', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n# 路径是 MyPackage\n>>> conn = MyPackage.Connection()\n```\n对于以上两种 import 方式, 结合 dir() 内建方法的展示, 可以发现在具体使用目标符号时所带路径的区别;\n\n#### **\\__init\\__.py 中的保留字段**\n(1) \\__all\\__ 字段:\n如果在代码中使用了如下的引用方式:\n``` python\nfrom MyPackage import *\n```\n解释器便会试图去指定的模块中寻找 `__all__` 字段, 将该列表中列举的所有 names 全部引入:\n``` python\n__all__ = [ 'BINARY', 'Binary', 'Connect', 'Connection', 'DATE',\n    'Date', 'Time', 'Timestamp', 'DateFromTicks', 'TimeFromTicks',\n    'TimestampFromTicks', 'DataError', 'DatabaseError', 'Error',\n    'FIELD_TYPE', 'IntegrityError', 'InterfaceError', 'InternalError',\n    'MySQLError', 'NULL', 'NUMBER', 'NotSupportedError', 'DBAPISet',\n    'OperationalError', 'ProgrammingError', 'ROWID', 'STRING', 'TIME',\n    'TIMESTAMP', 'Warning', 'apilevel', 'connect', 'connections',\n    'constants', 'converters', 'cursors', 'debug', 'escape', 'escape_dict',\n    'escape_sequence', 'escape_string', 'get_client_info',\n    'paramstyle', 'string_literal', 'threadsafety', 'version_info']\n```\n不过, 这种情况下不能完全清楚引入了什么 names, 有可能覆盖自己定义的 names, 最好谨慎使用;\n(2) 其他信息, 如版本, 作者:\n``` python\n# 作者\n__author__ = \"Andy Dustman <farcepest@gmail.com>\"\n# 版本信息\nversion_info = (1,2,5,'final',1)\n__version__ = \"1.2.5\"\n```\n\n#### **在 \\__init\\__.py 中定义方法/类**\n\\__init\\__.py 也是 python 源文件, 在其中亦可以定义方法, 类, 或者执行代码段:\n``` python\n# MyPackage: __init__.py\ndef test_DBAPISet_set_equality():\n    assert STRING == STRING\n    \ndef Binary(x):\n    return str(x)\n```\n此时, import 了 MyPackage 之后, 便可以正常使用定义的内容;\n\n### **python 的工作/搜索路径**\n当导入一个 python 模块时, 解释器的查找路径如下:\n\n1. 在当前的包中查找;\n2. 在 `__buildin__` 模块中查找;\n3. 在 sys.path 给定的路径中中查找;\n\n其中, 第一点自不必说;\n关于 \\__buildin\\__ 模块, 更多的信息请参见另一篇文章: [python module 使用总结: \\__buildin\\__](); 上文描述的 dir() 方法其实就是 \\__buildin\\__ 模块中的内建方法, 不需要额外引入其他模块便能直接使用;\n而关于 sys.path, 其初始构成内容又包含了以下几处地方:\n\n1. 程序的主目录;\n2. PYTHONPATH 中定义的路径;\n3. 标准链接库, 例如: /usr/lib/python2.7, /usr/local/lib/python2.7 等;\n\n``` python\n>>> import sys\n>>> sys.path\n['', '/usr/lib64/python27.zip', '/usr/lib64/python2.7', '/usr/lib/python2.7/plat-linux2', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/lib/python2.7/site-packages', '/usr/lib/python2.7/site-packages']\n```\n如上所述, 从运行主模块的角度考虑:\n\n1. 如果引入的模块是第三方模块, 那么大部分情况下, 所需要的模块在标准链接库 dist-packages 中都有, python 能够成功引到;\n2. 如果引入的模块是自己的子模块, 由于子模块一定在主模块的子目录下, 所以 python 也能成功引到;\n3. 如果引入的模块是自己的父模块或者兄弟模块, 这时 python 能否成功引到, 就得分情况了:\n\n如果工程在自己创建的目录中运行, 引入父模块或者兄弟模块, 在默认的搜索路径里是找不到的;\n这时要想成功引到目标模块, 有两种办法:\n(1) 向 sys.path 中拓展添加目标路径:\n``` python\nimport sys\nsys.path.append(os.path.abspath('xxx/yyy/zzz'))\n```\n(2) 使用 PYTHONPATH, 向其中添加目标路径:\n``` bash\n# /etc/profile\nexport PATH=${PATH}:${target_path}\nexport PYTHONPATH=${PYTHONPATH}:${target_path}\n```\n至于这两种方法的好坏, 就是仁者见仁, 智者见智的问题了;\n使用 sys.path.append, 比较灵活, 每个模块都可以自己定义, 但缺点是需要多添加两行代码, 比较繁琐;\n使用 PYTHONPATH, 优点是不需要在自己的模块中添加额外的代码, 但是如果自己创建的工程路径比较零散, PYTHONPATH 就需要不停地补充新路径;\n不过, 如果有诸如公司规范之类的, 将 python 项目都部署在约定的公共目录下, 那么 PYTHONPATH 只需要添加这一个公共路径即可, 这样问题便简单了;\n&nbsp;\n至此, 关于 python 模块导入的基础性问题就讲完了;\n最后要说的是, 其实本文最开始所列出的那个自定义模块 MyPackage, 其原型是 `MySQLdb`;\n\n### **站内相关文章**\n- [python module 使用总结: \\__buildin\\__]()\n\n### **参考链接**\n- [Python 中 if \\__name\\__ == '\\__main\\__' 理解](http://www.cnblogs.com/huwang-sun/p/6993980.html)\n- [Python 中的包 ImportError](https://www.cnblogs.com/AlwinXu/p/5658787.html)\n- [python import 工程内模块显示错误](https://segmentfault.com/q/1010000007837183?_ea=1477413)\n- [Python模块包中\\__init\\__.py文件的作用](http://blog.csdn.net/yxmmxy7913/article/details/4233420)\n- [Be Pythonic: \\__init\\__.py](http://mikegrouchy.com/blog/2012/05/be-pythonic-__init__py.html)\n- [Python类、模块、包的区别](https://www.cnblogs.com/kex1n/p/5977051.html)\n- [Python环境变量PYTHONPATH设置](http://blog.csdn.net/qw_xingzhe/article/details/52695486)\n\n","source":"_posts/python--python模块导入_相关基础知识梳理.md","raw":"---\ntitle: \"python 模块导入: 相关基础知识梳理\"\ndate: 2017-03-12 21:35:04\ncategories:\n - python\ntags:\n - python:module\n---\n\n> python 有一个关键字和 java 一样: `import`, 其功能也类似: 在代码中引入其他的依赖(模块)以使用;\n不过, 不像 java 那么单纯, python 还要区分为 import module 和 import names 两大类; 作为一个 python 新手, 这些使用上的区别有时会令人感到迷惑;\npython 包和 java 包在概念上也有类似之处, 不过 python 的 \\__init\\__.py 规范更讲究一些, java 的 package-info.java 重要性没有那么强, python 初学者在此也很容易栽跟头;\n在使用了一段时间的 python 之后, 我突然发现, 关于模块引入相关的知识, 我还从来没有过一个系统性的整理; 故作此文以备将来查阅;\n\n<!--more-->\n\n------\n\n下面所示的是一个 python 工程结构, 包括了一个父 package 和其下的子 package , 结构比较完整; 本文将以此工程结构为例, 展开内容;\n``` python\nMyPackage\n    ├── connections.py\n    ├── constants\n    │   ├── CLIENT.py\n    │   ├── CR.py\n    │   ├── ER.py\n    │   ├── FIELD_TYPE.py\n    │   ├── FLAG.py\n    │   ├── __init__.py\n    │   ├── REFRESH.py\n    ├── converters.py\n    ├── cursors.py\n    ├── __init__.py\n    ├── release.py\n    ├── times.py\n```\n其中, 假设 connections.py 中定义了 Connection 类:\n``` python\n# connections.py\nimport _mysql\nclass Connection(_mysql.connection):\n    def __init__(self, *args, **kwargs):\n        ...\n```\n下面开始本文的内容;\n\n### **基础预备知识**\n#### **对象的 \\__name\\__ 字段**\n所有 python 程序的执行必须要有一个入口, 而我们经常见到的入口会有这么一行代码:\n``` python\nif __name__ == '__main__':\n```\n这里面涉及到了一个模块的属性: `__name__`:\n当一个模块以主模块被执行时, 该模块的 \\__name\\__ 就被解释器设定为 '\\__main\\__';\n当一个模块被其他模块引入时, 该模块的 \\__name\\__ 就被解释器设定为 '该模块的文件名';\n\n#### **内建方法: dir()**\npython 中有一个全局内建方法 `dir(p_object=None)` 可以返回目标作用域里所有的成员 (names);\n当方法参数 p_object 为 None 时, 默认返回当前作用域内的所有成员:\n``` python\n# 在 python shell 里执行, 作用域为主模块, 展示模块属性\n>>> import MyPackage\n>>> dir()\n['MyPackage', '__builtins__', '__doc__', '__name__', '__package__']\n```\n\n``` python\n# 在方法内部执行, 作用域为方法内, 展示方法的字段\ndef print_dir(num=1, str=None):\n    print dir()\n    \nif __name__ == '__main__':\n    print_dir()\n\noutput:\n['num', 'str']\n```\n如果指定了目标作用域(对象), 则无论在哪里指定 dir () 方法, 都只打印指定目标的成员;\n``` python\nfrom MyPackage.connections import Connection\n# 指定作用域\ndef print_dir(obj=None):\n    print dir(obj)\n\nif __name__ == '__main__':\n    conn = Connection()\n    print_dir(conn)\n\noutput:\n['__doc__', '__init__', '__module__']\n```\n\n#### **import 的规则语法**\npython 导入其他模块分为两种: import module/package 与 import names (包括变量, 函数, 类等);\nimport module/package 的语法如下:\n``` python\nimport MyPackage\nimport MyPackage.connections\n```\nimport names 的语法如下:\n``` python\n# 引入类\nfrom MyPackage.connections import Connection\n# 引入方法\nfrom MyPackage.connections import numeric_part\n# 引入 __all__ 指定的所有 names\nfrom MyPackage import *\n```\n对于不同的 package, 不同的 \\__init\\__.py 文件, 这些 import 语句所产生的效果都不尽相同, 详细的区别将在下一节描述;\n\n### **\\__init\\__.py 文件的功能**\n对于 python 的每一个包来说, \\__init\\__.py 是必须的, 它控制着包的导入行为, 并可以表达非常丰富的信息; 如果没有 \\__init\\__.py 文件, 那这个包只能算是一个普通目录, 目录下的任何 python 文件都不能作为模块被导入;\n以下是几种常见的 \\__init\\__.py 文件的内容:\n\n#### **\\__init\\__.py 文件内容为空**\n\\__init\\__.py 文件必须有, 但可以是空文件, 这将是最简单的形式, 当然其所提供的功能也最简单: 标识这是一个 python 包, 仅此而已;\n如果将该包作为一个模块导入, 其实是等于什么都没导入:\n``` python\n>>> import MyPackage\n>>> dir()\n['MyPackage', '__builtins__', '__doc__', '__name__', '__package__']\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__']\n```\n通过 dir() 内建方法可以发现, 无论是当前主模块, 还是 MyPackage 包, 除了一些保留 names, 不再有其他任何自定义符号, 这时将无法直接使用 MyPackage 下的任何模块:\n``` python\n# 直接 使用 connections.py 下的 Connection 类\n>>> conn = MyPackage.connections.Connection()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'MyPackage' is not defined\n```\n\n不过, 既然 \\__init\\__.py 已经标识了这是一个 python 包, 所以对于包下所有其他的模块文件, 我们可以主动引入它们, 这算是空 \\__init\\__.py 的唯一作用:\n``` python\n# 主动引入模块\n>>> import MyPackage.connections\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n>>> dir(MyPackage.connections)\n['Connection', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'numeric_part']\n```\n这时可以发现, dir(MyPackage) 列表里有了 connections 模块, dir(MyPackage.connections) 列表里有了 Connection 类; 这时带着 python 路径, 就可以使用 target name 了:\n``` python\n>>> conn = MyPackage.connections.Connection()\n```\n另外, 如果使用 from ... import ... 主动引入目标符号:\n``` python\n>>> from MyPackage.connections import Connection\n>>> dir()\n['Connection', '__builtins__', '__doc__', '__name__', '__package__']\n```\n便可以直接将目标符号引入当前作用域, 不需要使用模块路径, 就可以直接使用:\n``` python\n>>> conn = Connection()\n```\n\n#### **在 \\__init\\__.py 中 import 其他模块**\n\\__init\\__.py 中自己主动 import 第三方模块是一种常见的操作:\n``` python\n# __init__.py\nimport connections\n```\n``` python\n>>> import MyPackage\n>>> dir(MyPackage)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n# 路径是 MyPackage.connections\n>>> conn = MyPackage.connections.Connection()\n```\n或者使用 from ... import ... 语法:\n``` python\n# __init__.py\nfrom connections import Connection\n```\n``` python\n>>> import MyPackage\n>>> dir(MyPackage)\n['Connection', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'connections']\n# 路径是 MyPackage\n>>> conn = MyPackage.Connection()\n```\n对于以上两种 import 方式, 结合 dir() 内建方法的展示, 可以发现在具体使用目标符号时所带路径的区别;\n\n#### **\\__init\\__.py 中的保留字段**\n(1) \\__all\\__ 字段:\n如果在代码中使用了如下的引用方式:\n``` python\nfrom MyPackage import *\n```\n解释器便会试图去指定的模块中寻找 `__all__` 字段, 将该列表中列举的所有 names 全部引入:\n``` python\n__all__ = [ 'BINARY', 'Binary', 'Connect', 'Connection', 'DATE',\n    'Date', 'Time', 'Timestamp', 'DateFromTicks', 'TimeFromTicks',\n    'TimestampFromTicks', 'DataError', 'DatabaseError', 'Error',\n    'FIELD_TYPE', 'IntegrityError', 'InterfaceError', 'InternalError',\n    'MySQLError', 'NULL', 'NUMBER', 'NotSupportedError', 'DBAPISet',\n    'OperationalError', 'ProgrammingError', 'ROWID', 'STRING', 'TIME',\n    'TIMESTAMP', 'Warning', 'apilevel', 'connect', 'connections',\n    'constants', 'converters', 'cursors', 'debug', 'escape', 'escape_dict',\n    'escape_sequence', 'escape_string', 'get_client_info',\n    'paramstyle', 'string_literal', 'threadsafety', 'version_info']\n```\n不过, 这种情况下不能完全清楚引入了什么 names, 有可能覆盖自己定义的 names, 最好谨慎使用;\n(2) 其他信息, 如版本, 作者:\n``` python\n# 作者\n__author__ = \"Andy Dustman <farcepest@gmail.com>\"\n# 版本信息\nversion_info = (1,2,5,'final',1)\n__version__ = \"1.2.5\"\n```\n\n#### **在 \\__init\\__.py 中定义方法/类**\n\\__init\\__.py 也是 python 源文件, 在其中亦可以定义方法, 类, 或者执行代码段:\n``` python\n# MyPackage: __init__.py\ndef test_DBAPISet_set_equality():\n    assert STRING == STRING\n    \ndef Binary(x):\n    return str(x)\n```\n此时, import 了 MyPackage 之后, 便可以正常使用定义的内容;\n\n### **python 的工作/搜索路径**\n当导入一个 python 模块时, 解释器的查找路径如下:\n\n1. 在当前的包中查找;\n2. 在 `__buildin__` 模块中查找;\n3. 在 sys.path 给定的路径中中查找;\n\n其中, 第一点自不必说;\n关于 \\__buildin\\__ 模块, 更多的信息请参见另一篇文章: [python module 使用总结: \\__buildin\\__](); 上文描述的 dir() 方法其实就是 \\__buildin\\__ 模块中的内建方法, 不需要额外引入其他模块便能直接使用;\n而关于 sys.path, 其初始构成内容又包含了以下几处地方:\n\n1. 程序的主目录;\n2. PYTHONPATH 中定义的路径;\n3. 标准链接库, 例如: /usr/lib/python2.7, /usr/local/lib/python2.7 等;\n\n``` python\n>>> import sys\n>>> sys.path\n['', '/usr/lib64/python27.zip', '/usr/lib64/python2.7', '/usr/lib/python2.7/plat-linux2', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/lib/python2.7/site-packages', '/usr/lib/python2.7/site-packages']\n```\n如上所述, 从运行主模块的角度考虑:\n\n1. 如果引入的模块是第三方模块, 那么大部分情况下, 所需要的模块在标准链接库 dist-packages 中都有, python 能够成功引到;\n2. 如果引入的模块是自己的子模块, 由于子模块一定在主模块的子目录下, 所以 python 也能成功引到;\n3. 如果引入的模块是自己的父模块或者兄弟模块, 这时 python 能否成功引到, 就得分情况了:\n\n如果工程在自己创建的目录中运行, 引入父模块或者兄弟模块, 在默认的搜索路径里是找不到的;\n这时要想成功引到目标模块, 有两种办法:\n(1) 向 sys.path 中拓展添加目标路径:\n``` python\nimport sys\nsys.path.append(os.path.abspath('xxx/yyy/zzz'))\n```\n(2) 使用 PYTHONPATH, 向其中添加目标路径:\n``` bash\n# /etc/profile\nexport PATH=${PATH}:${target_path}\nexport PYTHONPATH=${PYTHONPATH}:${target_path}\n```\n至于这两种方法的好坏, 就是仁者见仁, 智者见智的问题了;\n使用 sys.path.append, 比较灵活, 每个模块都可以自己定义, 但缺点是需要多添加两行代码, 比较繁琐;\n使用 PYTHONPATH, 优点是不需要在自己的模块中添加额外的代码, 但是如果自己创建的工程路径比较零散, PYTHONPATH 就需要不停地补充新路径;\n不过, 如果有诸如公司规范之类的, 将 python 项目都部署在约定的公共目录下, 那么 PYTHONPATH 只需要添加这一个公共路径即可, 这样问题便简单了;\n&nbsp;\n至此, 关于 python 模块导入的基础性问题就讲完了;\n最后要说的是, 其实本文最开始所列出的那个自定义模块 MyPackage, 其原型是 `MySQLdb`;\n\n### **站内相关文章**\n- [python module 使用总结: \\__buildin\\__]()\n\n### **参考链接**\n- [Python 中 if \\__name\\__ == '\\__main\\__' 理解](http://www.cnblogs.com/huwang-sun/p/6993980.html)\n- [Python 中的包 ImportError](https://www.cnblogs.com/AlwinXu/p/5658787.html)\n- [python import 工程内模块显示错误](https://segmentfault.com/q/1010000007837183?_ea=1477413)\n- [Python模块包中\\__init\\__.py文件的作用](http://blog.csdn.net/yxmmxy7913/article/details/4233420)\n- [Be Pythonic: \\__init\\__.py](http://mikegrouchy.com/blog/2012/05/be-pythonic-__init__py.html)\n- [Python类、模块、包的区别](https://www.cnblogs.com/kex1n/p/5977051.html)\n- [Python环境变量PYTHONPATH设置](http://blog.csdn.net/qw_xingzhe/article/details/52695486)\n\n","slug":"python--python模块导入_相关基础知识梳理","published":1,"updated":"2018-02-25T01:47:57.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5v000pj1jxcyk0b9j9","content":"<blockquote>\n<p>python 有一个关键字和 java 一样: <code>import</code>, 其功能也类似: 在代码中引入其他的依赖(模块)以使用;<br>不过, 不像 java 那么单纯, python 还要区分为 import module 和 import names 两大类; 作为一个 python 新手, 这些使用上的区别有时会令人感到迷惑;<br>python 包和 java 包在概念上也有类似之处, 不过 python 的 __init__.py 规范更讲究一些, java 的 package-info.java 重要性没有那么强, python 初学者在此也很容易栽跟头;<br>在使用了一段时间的 python 之后, 我突然发现, 关于模块引入相关的知识, 我还从来没有过一个系统性的整理; 故作此文以备将来查阅;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p>下面所示的是一个 python 工程结构, 包括了一个父 package 和其下的子 package , 结构比较完整; 本文将以此工程结构为例, 展开内容;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPackage</span><br><span class=\"line\">    ├── connections.py</span><br><span class=\"line\">    ├── constants</span><br><span class=\"line\">    │   ├── CLIENT.py</span><br><span class=\"line\">    │   ├── CR.py</span><br><span class=\"line\">    │   ├── ER.py</span><br><span class=\"line\">    │   ├── FIELD_TYPE.py</span><br><span class=\"line\">    │   ├── FLAG.py</span><br><span class=\"line\">    │   ├── __init__.py</span><br><span class=\"line\">    │   ├── REFRESH.py</span><br><span class=\"line\">    ├── converters.py</span><br><span class=\"line\">    ├── cursors.py</span><br><span class=\"line\">    ├── __init__.py</span><br><span class=\"line\">    ├── release.py</span><br><span class=\"line\">    ├── times.py</span><br></pre></td></tr></table></figure></p>\n<p>其中, 假设 connections.py 中定义了 Connection 类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># connections.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> _mysql</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connection</span><span class=\"params\">(_mysql.connection)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure></p>\n<p>下面开始本文的内容;</p>\n<h3 id=\"基础预备知识\"><a href=\"#基础预备知识\" class=\"headerlink\" title=\"基础预备知识\"></a><strong>基础预备知识</strong></h3><h4 id=\"对象的-name-字段\"><a href=\"#对象的-name-字段\" class=\"headerlink\" title=\"对象的 __name__ 字段\"></a><strong>对象的 __name__ 字段</strong></h4><p>所有 python 程序的执行必须要有一个入口, 而我们经常见到的入口会有这么一行代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br></pre></td></tr></table></figure></p>\n<p>这里面涉及到了一个模块的属性: <code>__name__</code>:<br>当一个模块以主模块被执行时, 该模块的 __name__ 就被解释器设定为 ‘__main__’;<br>当一个模块被其他模块引入时, 该模块的 __name__ 就被解释器设定为 ‘该模块的文件名’;</p>\n<h4 id=\"内建方法-dir\"><a href=\"#内建方法-dir\" class=\"headerlink\" title=\"内建方法: dir()\"></a><strong>内建方法: dir()</strong></h4><p>python 中有一个全局内建方法 <code>dir(p_object=None)</code> 可以返回目标作用域里所有的成员 (names);<br>当方法参数 p_object 为 None 时, 默认返回当前作用域内的所有成员:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 python shell 里执行, 作用域为主模块, 展示模块属性</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'MyPackage'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在方法内部执行, 作用域为方法内, 展示方法的字段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_dir</span><span class=\"params\">(num=<span class=\"number\">1</span>, str=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> dir()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print_dir()</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"string\">'num'</span>, <span class=\"string\">'str'</span>]</span><br></pre></td></tr></table></figure>\n<p>如果指定了目标作用域(对象), 则无论在哪里指定 dir () 方法, 都只打印指定目标的成员;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"comment\"># 指定作用域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_dir</span><span class=\"params\">(obj=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> dir(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    conn = Connection()</span><br><span class=\"line\">    print_dir(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"string\">'__doc__'</span>, <span class=\"string\">'__init__'</span>, <span class=\"string\">'__module__'</span>]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"import-的规则语法\"><a href=\"#import-的规则语法\" class=\"headerlink\" title=\"import 的规则语法\"></a><strong>import 的规则语法</strong></h4><p>python 导入其他模块分为两种: import module/package 与 import names (包括变量, 函数, 类等);<br>import module/package 的语法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"keyword\">import</span> MyPackage.connections</span><br></pre></td></tr></table></figure></p>\n<p>import names 的语法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 引入类</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"comment\"># 引入方法</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> numeric_part</span><br><span class=\"line\"><span class=\"comment\"># 引入 __all__ 指定的所有 names</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage <span class=\"keyword\">import</span> *</span><br></pre></td></tr></table></figure></p>\n<p>对于不同的 package, 不同的 __init__.py 文件, 这些 import 语句所产生的效果都不尽相同, 详细的区别将在下一节描述;</p>\n<h3 id=\"init-py-文件的功能\"><a href=\"#init-py-文件的功能\" class=\"headerlink\" title=\"__init__.py 文件的功能\"></a><strong>__init__.py 文件的功能</strong></h3><p>对于 python 的每一个包来说, __init__.py 是必须的, 它控制着包的导入行为, 并可以表达非常丰富的信息; 如果没有 __init__.py 文件, 那这个包只能算是一个普通目录, 目录下的任何 python 文件都不能作为模块被导入;<br>以下是几种常见的 __init__.py 文件的内容:</p>\n<h4 id=\"init-py-文件内容为空\"><a href=\"#init-py-文件内容为空\" class=\"headerlink\" title=\"__init__.py 文件内容为空\"></a><strong>__init__.py 文件内容为空</strong></h4><p>__init__.py 文件必须有, 但可以是空文件, 这将是最简单的形式, 当然其所提供的功能也最简单: 标识这是一个 python 包, 仅此而已;<br>如果将该包作为一个模块导入, 其实是等于什么都没导入:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'MyPackage'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>通过 dir() 内建方法可以发现, 无论是当前主模块, 还是 MyPackage 包, 除了一些保留 names, 不再有其他任何自定义符号, 这时将无法直接使用 MyPackage 下的任何模块:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接 使用 connections.py 下的 Connection 类</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">NameError: name <span class=\"string\">'MyPackage'</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> defined</span><br></pre></td></tr></table></figure></p>\n<p>不过, 既然 __init__.py 已经标识了这是一个 python 包, 所以对于包下所有其他的模块文件, 我们可以主动引入它们, 这算是空 __init__.py 的唯一作用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主动引入模块</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage.connections</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage.connections)</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'numeric_part'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这时可以发现, dir(MyPackage) 列表里有了 connections 模块, dir(MyPackage.connections) 列表里有了 Connection 类; 这时带着 python 路径, 就可以使用 target name 了:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br></pre></td></tr></table></figure></p>\n<p>另外, 如果使用 from … import … 主动引入目标符号:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>便可以直接将目标符号引入当前作用域, 不需要使用模块路径, 就可以直接使用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = Connection()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在-init-py-中-import-其他模块\"><a href=\"#在-init-py-中-import-其他模块\" class=\"headerlink\" title=\"在 __init__.py 中 import 其他模块\"></a><strong>在 __init__.py 中 import 其他模块</strong></h4><p>__init__.py 中自己主动 import 第三方模块是一种常见的操作:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># __init__.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> connections</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 路径是 MyPackage.connections</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br></pre></td></tr></table></figure>\n<p>或者使用 from … import … 语法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># __init__.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> connections <span class=\"keyword\">import</span> Connection</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 路径是 MyPackage</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.Connection()</span><br></pre></td></tr></table></figure>\n<p>对于以上两种 import 方式, 结合 dir() 内建方法的展示, 可以发现在具体使用目标符号时所带路径的区别;</p>\n<h4 id=\"init-py-中的保留字段\"><a href=\"#init-py-中的保留字段\" class=\"headerlink\" title=\"__init__.py 中的保留字段\"></a><strong>__init__.py 中的保留字段</strong></h4><p>(1) __all__ 字段:<br>如果在代码中使用了如下的引用方式:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> MyPackage <span class=\"keyword\">import</span> *</span><br></pre></td></tr></table></figure></p>\n<p>解释器便会试图去指定的模块中寻找 <code>__all__</code> 字段, 将该列表中列举的所有 names 全部引入:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__all__ = [ <span class=\"string\">'BINARY'</span>, <span class=\"string\">'Binary'</span>, <span class=\"string\">'Connect'</span>, <span class=\"string\">'Connection'</span>, <span class=\"string\">'DATE'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Date'</span>, <span class=\"string\">'Time'</span>, <span class=\"string\">'Timestamp'</span>, <span class=\"string\">'DateFromTicks'</span>, <span class=\"string\">'TimeFromTicks'</span>,</span><br><span class=\"line\">    <span class=\"string\">'TimestampFromTicks'</span>, <span class=\"string\">'DataError'</span>, <span class=\"string\">'DatabaseError'</span>, <span class=\"string\">'Error'</span>,</span><br><span class=\"line\">    <span class=\"string\">'FIELD_TYPE'</span>, <span class=\"string\">'IntegrityError'</span>, <span class=\"string\">'InterfaceError'</span>, <span class=\"string\">'InternalError'</span>,</span><br><span class=\"line\">    <span class=\"string\">'MySQLError'</span>, <span class=\"string\">'NULL'</span>, <span class=\"string\">'NUMBER'</span>, <span class=\"string\">'NotSupportedError'</span>, <span class=\"string\">'DBAPISet'</span>,</span><br><span class=\"line\">    <span class=\"string\">'OperationalError'</span>, <span class=\"string\">'ProgrammingError'</span>, <span class=\"string\">'ROWID'</span>, <span class=\"string\">'STRING'</span>, <span class=\"string\">'TIME'</span>,</span><br><span class=\"line\">    <span class=\"string\">'TIMESTAMP'</span>, <span class=\"string\">'Warning'</span>, <span class=\"string\">'apilevel'</span>, <span class=\"string\">'connect'</span>, <span class=\"string\">'connections'</span>,</span><br><span class=\"line\">    <span class=\"string\">'constants'</span>, <span class=\"string\">'converters'</span>, <span class=\"string\">'cursors'</span>, <span class=\"string\">'debug'</span>, <span class=\"string\">'escape'</span>, <span class=\"string\">'escape_dict'</span>,</span><br><span class=\"line\">    <span class=\"string\">'escape_sequence'</span>, <span class=\"string\">'escape_string'</span>, <span class=\"string\">'get_client_info'</span>,</span><br><span class=\"line\">    <span class=\"string\">'paramstyle'</span>, <span class=\"string\">'string_literal'</span>, <span class=\"string\">'threadsafety'</span>, <span class=\"string\">'version_info'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>不过, 这种情况下不能完全清楚引入了什么 names, 有可能覆盖自己定义的 names, 最好谨慎使用;<br>(2) 其他信息, 如版本, 作者:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 作者</span></span><br><span class=\"line\">__author__ = <span class=\"string\">\"Andy Dustman &lt;farcepest@gmail.com&gt;\"</span></span><br><span class=\"line\"><span class=\"comment\"># 版本信息</span></span><br><span class=\"line\">version_info = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"string\">'final'</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">__version__ = <span class=\"string\">\"1.2.5\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在-init-py-中定义方法-类\"><a href=\"#在-init-py-中定义方法-类\" class=\"headerlink\" title=\"在 __init__.py 中定义方法/类\"></a><strong>在 __init__.py 中定义方法/类</strong></h4><p>__init__.py 也是 python 源文件, 在其中亦可以定义方法, 类, 或者执行代码段:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># MyPackage: __init__.py</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_DBAPISet_set_equality</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> STRING == STRING</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Binary</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str(x)</span><br></pre></td></tr></table></figure></p>\n<p>此时, import 了 MyPackage 之后, 便可以正常使用定义的内容;</p>\n<h3 id=\"python-的工作-搜索路径\"><a href=\"#python-的工作-搜索路径\" class=\"headerlink\" title=\"python 的工作/搜索路径\"></a><strong>python 的工作/搜索路径</strong></h3><p>当导入一个 python 模块时, 解释器的查找路径如下:</p>\n<ol>\n<li>在当前的包中查找;</li>\n<li>在 <code>__buildin__</code> 模块中查找;</li>\n<li>在 sys.path 给定的路径中中查找;</li>\n</ol>\n<p>其中, 第一点自不必说;<br>关于 __buildin__ 模块, 更多的信息请参见另一篇文章: <a href=\"\">python module 使用总结: __buildin__</a>; 上文描述的 dir() 方法其实就是 __buildin__ 模块中的内建方法, 不需要额外引入其他模块便能直接使用;<br>而关于 sys.path, 其初始构成内容又包含了以下几处地方:</p>\n<ol>\n<li>程序的主目录;</li>\n<li>PYTHONPATH 中定义的路径;</li>\n<li>标准链接库, 例如: /usr/lib/python2.7, /usr/local/lib/python2.7 等;</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sys.path</span><br><span class=\"line\">[<span class=\"string\">''</span>, <span class=\"string\">'/usr/lib64/python27.zip'</span>, <span class=\"string\">'/usr/lib64/python2.7'</span>, <span class=\"string\">'/usr/lib/python2.7/plat-linux2'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-tk'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-old'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-dynload'</span>, <span class=\"string\">'/usr/lib/python2.7/site-packages'</span>, <span class=\"string\">'/usr/lib/python2.7/site-packages'</span>]</span><br></pre></td></tr></table></figure>\n<p>如上所述, 从运行主模块的角度考虑:</p>\n<ol>\n<li>如果引入的模块是第三方模块, 那么大部分情况下, 所需要的模块在标准链接库 dist-packages 中都有, python 能够成功引到;</li>\n<li>如果引入的模块是自己的子模块, 由于子模块一定在主模块的子目录下, 所以 python 也能成功引到;</li>\n<li>如果引入的模块是自己的父模块或者兄弟模块, 这时 python 能否成功引到, 就得分情况了:</li>\n</ol>\n<p>如果工程在自己创建的目录中运行, 引入父模块或者兄弟模块, 在默认的搜索路径里是找不到的;<br>这时要想成功引到目标模块, 有两种办法:<br>(1) 向 sys.path 中拓展添加目标路径:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.path.append(os.path.abspath(<span class=\"string\">'xxx/yyy/zzz'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>(2) 使用 PYTHONPATH, 向其中添加目标路径:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /etc/profile</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;PATH&#125;</span>:<span class=\"variable\">$&#123;target_path&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PYTHONPATH=<span class=\"variable\">$&#123;PYTHONPATH&#125;</span>:<span class=\"variable\">$&#123;target_path&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>至于这两种方法的好坏, 就是仁者见仁, 智者见智的问题了;<br>使用 sys.path.append, 比较灵活, 每个模块都可以自己定义, 但缺点是需要多添加两行代码, 比较繁琐;<br>使用 PYTHONPATH, 优点是不需要在自己的模块中添加额外的代码, 但是如果自己创建的工程路径比较零散, PYTHONPATH 就需要不停地补充新路径;<br>不过, 如果有诸如公司规范之类的, 将 python 项目都部署在约定的公共目录下, 那么 PYTHONPATH 只需要添加这一个公共路径即可, 这样问题便简单了;<br>&nbsp;<br>至此, 关于 python 模块导入的基础性问题就讲完了;<br>最后要说的是, 其实本文最开始所列出的那个自定义模块 MyPackage, 其原型是 <code>MySQLdb</code>;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">python module 使用总结: __buildin__</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/huwang-sun/p/6993980.html\" target=\"_blank\" rel=\"noopener\">Python 中 if __name__ == ‘__main__’ 理解</a></li>\n<li><a href=\"https://www.cnblogs.com/AlwinXu/p/5658787.html\" target=\"_blank\" rel=\"noopener\">Python 中的包 ImportError</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000007837183?_ea=1477413\" target=\"_blank\" rel=\"noopener\">python import 工程内模块显示错误</a></li>\n<li><a href=\"http://blog.csdn.net/yxmmxy7913/article/details/4233420\" target=\"_blank\" rel=\"noopener\">Python模块包中__init__.py文件的作用</a></li>\n<li><a href=\"http://mikegrouchy.com/blog/2012/05/be-pythonic-__init__py.html\" target=\"_blank\" rel=\"noopener\">Be Pythonic: __init__.py</a></li>\n<li><a href=\"https://www.cnblogs.com/kex1n/p/5977051.html\" target=\"_blank\" rel=\"noopener\">Python类、模块、包的区别</a></li>\n<li><a href=\"http://blog.csdn.net/qw_xingzhe/article/details/52695486\" target=\"_blank\" rel=\"noopener\">Python环境变量PYTHONPATH设置</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>python 有一个关键字和 java 一样: <code>import</code>, 其功能也类似: 在代码中引入其他的依赖(模块)以使用;<br>不过, 不像 java 那么单纯, python 还要区分为 import module 和 import names 两大类; 作为一个 python 新手, 这些使用上的区别有时会令人感到迷惑;<br>python 包和 java 包在概念上也有类似之处, 不过 python 的 __init__.py 规范更讲究一些, java 的 package-info.java 重要性没有那么强, python 初学者在此也很容易栽跟头;<br>在使用了一段时间的 python 之后, 我突然发现, 关于模块引入相关的知识, 我还从来没有过一个系统性的整理; 故作此文以备将来查阅;</p>\n</blockquote>","more":"<hr>\n<p>下面所示的是一个 python 工程结构, 包括了一个父 package 和其下的子 package , 结构比较完整; 本文将以此工程结构为例, 展开内容;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPackage</span><br><span class=\"line\">    ├── connections.py</span><br><span class=\"line\">    ├── constants</span><br><span class=\"line\">    │   ├── CLIENT.py</span><br><span class=\"line\">    │   ├── CR.py</span><br><span class=\"line\">    │   ├── ER.py</span><br><span class=\"line\">    │   ├── FIELD_TYPE.py</span><br><span class=\"line\">    │   ├── FLAG.py</span><br><span class=\"line\">    │   ├── __init__.py</span><br><span class=\"line\">    │   ├── REFRESH.py</span><br><span class=\"line\">    ├── converters.py</span><br><span class=\"line\">    ├── cursors.py</span><br><span class=\"line\">    ├── __init__.py</span><br><span class=\"line\">    ├── release.py</span><br><span class=\"line\">    ├── times.py</span><br></pre></td></tr></table></figure></p>\n<p>其中, 假设 connections.py 中定义了 Connection 类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># connections.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> _mysql</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connection</span><span class=\"params\">(_mysql.connection)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure></p>\n<p>下面开始本文的内容;</p>\n<h3 id=\"基础预备知识\"><a href=\"#基础预备知识\" class=\"headerlink\" title=\"基础预备知识\"></a><strong>基础预备知识</strong></h3><h4 id=\"对象的-name-字段\"><a href=\"#对象的-name-字段\" class=\"headerlink\" title=\"对象的 __name__ 字段\"></a><strong>对象的 __name__ 字段</strong></h4><p>所有 python 程序的执行必须要有一个入口, 而我们经常见到的入口会有这么一行代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br></pre></td></tr></table></figure></p>\n<p>这里面涉及到了一个模块的属性: <code>__name__</code>:<br>当一个模块以主模块被执行时, 该模块的 __name__ 就被解释器设定为 ‘__main__’;<br>当一个模块被其他模块引入时, 该模块的 __name__ 就被解释器设定为 ‘该模块的文件名’;</p>\n<h4 id=\"内建方法-dir\"><a href=\"#内建方法-dir\" class=\"headerlink\" title=\"内建方法: dir()\"></a><strong>内建方法: dir()</strong></h4><p>python 中有一个全局内建方法 <code>dir(p_object=None)</code> 可以返回目标作用域里所有的成员 (names);<br>当方法参数 p_object 为 None 时, 默认返回当前作用域内的所有成员:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 python shell 里执行, 作用域为主模块, 展示模块属性</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'MyPackage'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在方法内部执行, 作用域为方法内, 展示方法的字段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_dir</span><span class=\"params\">(num=<span class=\"number\">1</span>, str=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> dir()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print_dir()</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"string\">'num'</span>, <span class=\"string\">'str'</span>]</span><br></pre></td></tr></table></figure>\n<p>如果指定了目标作用域(对象), 则无论在哪里指定 dir () 方法, 都只打印指定目标的成员;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"comment\"># 指定作用域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_dir</span><span class=\"params\">(obj=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> dir(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    conn = Connection()</span><br><span class=\"line\">    print_dir(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">[<span class=\"string\">'__doc__'</span>, <span class=\"string\">'__init__'</span>, <span class=\"string\">'__module__'</span>]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"import-的规则语法\"><a href=\"#import-的规则语法\" class=\"headerlink\" title=\"import 的规则语法\"></a><strong>import 的规则语法</strong></h4><p>python 导入其他模块分为两种: import module/package 与 import names (包括变量, 函数, 类等);<br>import module/package 的语法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"keyword\">import</span> MyPackage.connections</span><br></pre></td></tr></table></figure></p>\n<p>import names 的语法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 引入类</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"comment\"># 引入方法</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> numeric_part</span><br><span class=\"line\"><span class=\"comment\"># 引入 __all__ 指定的所有 names</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> MyPackage <span class=\"keyword\">import</span> *</span><br></pre></td></tr></table></figure></p>\n<p>对于不同的 package, 不同的 __init__.py 文件, 这些 import 语句所产生的效果都不尽相同, 详细的区别将在下一节描述;</p>\n<h3 id=\"init-py-文件的功能\"><a href=\"#init-py-文件的功能\" class=\"headerlink\" title=\"__init__.py 文件的功能\"></a><strong>__init__.py 文件的功能</strong></h3><p>对于 python 的每一个包来说, __init__.py 是必须的, 它控制着包的导入行为, 并可以表达非常丰富的信息; 如果没有 __init__.py 文件, 那这个包只能算是一个普通目录, 目录下的任何 python 文件都不能作为模块被导入;<br>以下是几种常见的 __init__.py 文件的内容:</p>\n<h4 id=\"init-py-文件内容为空\"><a href=\"#init-py-文件内容为空\" class=\"headerlink\" title=\"__init__.py 文件内容为空\"></a><strong>__init__.py 文件内容为空</strong></h4><p>__init__.py 文件必须有, 但可以是空文件, 这将是最简单的形式, 当然其所提供的功能也最简单: 标识这是一个 python 包, 仅此而已;<br>如果将该包作为一个模块导入, 其实是等于什么都没导入:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'MyPackage'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>通过 dir() 内建方法可以发现, 无论是当前主模块, 还是 MyPackage 包, 除了一些保留 names, 不再有其他任何自定义符号, 这时将无法直接使用 MyPackage 下的任何模块:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接 使用 connections.py 下的 Connection 类</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">NameError: name <span class=\"string\">'MyPackage'</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> defined</span><br></pre></td></tr></table></figure></p>\n<p>不过, 既然 __init__.py 已经标识了这是一个 python 包, 所以对于包下所有其他的模块文件, 我们可以主动引入它们, 这算是空 __init__.py 的唯一作用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主动引入模块</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage.connections</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage.connections)</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'numeric_part'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>这时可以发现, dir(MyPackage) 列表里有了 connections 模块, dir(MyPackage.connections) 列表里有了 Connection 类; 这时带着 python 路径, 就可以使用 target name 了:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br></pre></td></tr></table></figure></p>\n<p>另外, 如果使用 from … import … 主动引入目标符号:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> MyPackage.connections <span class=\"keyword\">import</span> Connection</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir()</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>便可以直接将目标符号引入当前作用域, 不需要使用模块路径, 就可以直接使用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = Connection()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在-init-py-中-import-其他模块\"><a href=\"#在-init-py-中-import-其他模块\" class=\"headerlink\" title=\"在 __init__.py 中 import 其他模块\"></a><strong>在 __init__.py 中 import 其他模块</strong></h4><p>__init__.py 中自己主动 import 第三方模块是一种常见的操作:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># __init__.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> connections</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 路径是 MyPackage.connections</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.connections.Connection()</span><br></pre></td></tr></table></figure>\n<p>或者使用 from … import … 语法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># __init__.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> connections <span class=\"keyword\">import</span> Connection</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> MyPackage</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dir(MyPackage)</span><br><span class=\"line\">[<span class=\"string\">'Connection'</span>, <span class=\"string\">'__builtins__'</span>, <span class=\"string\">'__doc__'</span>, <span class=\"string\">'__file__'</span>, <span class=\"string\">'__name__'</span>, <span class=\"string\">'__package__'</span>, <span class=\"string\">'__path__'</span>, <span class=\"string\">'connections'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 路径是 MyPackage</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>conn = MyPackage.Connection()</span><br></pre></td></tr></table></figure>\n<p>对于以上两种 import 方式, 结合 dir() 内建方法的展示, 可以发现在具体使用目标符号时所带路径的区别;</p>\n<h4 id=\"init-py-中的保留字段\"><a href=\"#init-py-中的保留字段\" class=\"headerlink\" title=\"__init__.py 中的保留字段\"></a><strong>__init__.py 中的保留字段</strong></h4><p>(1) __all__ 字段:<br>如果在代码中使用了如下的引用方式:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> MyPackage <span class=\"keyword\">import</span> *</span><br></pre></td></tr></table></figure></p>\n<p>解释器便会试图去指定的模块中寻找 <code>__all__</code> 字段, 将该列表中列举的所有 names 全部引入:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__all__ = [ <span class=\"string\">'BINARY'</span>, <span class=\"string\">'Binary'</span>, <span class=\"string\">'Connect'</span>, <span class=\"string\">'Connection'</span>, <span class=\"string\">'DATE'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Date'</span>, <span class=\"string\">'Time'</span>, <span class=\"string\">'Timestamp'</span>, <span class=\"string\">'DateFromTicks'</span>, <span class=\"string\">'TimeFromTicks'</span>,</span><br><span class=\"line\">    <span class=\"string\">'TimestampFromTicks'</span>, <span class=\"string\">'DataError'</span>, <span class=\"string\">'DatabaseError'</span>, <span class=\"string\">'Error'</span>,</span><br><span class=\"line\">    <span class=\"string\">'FIELD_TYPE'</span>, <span class=\"string\">'IntegrityError'</span>, <span class=\"string\">'InterfaceError'</span>, <span class=\"string\">'InternalError'</span>,</span><br><span class=\"line\">    <span class=\"string\">'MySQLError'</span>, <span class=\"string\">'NULL'</span>, <span class=\"string\">'NUMBER'</span>, <span class=\"string\">'NotSupportedError'</span>, <span class=\"string\">'DBAPISet'</span>,</span><br><span class=\"line\">    <span class=\"string\">'OperationalError'</span>, <span class=\"string\">'ProgrammingError'</span>, <span class=\"string\">'ROWID'</span>, <span class=\"string\">'STRING'</span>, <span class=\"string\">'TIME'</span>,</span><br><span class=\"line\">    <span class=\"string\">'TIMESTAMP'</span>, <span class=\"string\">'Warning'</span>, <span class=\"string\">'apilevel'</span>, <span class=\"string\">'connect'</span>, <span class=\"string\">'connections'</span>,</span><br><span class=\"line\">    <span class=\"string\">'constants'</span>, <span class=\"string\">'converters'</span>, <span class=\"string\">'cursors'</span>, <span class=\"string\">'debug'</span>, <span class=\"string\">'escape'</span>, <span class=\"string\">'escape_dict'</span>,</span><br><span class=\"line\">    <span class=\"string\">'escape_sequence'</span>, <span class=\"string\">'escape_string'</span>, <span class=\"string\">'get_client_info'</span>,</span><br><span class=\"line\">    <span class=\"string\">'paramstyle'</span>, <span class=\"string\">'string_literal'</span>, <span class=\"string\">'threadsafety'</span>, <span class=\"string\">'version_info'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>不过, 这种情况下不能完全清楚引入了什么 names, 有可能覆盖自己定义的 names, 最好谨慎使用;<br>(2) 其他信息, 如版本, 作者:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 作者</span></span><br><span class=\"line\">__author__ = <span class=\"string\">\"Andy Dustman &lt;farcepest@gmail.com&gt;\"</span></span><br><span class=\"line\"><span class=\"comment\"># 版本信息</span></span><br><span class=\"line\">version_info = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"string\">'final'</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">__version__ = <span class=\"string\">\"1.2.5\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在-init-py-中定义方法-类\"><a href=\"#在-init-py-中定义方法-类\" class=\"headerlink\" title=\"在 __init__.py 中定义方法/类\"></a><strong>在 __init__.py 中定义方法/类</strong></h4><p>__init__.py 也是 python 源文件, 在其中亦可以定义方法, 类, 或者执行代码段:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># MyPackage: __init__.py</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_DBAPISet_set_equality</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> STRING == STRING</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Binary</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str(x)</span><br></pre></td></tr></table></figure></p>\n<p>此时, import 了 MyPackage 之后, 便可以正常使用定义的内容;</p>\n<h3 id=\"python-的工作-搜索路径\"><a href=\"#python-的工作-搜索路径\" class=\"headerlink\" title=\"python 的工作/搜索路径\"></a><strong>python 的工作/搜索路径</strong></h3><p>当导入一个 python 模块时, 解释器的查找路径如下:</p>\n<ol>\n<li>在当前的包中查找;</li>\n<li>在 <code>__buildin__</code> 模块中查找;</li>\n<li>在 sys.path 给定的路径中中查找;</li>\n</ol>\n<p>其中, 第一点自不必说;<br>关于 __buildin__ 模块, 更多的信息请参见另一篇文章: <a href=\"\">python module 使用总结: __buildin__</a>; 上文描述的 dir() 方法其实就是 __buildin__ 模块中的内建方法, 不需要额外引入其他模块便能直接使用;<br>而关于 sys.path, 其初始构成内容又包含了以下几处地方:</p>\n<ol>\n<li>程序的主目录;</li>\n<li>PYTHONPATH 中定义的路径;</li>\n<li>标准链接库, 例如: /usr/lib/python2.7, /usr/local/lib/python2.7 等;</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sys.path</span><br><span class=\"line\">[<span class=\"string\">''</span>, <span class=\"string\">'/usr/lib64/python27.zip'</span>, <span class=\"string\">'/usr/lib64/python2.7'</span>, <span class=\"string\">'/usr/lib/python2.7/plat-linux2'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-tk'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-old'</span>, <span class=\"string\">'/usr/lib/python2.7/lib-dynload'</span>, <span class=\"string\">'/usr/lib/python2.7/site-packages'</span>, <span class=\"string\">'/usr/lib/python2.7/site-packages'</span>]</span><br></pre></td></tr></table></figure>\n<p>如上所述, 从运行主模块的角度考虑:</p>\n<ol>\n<li>如果引入的模块是第三方模块, 那么大部分情况下, 所需要的模块在标准链接库 dist-packages 中都有, python 能够成功引到;</li>\n<li>如果引入的模块是自己的子模块, 由于子模块一定在主模块的子目录下, 所以 python 也能成功引到;</li>\n<li>如果引入的模块是自己的父模块或者兄弟模块, 这时 python 能否成功引到, 就得分情况了:</li>\n</ol>\n<p>如果工程在自己创建的目录中运行, 引入父模块或者兄弟模块, 在默认的搜索路径里是找不到的;<br>这时要想成功引到目标模块, 有两种办法:<br>(1) 向 sys.path 中拓展添加目标路径:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.path.append(os.path.abspath(<span class=\"string\">'xxx/yyy/zzz'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>(2) 使用 PYTHONPATH, 向其中添加目标路径:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /etc/profile</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;PATH&#125;</span>:<span class=\"variable\">$&#123;target_path&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PYTHONPATH=<span class=\"variable\">$&#123;PYTHONPATH&#125;</span>:<span class=\"variable\">$&#123;target_path&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>至于这两种方法的好坏, 就是仁者见仁, 智者见智的问题了;<br>使用 sys.path.append, 比较灵活, 每个模块都可以自己定义, 但缺点是需要多添加两行代码, 比较繁琐;<br>使用 PYTHONPATH, 优点是不需要在自己的模块中添加额外的代码, 但是如果自己创建的工程路径比较零散, PYTHONPATH 就需要不停地补充新路径;<br>不过, 如果有诸如公司规范之类的, 将 python 项目都部署在约定的公共目录下, 那么 PYTHONPATH 只需要添加这一个公共路径即可, 这样问题便简单了;<br>&nbsp;<br>至此, 关于 python 模块导入的基础性问题就讲完了;<br>最后要说的是, 其实本文最开始所列出的那个自定义模块 MyPackage, 其原型是 <code>MySQLdb</code>;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">python module 使用总结: __buildin__</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://www.cnblogs.com/huwang-sun/p/6993980.html\" target=\"_blank\" rel=\"noopener\">Python 中 if __name__ == ‘__main__’ 理解</a></li>\n<li><a href=\"https://www.cnblogs.com/AlwinXu/p/5658787.html\" target=\"_blank\" rel=\"noopener\">Python 中的包 ImportError</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000007837183?_ea=1477413\" target=\"_blank\" rel=\"noopener\">python import 工程内模块显示错误</a></li>\n<li><a href=\"http://blog.csdn.net/yxmmxy7913/article/details/4233420\" target=\"_blank\" rel=\"noopener\">Python模块包中__init__.py文件的作用</a></li>\n<li><a href=\"http://mikegrouchy.com/blog/2012/05/be-pythonic-__init__py.html\" target=\"_blank\" rel=\"noopener\">Be Pythonic: __init__.py</a></li>\n<li><a href=\"https://www.cnblogs.com/kex1n/p/5977051.html\" target=\"_blank\" rel=\"noopener\">Python类、模块、包的区别</a></li>\n<li><a href=\"http://blog.csdn.net/qw_xingzhe/article/details/52695486\" target=\"_blank\" rel=\"noopener\">Python环境变量PYTHONPATH设置</a></li>\n</ul>"},{"title":"logrotate 配置与运维","date":"2018-01-14T16:23:27.000Z","_content":"\n> 本文主要讨论以下几个方面:\n1. logrotate 的关键配置文件和配置项语法;\n2. logrotate 的使用与运维技巧;\n3. logrotate 的运行原理;\n4. 特殊场景下 logrotate 的代替方案;\n\n<!--more-->\n\n------\n\n### **配置文件与配置语法**\nlogrotate 的配置文件主要是 `/etc/logrotate.conf` 和 `/etc/logrotate.d` 目录;\n/etc/logrotate.conf 文件作为主配置文件, include 了 /etc/logrotate.d 目录下具体的配置内容;\n以下是 /etc/logrotate.conf 的默认内容:\n``` bash\n# 默认的历史日志保留周期单位: 周\nweekly\n# 历史日志保留四个周期单位, 即四周, 一个月\nrotate 4\n# use the syslog group by default, since this is the owning group of /var/log/syslog.\nsu root syslog\n# 当旧日志作了 rotate 之后, 将会创建一个和旧日志同名的新文件\ncreate\n# 默认使用 gzip 压缩旧日志文件\ncompress\n# 将 /etc/logrotate.d 下面的所有独立配置文件都 include 进来\ninclude /etc/logrotate.d\n```\n/etc/logrotate.conf 的默认配置优先级比 /etc/logrotate.d/ 目录下的独立配置要低, /etc/logrotate.d 下所有的独立配置文件中的配置项可以覆盖 /etc/logrotate.conf;\n以 rsyslog 的配置文件为例, 以下是 /etc/logrotate.d/rsyslog 的内容:\n``` bash\n/var/log/syslog {\n    # 以 天 为周期单位, 保留 7 天的日志\n    daily\n    rotate 7\n\t\n    # 忽略任何错误, 比如找不到文件\n    missingok\n\t\n    # not if empty, 当日志内容为空时, 不作 rotate\n    notifempty\n\t\n    # 压缩日志, 但是采用延时压缩, 即本轮周期产生的日志不压缩, 而在下一个周期时压缩之\n    compress\n    delaycompress\n\t\n    # postrotate/endscript 内的命令, 作为后处理, 会在本轮周期 rotate 之后回调执行\n    postrotate\n\tinvoke-rc.d rsyslog rotate > /dev/null\n    endscript\n}\n\n# 可以同时指定多个目标日志使用同一段配置\n/var/log/mail.info\n/var/log/mail.warn\n/var/log/mail.err\n/var/log/mail.log\n/var/log/daemon.log\n/var/log/kern.log\n/var/log/auth.log\n/var/log/user.log\n/var/log/lpr.log\n/var/log/cron.log\n/var/log/debug\n/var/log/messages {\n    weekly\n    rotate 4\n\t\n    missingok\n    notifempty\n\t\n    compress\n    delaycompress\n\t\n    # 共享处理脚本, 仅对 prerotate/postrotate 定义时生效\n    sharedscripts\n\t\n    postrotate\n\tinvoke-rc.d rsyslog rotate > /dev/null\n    endscript\n}\n```\n注意:\n\n1. `sharedscripts` 选项打开后, 所有使用该段配置作 rotate 的目标日志名都会作为参数一次性传给 prerotate/postrotate;\n而默认的选项 `nosharedscripts` 则是将每一个日志名分别作为参数传给 prerotate/postrotate;\n2. logrotate 支持的周期单位, 有 hourly, daily, weekly, monthly; 但是这里有坑: hourly 默认是不生效的, 具体原因见本文第三节;\n\n&nbsp;\n如上所叙, prerotate/postrotate 是一种在 rotate 过程中某个时机回调的一段脚本, 像这样类似的配置项总共有如下几种 (所有的配置项必须与 `endscript` 成对出现):\n``` bash\n# 在所有匹配的日志 rotate 之前, 仅执行一次\nfirstaction/endscript\n# 在日志 rotate 之前回调\nprerotate/endscript\n# 在日志 rotate 之后回调\npostrotate/endscript\n# 在所有匹配的日志 rotate 之后, 仅执行一次\nlastaction/endscript\n\n# 在某个日志将要被删除之前回调执行\npreremove/endscript\n```\n这几种回调时间点的设计, 不禁让人想到 junit 测试类几种注解的方法执行时机, 不得不说有异曲同工之妙;\n&nbsp;\nrsyslog 的 logrotate 配置是一个典型, 但同时 logrotate 还有着其他的个性化配置选项:\n``` bash\n# 以下是另一段案例\n/var/log/test.log {\n    # 不以时间为周期单位, 而是以 日志size 为周期单位, 当日志大小达到 100MB 时, 作一次 rotate, 日志保留 5 个周期\n    size=100M\n    rotate 5\n    \n    # 使用日期命名 rotate 后的旧文件, 日期格式采用 -%Y-%m-%d\n    dateext\n    dateformat -%Y-%m-%d\n    \n    # 以指定的权限掩码, owner/group 创建 rotate 后的新文件\n    create 644 root root\n    \n    postrotate\n        /usr/bin/killall -HUP rsyslogd\n    endscript\n}\n```\n\n### **logrotate 命令的常用运维选项**\n1.指定目标配置文件, 手动执行:\n``` bash\n# 将会执行 /etc/logrotate.d/ 下所有的配置\nlogrotate /etc/logrotate.conf\n# 将会只执行指定配置文件中的配置\nlogrotate /etc/logrotate.d/xxx.log\n```\n2.debug 验证配置文件正误:\n``` bash\n# -d:   --debug\n> logrotate -d /etc/logrotate.d/redis-server.log\n# output\nreading config file /etc/logrotate.d/redis-server\nHandling 1 logs\nrotating pattern: /var/log/redis/redis-server*.log  weekly (12 rotations)\nempty log files are not rotated, old logs are removed\nconsidering log /var/log/redis/redis-server.log\n  log does not need rotating\n```\n3.强制 rotate:\n即便当前不满足 rotate 的条件, force rotate 也会强制作一次 rotate, 而那些超过指定轮数的旧日志将会被删除;\nforce rotate 比较适用于加入了新的配置文件, 需要对其存量历史立即作一次 rotate;\n``` bash\n# -f:   --force\nlogrotate -f /etc/logrotate.d/xxx.log\n```\n4.verbose 详细信息:\n``` bash\n# -v:   --verbose\nlogrotate -vf /etc/logrotate.d/xxx.log\n```\n5.指定 logrotate 自身的日志文件路径:\n``` bash\n# -s:   --state\n# 默认 logrotate 的日志路径: /var/lib/logrotate/status\nlogrotate -s /tmp/logrotate.log /etc/logrotate.conf\n```\n\n### **logrotate 的运行原理及其缺陷**\nlogrotate 并不是一个 daemon service, 其本质上只是一个 '什么时候调用就什么时候立即执行一次' 的 C 程序;\n所以 logrotate 的执行, 依赖于其他 daemon service 的调用, 那么最自然的就是通过 crond 定时任务来调用了;\n默认情况下, logrotate 是一天被调用一次的, 因为与它相关的 crontab 配置在 `/etc/cron.daily` 里:\n``` bash\n#!/bin/sh\n\n# Clean non existent log file entries from status file\ncd /var/lib/logrotate\ntest -e status || touch status\nhead -1 status > status.clean\nsed 's/\"//g' status | while read logfile date\ndo\n    [ -e \"$logfile\" ] && echo \"\\\"$logfile\\\" $date\"\ndone >> status.clean\nmv status.clean status\n\ntest -x /usr/sbin/logrotate || exit 0\n/usr/sbin/logrotate /etc/logrotate.conf\n```\n如本文第二节所述, 由于 logrotate 的执行方式是通过 cron 默认 1 天执行一次, 所以按小时 rotate 的 `hourly` 配置项, 默认是不生效的; logrotate 的 manual 文档里也有说明:\n> `hourly` Log files are rotated every hour. Note that usually logrotate is configured to be run by cron daily. You have to change this configuration and run logrotate hourly to be able to really rotate logs hourly.\n\n不过, 这还不是最大的问题, 毕竟我们只要把上述脚本放到 `cron.hourly` 里, 就能解决该问题;\n这种靠定时任务来运行的方式, 最大的问题是: 当我们对某个日志配置成按 `size` 来 rotate 时, 无法做到当日志触达 size 条件时及时切分, 其所能实现的最小延时是一分钟 (当把 logrotate 脚本的定时任务配成 \\* \\* \\* \\* \\*, 即每分钟执行一次时), 没法更短了;\n\n### **其他的特殊场景**\nlogrotate 集日志切分, 日志压缩, 删除旧日志, 邮件提醒等功能为一体, 提供了非常完整的日志管理策略; 不过, 并不是所有的系统日志, 自身都不具有上述功能, 都需要依赖 logrotate 来管理自己;\n有一个非常典型, 而且使用十分广泛的场景: tomcat web 服务器; 当我们在 tomcat 上部署的服务使用了诸如 logback 之类的第三方日志框架时, 日志切分, 日志压缩等服务它自己便能够胜任了 (与 logback 相关功能的文章请见: [logback appender 使用总结]()), 而且我们绝大部分人 (去哪儿网), 即便不怎么接触 logback 的日志压缩功能, 也至少都习惯于使用 logback  `RollingFileAppender` 的基础功能去作日志切分;\n基于以上, 我们只需要一个简单的脚本, 便能够满足日常的 tomcat web 服务器日志运维:\n``` bash\n#!/bin/bash\nHOUR1=$(date -d \"1 hours ago\" +%F-%H)\nDATE7=$(date -d \"7 days ago\" +%F-%H)\n# for example: /home/web/my_server/logs\nfor i in `find /home/web/ -maxdepth 2 \\( -type d -o -type l \\) -name logs`; do\n        find -L $i -maxdepth 1 -type f \\( -name \"*${HOUR1}*\" -a ! -name \"*.gz\" \\) -exec gzip {} \\;\n        find -L $i -maxdepth 1 -type f \\( -name \"*${DATE7}*\" -a -name \"*.gz\" \\) -exec rm -f {} \\;\ndone\n```\n本节内容讨论的是针对 tomcat web 系统上的日志切分, 压缩, 以及删除等常规运维内容; 其实, 针对公司各业务线 web 系统的业务日志, 除此之外至少还有另外两项重要的运维内容: *日志冷备份收集* 与 *日志实时收集及其可视化 (ELK)*; 与之相关的内容请参见如下文章: \n\n1. [改造 flume-ng: 融入公司的技术体系]();\n2. [日志冷备份收集的方案选型]();\n\n### **站内相关文章**\n- [cron 相关全梳理]()\n- [logback appender 使用总结]()\n- [改造 flume-ng: 融入公司的技术体系]()\n- [日志冷备份收集的方案选型]()\n\n### **参考链接**\n- [Linux日志文件总管——logrotate](https://linux.cn/article-4126-1.html)\n- [被遗忘的 Logrotate](https://huoding.com/2013/04/21/246)\n\n","source":"_posts/linux-varlog--logrotate配置与运维.md","raw":"---\ntitle: logrotate 配置与运维\ndate: 2018-01-15 00:23:27\ncategories:\n - linux\n - varlog\ntags:\n - linux:varlog\n---\n\n> 本文主要讨论以下几个方面:\n1. logrotate 的关键配置文件和配置项语法;\n2. logrotate 的使用与运维技巧;\n3. logrotate 的运行原理;\n4. 特殊场景下 logrotate 的代替方案;\n\n<!--more-->\n\n------\n\n### **配置文件与配置语法**\nlogrotate 的配置文件主要是 `/etc/logrotate.conf` 和 `/etc/logrotate.d` 目录;\n/etc/logrotate.conf 文件作为主配置文件, include 了 /etc/logrotate.d 目录下具体的配置内容;\n以下是 /etc/logrotate.conf 的默认内容:\n``` bash\n# 默认的历史日志保留周期单位: 周\nweekly\n# 历史日志保留四个周期单位, 即四周, 一个月\nrotate 4\n# use the syslog group by default, since this is the owning group of /var/log/syslog.\nsu root syslog\n# 当旧日志作了 rotate 之后, 将会创建一个和旧日志同名的新文件\ncreate\n# 默认使用 gzip 压缩旧日志文件\ncompress\n# 将 /etc/logrotate.d 下面的所有独立配置文件都 include 进来\ninclude /etc/logrotate.d\n```\n/etc/logrotate.conf 的默认配置优先级比 /etc/logrotate.d/ 目录下的独立配置要低, /etc/logrotate.d 下所有的独立配置文件中的配置项可以覆盖 /etc/logrotate.conf;\n以 rsyslog 的配置文件为例, 以下是 /etc/logrotate.d/rsyslog 的内容:\n``` bash\n/var/log/syslog {\n    # 以 天 为周期单位, 保留 7 天的日志\n    daily\n    rotate 7\n\t\n    # 忽略任何错误, 比如找不到文件\n    missingok\n\t\n    # not if empty, 当日志内容为空时, 不作 rotate\n    notifempty\n\t\n    # 压缩日志, 但是采用延时压缩, 即本轮周期产生的日志不压缩, 而在下一个周期时压缩之\n    compress\n    delaycompress\n\t\n    # postrotate/endscript 内的命令, 作为后处理, 会在本轮周期 rotate 之后回调执行\n    postrotate\n\tinvoke-rc.d rsyslog rotate > /dev/null\n    endscript\n}\n\n# 可以同时指定多个目标日志使用同一段配置\n/var/log/mail.info\n/var/log/mail.warn\n/var/log/mail.err\n/var/log/mail.log\n/var/log/daemon.log\n/var/log/kern.log\n/var/log/auth.log\n/var/log/user.log\n/var/log/lpr.log\n/var/log/cron.log\n/var/log/debug\n/var/log/messages {\n    weekly\n    rotate 4\n\t\n    missingok\n    notifempty\n\t\n    compress\n    delaycompress\n\t\n    # 共享处理脚本, 仅对 prerotate/postrotate 定义时生效\n    sharedscripts\n\t\n    postrotate\n\tinvoke-rc.d rsyslog rotate > /dev/null\n    endscript\n}\n```\n注意:\n\n1. `sharedscripts` 选项打开后, 所有使用该段配置作 rotate 的目标日志名都会作为参数一次性传给 prerotate/postrotate;\n而默认的选项 `nosharedscripts` 则是将每一个日志名分别作为参数传给 prerotate/postrotate;\n2. logrotate 支持的周期单位, 有 hourly, daily, weekly, monthly; 但是这里有坑: hourly 默认是不生效的, 具体原因见本文第三节;\n\n&nbsp;\n如上所叙, prerotate/postrotate 是一种在 rotate 过程中某个时机回调的一段脚本, 像这样类似的配置项总共有如下几种 (所有的配置项必须与 `endscript` 成对出现):\n``` bash\n# 在所有匹配的日志 rotate 之前, 仅执行一次\nfirstaction/endscript\n# 在日志 rotate 之前回调\nprerotate/endscript\n# 在日志 rotate 之后回调\npostrotate/endscript\n# 在所有匹配的日志 rotate 之后, 仅执行一次\nlastaction/endscript\n\n# 在某个日志将要被删除之前回调执行\npreremove/endscript\n```\n这几种回调时间点的设计, 不禁让人想到 junit 测试类几种注解的方法执行时机, 不得不说有异曲同工之妙;\n&nbsp;\nrsyslog 的 logrotate 配置是一个典型, 但同时 logrotate 还有着其他的个性化配置选项:\n``` bash\n# 以下是另一段案例\n/var/log/test.log {\n    # 不以时间为周期单位, 而是以 日志size 为周期单位, 当日志大小达到 100MB 时, 作一次 rotate, 日志保留 5 个周期\n    size=100M\n    rotate 5\n    \n    # 使用日期命名 rotate 后的旧文件, 日期格式采用 -%Y-%m-%d\n    dateext\n    dateformat -%Y-%m-%d\n    \n    # 以指定的权限掩码, owner/group 创建 rotate 后的新文件\n    create 644 root root\n    \n    postrotate\n        /usr/bin/killall -HUP rsyslogd\n    endscript\n}\n```\n\n### **logrotate 命令的常用运维选项**\n1.指定目标配置文件, 手动执行:\n``` bash\n# 将会执行 /etc/logrotate.d/ 下所有的配置\nlogrotate /etc/logrotate.conf\n# 将会只执行指定配置文件中的配置\nlogrotate /etc/logrotate.d/xxx.log\n```\n2.debug 验证配置文件正误:\n``` bash\n# -d:   --debug\n> logrotate -d /etc/logrotate.d/redis-server.log\n# output\nreading config file /etc/logrotate.d/redis-server\nHandling 1 logs\nrotating pattern: /var/log/redis/redis-server*.log  weekly (12 rotations)\nempty log files are not rotated, old logs are removed\nconsidering log /var/log/redis/redis-server.log\n  log does not need rotating\n```\n3.强制 rotate:\n即便当前不满足 rotate 的条件, force rotate 也会强制作一次 rotate, 而那些超过指定轮数的旧日志将会被删除;\nforce rotate 比较适用于加入了新的配置文件, 需要对其存量历史立即作一次 rotate;\n``` bash\n# -f:   --force\nlogrotate -f /etc/logrotate.d/xxx.log\n```\n4.verbose 详细信息:\n``` bash\n# -v:   --verbose\nlogrotate -vf /etc/logrotate.d/xxx.log\n```\n5.指定 logrotate 自身的日志文件路径:\n``` bash\n# -s:   --state\n# 默认 logrotate 的日志路径: /var/lib/logrotate/status\nlogrotate -s /tmp/logrotate.log /etc/logrotate.conf\n```\n\n### **logrotate 的运行原理及其缺陷**\nlogrotate 并不是一个 daemon service, 其本质上只是一个 '什么时候调用就什么时候立即执行一次' 的 C 程序;\n所以 logrotate 的执行, 依赖于其他 daemon service 的调用, 那么最自然的就是通过 crond 定时任务来调用了;\n默认情况下, logrotate 是一天被调用一次的, 因为与它相关的 crontab 配置在 `/etc/cron.daily` 里:\n``` bash\n#!/bin/sh\n\n# Clean non existent log file entries from status file\ncd /var/lib/logrotate\ntest -e status || touch status\nhead -1 status > status.clean\nsed 's/\"//g' status | while read logfile date\ndo\n    [ -e \"$logfile\" ] && echo \"\\\"$logfile\\\" $date\"\ndone >> status.clean\nmv status.clean status\n\ntest -x /usr/sbin/logrotate || exit 0\n/usr/sbin/logrotate /etc/logrotate.conf\n```\n如本文第二节所述, 由于 logrotate 的执行方式是通过 cron 默认 1 天执行一次, 所以按小时 rotate 的 `hourly` 配置项, 默认是不生效的; logrotate 的 manual 文档里也有说明:\n> `hourly` Log files are rotated every hour. Note that usually logrotate is configured to be run by cron daily. You have to change this configuration and run logrotate hourly to be able to really rotate logs hourly.\n\n不过, 这还不是最大的问题, 毕竟我们只要把上述脚本放到 `cron.hourly` 里, 就能解决该问题;\n这种靠定时任务来运行的方式, 最大的问题是: 当我们对某个日志配置成按 `size` 来 rotate 时, 无法做到当日志触达 size 条件时及时切分, 其所能实现的最小延时是一分钟 (当把 logrotate 脚本的定时任务配成 \\* \\* \\* \\* \\*, 即每分钟执行一次时), 没法更短了;\n\n### **其他的特殊场景**\nlogrotate 集日志切分, 日志压缩, 删除旧日志, 邮件提醒等功能为一体, 提供了非常完整的日志管理策略; 不过, 并不是所有的系统日志, 自身都不具有上述功能, 都需要依赖 logrotate 来管理自己;\n有一个非常典型, 而且使用十分广泛的场景: tomcat web 服务器; 当我们在 tomcat 上部署的服务使用了诸如 logback 之类的第三方日志框架时, 日志切分, 日志压缩等服务它自己便能够胜任了 (与 logback 相关功能的文章请见: [logback appender 使用总结]()), 而且我们绝大部分人 (去哪儿网), 即便不怎么接触 logback 的日志压缩功能, 也至少都习惯于使用 logback  `RollingFileAppender` 的基础功能去作日志切分;\n基于以上, 我们只需要一个简单的脚本, 便能够满足日常的 tomcat web 服务器日志运维:\n``` bash\n#!/bin/bash\nHOUR1=$(date -d \"1 hours ago\" +%F-%H)\nDATE7=$(date -d \"7 days ago\" +%F-%H)\n# for example: /home/web/my_server/logs\nfor i in `find /home/web/ -maxdepth 2 \\( -type d -o -type l \\) -name logs`; do\n        find -L $i -maxdepth 1 -type f \\( -name \"*${HOUR1}*\" -a ! -name \"*.gz\" \\) -exec gzip {} \\;\n        find -L $i -maxdepth 1 -type f \\( -name \"*${DATE7}*\" -a -name \"*.gz\" \\) -exec rm -f {} \\;\ndone\n```\n本节内容讨论的是针对 tomcat web 系统上的日志切分, 压缩, 以及删除等常规运维内容; 其实, 针对公司各业务线 web 系统的业务日志, 除此之外至少还有另外两项重要的运维内容: *日志冷备份收集* 与 *日志实时收集及其可视化 (ELK)*; 与之相关的内容请参见如下文章: \n\n1. [改造 flume-ng: 融入公司的技术体系]();\n2. [日志冷备份收集的方案选型]();\n\n### **站内相关文章**\n- [cron 相关全梳理]()\n- [logback appender 使用总结]()\n- [改造 flume-ng: 融入公司的技术体系]()\n- [日志冷备份收集的方案选型]()\n\n### **参考链接**\n- [Linux日志文件总管——logrotate](https://linux.cn/article-4126-1.html)\n- [被遗忘的 Logrotate](https://huoding.com/2013/04/21/246)\n\n","slug":"linux-varlog--logrotate配置与运维","published":1,"updated":"2018-01-27T14:53:07.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5w000rj1jxbpdxtge7","content":"<blockquote>\n<p>本文主要讨论以下几个方面:</p>\n<ol>\n<li>logrotate 的关键配置文件和配置项语法;</li>\n<li>logrotate 的使用与运维技巧;</li>\n<li>logrotate 的运行原理;</li>\n<li>特殊场景下 logrotate 的代替方案;</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"配置文件与配置语法\"><a href=\"#配置文件与配置语法\" class=\"headerlink\" title=\"配置文件与配置语法\"></a><strong>配置文件与配置语法</strong></h3><p>logrotate 的配置文件主要是 <code>/etc/logrotate.conf</code> 和 <code>/etc/logrotate.d</code> 目录;<br>/etc/logrotate.conf 文件作为主配置文件, include 了 /etc/logrotate.d 目录下具体的配置内容;<br>以下是 /etc/logrotate.conf 的默认内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认的历史日志保留周期单位: 周</span></span><br><span class=\"line\">weekly</span><br><span class=\"line\"><span class=\"comment\"># 历史日志保留四个周期单位, 即四周, 一个月</span></span><br><span class=\"line\">rotate 4</span><br><span class=\"line\"><span class=\"comment\"># use the syslog group by default, since this is the owning group of /var/log/syslog.</span></span><br><span class=\"line\">su root syslog</span><br><span class=\"line\"><span class=\"comment\"># 当旧日志作了 rotate 之后, 将会创建一个和旧日志同名的新文件</span></span><br><span class=\"line\">create</span><br><span class=\"line\"><span class=\"comment\"># 默认使用 gzip 压缩旧日志文件</span></span><br><span class=\"line\">compress</span><br><span class=\"line\"><span class=\"comment\"># 将 /etc/logrotate.d 下面的所有独立配置文件都 include 进来</span></span><br><span class=\"line\">include /etc/logrotate.d</span><br></pre></td></tr></table></figure></p>\n<p>/etc/logrotate.conf 的默认配置优先级比 /etc/logrotate.d/ 目录下的独立配置要低, /etc/logrotate.d 下所有的独立配置文件中的配置项可以覆盖 /etc/logrotate.conf;<br>以 rsyslog 的配置文件为例, 以下是 /etc/logrotate.d/rsyslog 的内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/<span class=\"built_in\">log</span>/syslog &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 以 天 为周期单位, 保留 7 天的日志</span></span><br><span class=\"line\">    daily</span><br><span class=\"line\">    rotate 7</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 忽略任何错误, 比如找不到文件</span></span><br><span class=\"line\">    missingok</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># not if empty, 当日志内容为空时, 不作 rotate</span></span><br><span class=\"line\">    notifempty</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 压缩日志, 但是采用延时压缩, 即本轮周期产生的日志不压缩, 而在下一个周期时压缩之</span></span><br><span class=\"line\">    compress</span><br><span class=\"line\">    delaycompress</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># postrotate/endscript 内的命令, 作为后处理, 会在本轮周期 rotate 之后回调执行</span></span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">\tinvoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以同时指定多个目标日志使用同一段配置</span></span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.info</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.warn</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.err</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/daemon.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/kern.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/auth.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/user.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/lpr.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/cron.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/debug</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/messages &#123;</span><br><span class=\"line\">    weekly</span><br><span class=\"line\">    rotate 4</span><br><span class=\"line\">\t</span><br><span class=\"line\">    missingok</span><br><span class=\"line\">    notifempty</span><br><span class=\"line\">\t</span><br><span class=\"line\">    compress</span><br><span class=\"line\">    delaycompress</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 共享处理脚本, 仅对 prerotate/postrotate 定义时生效</span></span><br><span class=\"line\">    sharedscripts</span><br><span class=\"line\">\t</span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">\tinvoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:</p>\n<ol>\n<li><code>sharedscripts</code> 选项打开后, 所有使用该段配置作 rotate 的目标日志名都会作为参数一次性传给 prerotate/postrotate;<br>而默认的选项 <code>nosharedscripts</code> 则是将每一个日志名分别作为参数传给 prerotate/postrotate;</li>\n<li>logrotate 支持的周期单位, 有 hourly, daily, weekly, monthly; 但是这里有坑: hourly 默认是不生效的, 具体原因见本文第三节;</li>\n</ol>\n<p>&nbsp;<br>如上所叙, prerotate/postrotate 是一种在 rotate 过程中某个时机回调的一段脚本, 像这样类似的配置项总共有如下几种 (所有的配置项必须与 <code>endscript</code> 成对出现):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在所有匹配的日志 rotate 之前, 仅执行一次</span></span><br><span class=\"line\">firstaction/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在日志 rotate 之前回调</span></span><br><span class=\"line\">prerotate/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在日志 rotate 之后回调</span></span><br><span class=\"line\">postrotate/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在所有匹配的日志 rotate 之后, 仅执行一次</span></span><br><span class=\"line\">lastaction/endscript</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在某个日志将要被删除之前回调执行</span></span><br><span class=\"line\">preremove/endscript</span><br></pre></td></tr></table></figure></p>\n<p>这几种回调时间点的设计, 不禁让人想到 junit 测试类几种注解的方法执行时机, 不得不说有异曲同工之妙;<br>&nbsp;<br>rsyslog 的 logrotate 配置是一个典型, 但同时 logrotate 还有着其他的个性化配置选项:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下是另一段案例</span></span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/test.log &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 不以时间为周期单位, 而是以 日志size 为周期单位, 当日志大小达到 100MB 时, 作一次 rotate, 日志保留 5 个周期</span></span><br><span class=\"line\">    size=100M</span><br><span class=\"line\">    rotate 5</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用日期命名 rotate 后的旧文件, 日期格式采用 -%Y-%m-%d</span></span><br><span class=\"line\">    dateext</span><br><span class=\"line\">    dateformat -%Y-%m-%d</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 以指定的权限掩码, owner/group 创建 rotate 后的新文件</span></span><br><span class=\"line\">    create 644 root root</span><br><span class=\"line\">    </span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">        /usr/bin/killall -HUP rsyslogd</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"logrotate-命令的常用运维选项\"><a href=\"#logrotate-命令的常用运维选项\" class=\"headerlink\" title=\"logrotate 命令的常用运维选项\"></a><strong>logrotate 命令的常用运维选项</strong></h3><p>1.指定目标配置文件, 手动执行:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将会执行 /etc/logrotate.d/ 下所有的配置</span></span><br><span class=\"line\">logrotate /etc/logrotate.conf</span><br><span class=\"line\"><span class=\"comment\"># 将会只执行指定配置文件中的配置</span></span><br><span class=\"line\">logrotate /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>2.debug 验证配置文件正误:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d:   --debug</span></span><br><span class=\"line\">&gt; logrotate -d /etc/logrotate.d/redis-server.log</span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\">reading config file /etc/logrotate.d/redis-server</span><br><span class=\"line\">Handling 1 logs</span><br><span class=\"line\">rotating pattern: /var/<span class=\"built_in\">log</span>/redis/redis-server*.<span class=\"built_in\">log</span>  weekly (12 rotations)</span><br><span class=\"line\">empty <span class=\"built_in\">log</span> files are not rotated, old logs are removed</span><br><span class=\"line\">considering <span class=\"built_in\">log</span> /var/<span class=\"built_in\">log</span>/redis/redis-server.log</span><br><span class=\"line\">  <span class=\"built_in\">log</span> does not need rotating</span><br></pre></td></tr></table></figure></p>\n<p>3.强制 rotate:<br>即便当前不满足 rotate 的条件, force rotate 也会强制作一次 rotate, 而那些超过指定轮数的旧日志将会被删除;<br>force rotate 比较适用于加入了新的配置文件, 需要对其存量历史立即作一次 rotate;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -f:   --force</span></span><br><span class=\"line\">logrotate -f /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>4.verbose 详细信息:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -v:   --verbose</span></span><br><span class=\"line\">logrotate -vf /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>5.指定 logrotate 自身的日志文件路径:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -s:   --state</span></span><br><span class=\"line\"><span class=\"comment\"># 默认 logrotate 的日志路径: /var/lib/logrotate/status</span></span><br><span class=\"line\">logrotate -s /tmp/logrotate.log /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"logrotate-的运行原理及其缺陷\"><a href=\"#logrotate-的运行原理及其缺陷\" class=\"headerlink\" title=\"logrotate 的运行原理及其缺陷\"></a><strong>logrotate 的运行原理及其缺陷</strong></h3><p>logrotate 并不是一个 daemon service, 其本质上只是一个 ‘什么时候调用就什么时候立即执行一次’ 的 C 程序;<br>所以 logrotate 的执行, 依赖于其他 daemon service 的调用, 那么最自然的就是通过 crond 定时任务来调用了;<br>默认情况下, logrotate 是一天被调用一次的, 因为与它相关的 crontab 配置在 <code>/etc/cron.daily</code> 里:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean non existent log file entries from status file</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/logrotate</span><br><span class=\"line\"><span class=\"built_in\">test</span> -e status || touch status</span><br><span class=\"line\">head -1 status &gt; status.clean</span><br><span class=\"line\">sed <span class=\"string\">'s/\"//g'</span> status | <span class=\"keyword\">while</span> <span class=\"built_in\">read</span> logfile date</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    [ -e <span class=\"string\">\"<span class=\"variable\">$logfile</span>\"</span> ] &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"\\\"<span class=\"variable\">$logfile</span>\\\" <span class=\"variable\">$date</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">done</span> &gt;&gt; status.clean</span><br><span class=\"line\">mv status.clean status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">test</span> -x /usr/sbin/logrotate || <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">/usr/sbin/logrotate /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p>\n<p>如本文第二节所述, 由于 logrotate 的执行方式是通过 cron 默认 1 天执行一次, 所以按小时 rotate 的 <code>hourly</code> 配置项, 默认是不生效的; logrotate 的 manual 文档里也有说明:</p>\n<blockquote>\n<p><code>hourly</code> Log files are rotated every hour. Note that usually logrotate is configured to be run by cron daily. You have to change this configuration and run logrotate hourly to be able to really rotate logs hourly.</p>\n</blockquote>\n<p>不过, 这还不是最大的问题, 毕竟我们只要把上述脚本放到 <code>cron.hourly</code> 里, 就能解决该问题;<br>这种靠定时任务来运行的方式, 最大的问题是: 当我们对某个日志配置成按 <code>size</code> 来 rotate 时, 无法做到当日志触达 size 条件时及时切分, 其所能实现的最小延时是一分钟 (当把 logrotate 脚本的定时任务配成 * * * * *, 即每分钟执行一次时), 没法更短了;</p>\n<h3 id=\"其他的特殊场景\"><a href=\"#其他的特殊场景\" class=\"headerlink\" title=\"其他的特殊场景\"></a><strong>其他的特殊场景</strong></h3><p>logrotate 集日志切分, 日志压缩, 删除旧日志, 邮件提醒等功能为一体, 提供了非常完整的日志管理策略; 不过, 并不是所有的系统日志, 自身都不具有上述功能, 都需要依赖 logrotate 来管理自己;<br>有一个非常典型, 而且使用十分广泛的场景: tomcat web 服务器; 当我们在 tomcat 上部署的服务使用了诸如 logback 之类的第三方日志框架时, 日志切分, 日志压缩等服务它自己便能够胜任了 (与 logback 相关功能的文章请见: <a href=\"\">logback appender 使用总结</a>), 而且我们绝大部分人 (去哪儿网), 即便不怎么接触 logback 的日志压缩功能, 也至少都习惯于使用 logback  <code>RollingFileAppender</code> 的基础功能去作日志切分;<br>基于以上, 我们只需要一个简单的脚本, 便能够满足日常的 tomcat web 服务器日志运维:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">HOUR1=$(date -d <span class=\"string\">\"1 hours ago\"</span> +%F-%H)</span><br><span class=\"line\">DATE7=$(date -d <span class=\"string\">\"7 days ago\"</span> +%F-%H)</span><br><span class=\"line\"><span class=\"comment\"># for example: /home/web/my_server/logs</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `find /home/web/ -maxdepth 2 \\( -<span class=\"built_in\">type</span> d -o -<span class=\"built_in\">type</span> l \\) -name logs`; <span class=\"keyword\">do</span></span><br><span class=\"line\">        find -L <span class=\"variable\">$i</span> -maxdepth 1 -<span class=\"built_in\">type</span> f \\( -name <span class=\"string\">\"*<span class=\"variable\">$&#123;HOUR1&#125;</span>*\"</span> -a ! -name <span class=\"string\">\"*.gz\"</span> \\) -<span class=\"built_in\">exec</span> gzip &#123;&#125; \\;</span><br><span class=\"line\">        find -L <span class=\"variable\">$i</span> -maxdepth 1 -<span class=\"built_in\">type</span> f \\( -name <span class=\"string\">\"*<span class=\"variable\">$&#123;DATE7&#125;</span>*\"</span> -a -name <span class=\"string\">\"*.gz\"</span> \\) -<span class=\"built_in\">exec</span> rm -f &#123;&#125; \\;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<p>本节内容讨论的是针对 tomcat web 系统上的日志切分, 压缩, 以及删除等常规运维内容; 其实, 针对公司各业务线 web 系统的业务日志, 除此之外至少还有另外两项重要的运维内容: <em>日志冷备份收集</em> 与 <em>日志实时收集及其可视化 (ELK)</em>; 与之相关的内容请参见如下文章: </p>\n<ol>\n<li><a href=\"\">改造 flume-ng: 融入公司的技术体系</a>;</li>\n<li><a href=\"\">日志冷备份收集的方案选型</a>;</li>\n</ol>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">cron 相关全梳理</a></li>\n<li><a href=\"\">logback appender 使用总结</a></li>\n<li><a href=\"\">改造 flume-ng: 融入公司的技术体系</a></li>\n<li><a href=\"\">日志冷备份收集的方案选型</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://linux.cn/article-4126-1.html\" target=\"_blank\" rel=\"noopener\">Linux日志文件总管——logrotate</a></li>\n<li><a href=\"https://huoding.com/2013/04/21/246\" target=\"_blank\" rel=\"noopener\">被遗忘的 Logrotate</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要讨论以下几个方面:</p>\n<ol>\n<li>logrotate 的关键配置文件和配置项语法;</li>\n<li>logrotate 的使用与运维技巧;</li>\n<li>logrotate 的运行原理;</li>\n<li>特殊场景下 logrotate 的代替方案;</li>\n</ol>\n</blockquote>","more":"<hr>\n<h3 id=\"配置文件与配置语法\"><a href=\"#配置文件与配置语法\" class=\"headerlink\" title=\"配置文件与配置语法\"></a><strong>配置文件与配置语法</strong></h3><p>logrotate 的配置文件主要是 <code>/etc/logrotate.conf</code> 和 <code>/etc/logrotate.d</code> 目录;<br>/etc/logrotate.conf 文件作为主配置文件, include 了 /etc/logrotate.d 目录下具体的配置内容;<br>以下是 /etc/logrotate.conf 的默认内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认的历史日志保留周期单位: 周</span></span><br><span class=\"line\">weekly</span><br><span class=\"line\"><span class=\"comment\"># 历史日志保留四个周期单位, 即四周, 一个月</span></span><br><span class=\"line\">rotate 4</span><br><span class=\"line\"><span class=\"comment\"># use the syslog group by default, since this is the owning group of /var/log/syslog.</span></span><br><span class=\"line\">su root syslog</span><br><span class=\"line\"><span class=\"comment\"># 当旧日志作了 rotate 之后, 将会创建一个和旧日志同名的新文件</span></span><br><span class=\"line\">create</span><br><span class=\"line\"><span class=\"comment\"># 默认使用 gzip 压缩旧日志文件</span></span><br><span class=\"line\">compress</span><br><span class=\"line\"><span class=\"comment\"># 将 /etc/logrotate.d 下面的所有独立配置文件都 include 进来</span></span><br><span class=\"line\">include /etc/logrotate.d</span><br></pre></td></tr></table></figure></p>\n<p>/etc/logrotate.conf 的默认配置优先级比 /etc/logrotate.d/ 目录下的独立配置要低, /etc/logrotate.d 下所有的独立配置文件中的配置项可以覆盖 /etc/logrotate.conf;<br>以 rsyslog 的配置文件为例, 以下是 /etc/logrotate.d/rsyslog 的内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/<span class=\"built_in\">log</span>/syslog &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 以 天 为周期单位, 保留 7 天的日志</span></span><br><span class=\"line\">    daily</span><br><span class=\"line\">    rotate 7</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 忽略任何错误, 比如找不到文件</span></span><br><span class=\"line\">    missingok</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># not if empty, 当日志内容为空时, 不作 rotate</span></span><br><span class=\"line\">    notifempty</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 压缩日志, 但是采用延时压缩, 即本轮周期产生的日志不压缩, 而在下一个周期时压缩之</span></span><br><span class=\"line\">    compress</span><br><span class=\"line\">    delaycompress</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># postrotate/endscript 内的命令, 作为后处理, 会在本轮周期 rotate 之后回调执行</span></span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">\tinvoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以同时指定多个目标日志使用同一段配置</span></span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.info</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.warn</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.err</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/mail.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/daemon.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/kern.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/auth.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/user.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/lpr.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/cron.log</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/debug</span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/messages &#123;</span><br><span class=\"line\">    weekly</span><br><span class=\"line\">    rotate 4</span><br><span class=\"line\">\t</span><br><span class=\"line\">    missingok</span><br><span class=\"line\">    notifempty</span><br><span class=\"line\">\t</span><br><span class=\"line\">    compress</span><br><span class=\"line\">    delaycompress</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 共享处理脚本, 仅对 prerotate/postrotate 定义时生效</span></span><br><span class=\"line\">    sharedscripts</span><br><span class=\"line\">\t</span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">\tinvoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:</p>\n<ol>\n<li><code>sharedscripts</code> 选项打开后, 所有使用该段配置作 rotate 的目标日志名都会作为参数一次性传给 prerotate/postrotate;<br>而默认的选项 <code>nosharedscripts</code> 则是将每一个日志名分别作为参数传给 prerotate/postrotate;</li>\n<li>logrotate 支持的周期单位, 有 hourly, daily, weekly, monthly; 但是这里有坑: hourly 默认是不生效的, 具体原因见本文第三节;</li>\n</ol>\n<p>&nbsp;<br>如上所叙, prerotate/postrotate 是一种在 rotate 过程中某个时机回调的一段脚本, 像这样类似的配置项总共有如下几种 (所有的配置项必须与 <code>endscript</code> 成对出现):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在所有匹配的日志 rotate 之前, 仅执行一次</span></span><br><span class=\"line\">firstaction/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在日志 rotate 之前回调</span></span><br><span class=\"line\">prerotate/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在日志 rotate 之后回调</span></span><br><span class=\"line\">postrotate/endscript</span><br><span class=\"line\"><span class=\"comment\"># 在所有匹配的日志 rotate 之后, 仅执行一次</span></span><br><span class=\"line\">lastaction/endscript</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在某个日志将要被删除之前回调执行</span></span><br><span class=\"line\">preremove/endscript</span><br></pre></td></tr></table></figure></p>\n<p>这几种回调时间点的设计, 不禁让人想到 junit 测试类几种注解的方法执行时机, 不得不说有异曲同工之妙;<br>&nbsp;<br>rsyslog 的 logrotate 配置是一个典型, 但同时 logrotate 还有着其他的个性化配置选项:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下是另一段案例</span></span><br><span class=\"line\">/var/<span class=\"built_in\">log</span>/test.log &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 不以时间为周期单位, 而是以 日志size 为周期单位, 当日志大小达到 100MB 时, 作一次 rotate, 日志保留 5 个周期</span></span><br><span class=\"line\">    size=100M</span><br><span class=\"line\">    rotate 5</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用日期命名 rotate 后的旧文件, 日期格式采用 -%Y-%m-%d</span></span><br><span class=\"line\">    dateext</span><br><span class=\"line\">    dateformat -%Y-%m-%d</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 以指定的权限掩码, owner/group 创建 rotate 后的新文件</span></span><br><span class=\"line\">    create 644 root root</span><br><span class=\"line\">    </span><br><span class=\"line\">    postrotate</span><br><span class=\"line\">        /usr/bin/killall -HUP rsyslogd</span><br><span class=\"line\">    endscript</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"logrotate-命令的常用运维选项\"><a href=\"#logrotate-命令的常用运维选项\" class=\"headerlink\" title=\"logrotate 命令的常用运维选项\"></a><strong>logrotate 命令的常用运维选项</strong></h3><p>1.指定目标配置文件, 手动执行:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将会执行 /etc/logrotate.d/ 下所有的配置</span></span><br><span class=\"line\">logrotate /etc/logrotate.conf</span><br><span class=\"line\"><span class=\"comment\"># 将会只执行指定配置文件中的配置</span></span><br><span class=\"line\">logrotate /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>2.debug 验证配置文件正误:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -d:   --debug</span></span><br><span class=\"line\">&gt; logrotate -d /etc/logrotate.d/redis-server.log</span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\">reading config file /etc/logrotate.d/redis-server</span><br><span class=\"line\">Handling 1 logs</span><br><span class=\"line\">rotating pattern: /var/<span class=\"built_in\">log</span>/redis/redis-server*.<span class=\"built_in\">log</span>  weekly (12 rotations)</span><br><span class=\"line\">empty <span class=\"built_in\">log</span> files are not rotated, old logs are removed</span><br><span class=\"line\">considering <span class=\"built_in\">log</span> /var/<span class=\"built_in\">log</span>/redis/redis-server.log</span><br><span class=\"line\">  <span class=\"built_in\">log</span> does not need rotating</span><br></pre></td></tr></table></figure></p>\n<p>3.强制 rotate:<br>即便当前不满足 rotate 的条件, force rotate 也会强制作一次 rotate, 而那些超过指定轮数的旧日志将会被删除;<br>force rotate 比较适用于加入了新的配置文件, 需要对其存量历史立即作一次 rotate;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -f:   --force</span></span><br><span class=\"line\">logrotate -f /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>4.verbose 详细信息:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -v:   --verbose</span></span><br><span class=\"line\">logrotate -vf /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p>\n<p>5.指定 logrotate 自身的日志文件路径:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -s:   --state</span></span><br><span class=\"line\"><span class=\"comment\"># 默认 logrotate 的日志路径: /var/lib/logrotate/status</span></span><br><span class=\"line\">logrotate -s /tmp/logrotate.log /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"logrotate-的运行原理及其缺陷\"><a href=\"#logrotate-的运行原理及其缺陷\" class=\"headerlink\" title=\"logrotate 的运行原理及其缺陷\"></a><strong>logrotate 的运行原理及其缺陷</strong></h3><p>logrotate 并不是一个 daemon service, 其本质上只是一个 ‘什么时候调用就什么时候立即执行一次’ 的 C 程序;<br>所以 logrotate 的执行, 依赖于其他 daemon service 的调用, 那么最自然的就是通过 crond 定时任务来调用了;<br>默认情况下, logrotate 是一天被调用一次的, 因为与它相关的 crontab 配置在 <code>/etc/cron.daily</code> 里:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean non existent log file entries from status file</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /var/lib/logrotate</span><br><span class=\"line\"><span class=\"built_in\">test</span> -e status || touch status</span><br><span class=\"line\">head -1 status &gt; status.clean</span><br><span class=\"line\">sed <span class=\"string\">'s/\"//g'</span> status | <span class=\"keyword\">while</span> <span class=\"built_in\">read</span> logfile date</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    [ -e <span class=\"string\">\"<span class=\"variable\">$logfile</span>\"</span> ] &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"\\\"<span class=\"variable\">$logfile</span>\\\" <span class=\"variable\">$date</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">done</span> &gt;&gt; status.clean</span><br><span class=\"line\">mv status.clean status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">test</span> -x /usr/sbin/logrotate || <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\">/usr/sbin/logrotate /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p>\n<p>如本文第二节所述, 由于 logrotate 的执行方式是通过 cron 默认 1 天执行一次, 所以按小时 rotate 的 <code>hourly</code> 配置项, 默认是不生效的; logrotate 的 manual 文档里也有说明:</p>\n<blockquote>\n<p><code>hourly</code> Log files are rotated every hour. Note that usually logrotate is configured to be run by cron daily. You have to change this configuration and run logrotate hourly to be able to really rotate logs hourly.</p>\n</blockquote>\n<p>不过, 这还不是最大的问题, 毕竟我们只要把上述脚本放到 <code>cron.hourly</code> 里, 就能解决该问题;<br>这种靠定时任务来运行的方式, 最大的问题是: 当我们对某个日志配置成按 <code>size</code> 来 rotate 时, 无法做到当日志触达 size 条件时及时切分, 其所能实现的最小延时是一分钟 (当把 logrotate 脚本的定时任务配成 * * * * *, 即每分钟执行一次时), 没法更短了;</p>\n<h3 id=\"其他的特殊场景\"><a href=\"#其他的特殊场景\" class=\"headerlink\" title=\"其他的特殊场景\"></a><strong>其他的特殊场景</strong></h3><p>logrotate 集日志切分, 日志压缩, 删除旧日志, 邮件提醒等功能为一体, 提供了非常完整的日志管理策略; 不过, 并不是所有的系统日志, 自身都不具有上述功能, 都需要依赖 logrotate 来管理自己;<br>有一个非常典型, 而且使用十分广泛的场景: tomcat web 服务器; 当我们在 tomcat 上部署的服务使用了诸如 logback 之类的第三方日志框架时, 日志切分, 日志压缩等服务它自己便能够胜任了 (与 logback 相关功能的文章请见: <a href=\"\">logback appender 使用总结</a>), 而且我们绝大部分人 (去哪儿网), 即便不怎么接触 logback 的日志压缩功能, 也至少都习惯于使用 logback  <code>RollingFileAppender</code> 的基础功能去作日志切分;<br>基于以上, 我们只需要一个简单的脚本, 便能够满足日常的 tomcat web 服务器日志运维:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">HOUR1=$(date -d <span class=\"string\">\"1 hours ago\"</span> +%F-%H)</span><br><span class=\"line\">DATE7=$(date -d <span class=\"string\">\"7 days ago\"</span> +%F-%H)</span><br><span class=\"line\"><span class=\"comment\"># for example: /home/web/my_server/logs</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `find /home/web/ -maxdepth 2 \\( -<span class=\"built_in\">type</span> d -o -<span class=\"built_in\">type</span> l \\) -name logs`; <span class=\"keyword\">do</span></span><br><span class=\"line\">        find -L <span class=\"variable\">$i</span> -maxdepth 1 -<span class=\"built_in\">type</span> f \\( -name <span class=\"string\">\"*<span class=\"variable\">$&#123;HOUR1&#125;</span>*\"</span> -a ! -name <span class=\"string\">\"*.gz\"</span> \\) -<span class=\"built_in\">exec</span> gzip &#123;&#125; \\;</span><br><span class=\"line\">        find -L <span class=\"variable\">$i</span> -maxdepth 1 -<span class=\"built_in\">type</span> f \\( -name <span class=\"string\">\"*<span class=\"variable\">$&#123;DATE7&#125;</span>*\"</span> -a -name <span class=\"string\">\"*.gz\"</span> \\) -<span class=\"built_in\">exec</span> rm -f &#123;&#125; \\;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<p>本节内容讨论的是针对 tomcat web 系统上的日志切分, 压缩, 以及删除等常规运维内容; 其实, 针对公司各业务线 web 系统的业务日志, 除此之外至少还有另外两项重要的运维内容: <em>日志冷备份收集</em> 与 <em>日志实时收集及其可视化 (ELK)</em>; 与之相关的内容请参见如下文章: </p>\n<ol>\n<li><a href=\"\">改造 flume-ng: 融入公司的技术体系</a>;</li>\n<li><a href=\"\">日志冷备份收集的方案选型</a>;</li>\n</ol>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">cron 相关全梳理</a></li>\n<li><a href=\"\">logback appender 使用总结</a></li>\n<li><a href=\"\">改造 flume-ng: 融入公司的技术体系</a></li>\n<li><a href=\"\">日志冷备份收集的方案选型</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://linux.cn/article-4126-1.html\" target=\"_blank\" rel=\"noopener\">Linux日志文件总管——logrotate</a></li>\n<li><a href=\"https://huoding.com/2013/04/21/246\" target=\"_blank\" rel=\"noopener\">被遗忘的 Logrotate</a></li>\n</ul>"},{"title":"bash 结束死循环的方法","date":"2017-11-04T16:00:00.000Z","_content":"\n> linux 中有很多实用的工具, 采用了这样一种工作方式:\n定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;\n类似的工具包括 ioutil, jmap 等;\n本文整理了实现上述逻辑的一些典型方法;\n\n<!--more-->\n\n### **方法1: 监听命令返回值**\n根据 [GNU 相关规范](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status), 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;\n那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;\n```\nwhile [ 1 ]; do\n    COMMAND\n    test $? -gt 128 && break\ndone\n```\n更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:\n```\n# SIGINT = 2, 128 + SIGINT = 130\ntest $? -eq 130 && break\n```\n特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:\n```\nwhile [ 1 ]; do\n    COMMAND -e\n    test $? -gt 128 && break\ndone\n```\n\n### **方法2: 命令返回值短路**\n方法2 是方法1 的简化版本:\n```\nwhile [ 1 ]; do\n    COMMAND -e || break\ndone\n```\n其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;\n这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;\n这是方法2 相比 方法1 略显不精准的地方;\n\n### **方法3: 使用 trap 捕获信号**\n\n```\n# 捕获到 SIGINT 即 exit 0 正常退出\ntrap \"exit 0\" SIGINT\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n### **方法4: 使用 ctrl + z 配合 SIGTERM 信号**\n当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:\n``` bash\n# ^Z\n[1]+  Stopped                 COMMAND\n\n# 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号\nkill %1\n# 发送 SIGTERM 信号给最近一次被挂起的进程\nkill %%\n\n# 执行的结果\n[1]+ Terminated               COMMAND\n```\n\n### **方法5: 使用 -e 选项**\n使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;\n```\n#!/bin/bash\nset -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n或者作为 bash 的参数:\n```\n#!/bin/bash -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n\n### **参考链接**\n- [Terminating an infinite loop](https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop)\n- [3.7.5 Exit Status](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status)\n- [How to stop the loop bash script in terminal](https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465)\n- [Unix/Linux 脚本中 “set -e” 的作用](http://blog.csdn.net/todd911/article/details/9954961)\n\n","source":"_posts/linux-shell--bash结束死循环的方法.md","raw":"---\ntitle: bash 结束死循环的方法\ndate: 2017-11-05\ntags:\n  - linux:shell\ncategories:\n  - linux\n  - shell\n---\n\n> linux 中有很多实用的工具, 采用了这样一种工作方式:\n定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;\n类似的工具包括 ioutil, jmap 等;\n本文整理了实现上述逻辑的一些典型方法;\n\n<!--more-->\n\n### **方法1: 监听命令返回值**\n根据 [GNU 相关规范](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status), 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;\n那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;\n```\nwhile [ 1 ]; do\n    COMMAND\n    test $? -gt 128 && break\ndone\n```\n更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:\n```\n# SIGINT = 2, 128 + SIGINT = 130\ntest $? -eq 130 && break\n```\n特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:\n```\nwhile [ 1 ]; do\n    COMMAND -e\n    test $? -gt 128 && break\ndone\n```\n\n### **方法2: 命令返回值短路**\n方法2 是方法1 的简化版本:\n```\nwhile [ 1 ]; do\n    COMMAND -e || break\ndone\n```\n其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;\n这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;\n这是方法2 相比 方法1 略显不精准的地方;\n\n### **方法3: 使用 trap 捕获信号**\n\n```\n# 捕获到 SIGINT 即 exit 0 正常退出\ntrap \"exit 0\" SIGINT\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n### **方法4: 使用 ctrl + z 配合 SIGTERM 信号**\n当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:\n``` bash\n# ^Z\n[1]+  Stopped                 COMMAND\n\n# 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号\nkill %1\n# 发送 SIGTERM 信号给最近一次被挂起的进程\nkill %%\n\n# 执行的结果\n[1]+ Terminated               COMMAND\n```\n\n### **方法5: 使用 -e 选项**\n使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;\n```\n#!/bin/bash\nset -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n或者作为 bash 的参数:\n```\n#!/bin/bash -e\nwhile [ 1 ]; do\n    COMMAND -e\ndone\n```\n\n\n### **参考链接**\n- [Terminating an infinite loop](https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop)\n- [3.7.5 Exit Status](http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status)\n- [How to stop the loop bash script in terminal](https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465)\n- [Unix/Linux 脚本中 “set -e” 的作用](http://blog.csdn.net/todd911/article/details/9954961)\n\n","slug":"linux-shell--bash结束死循环的方法","published":1,"updated":"2018-01-02T15:41:21.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5y000vj1jxk0jacm2w","content":"<blockquote>\n<p>linux 中有很多实用的工具, 采用了这样一种工作方式:<br>定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;<br>类似的工具包括 ioutil, jmap 等;<br>本文整理了实现上述逻辑的一些典型方法;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"方法1-监听命令返回值\"><a href=\"#方法1-监听命令返回值\" class=\"headerlink\" title=\"方法1: 监听命令返回值\"></a><strong>方法1: 监听命令返回值</strong></h3><p>根据 <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">GNU 相关规范</a>, 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;<br>那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIGINT = 2, 128 + SIGINT = 130</span><br><span class=\"line\">test $? -eq 130 &amp;&amp; break</span><br></pre></td></tr></table></figure></p>\n<p>特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2-命令返回值短路\"><a href=\"#方法2-命令返回值短路\" class=\"headerlink\" title=\"方法2: 命令返回值短路\"></a><strong>方法2: 命令返回值短路</strong></h3><p>方法2 是方法1 的简化版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e || break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;<br>这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;<br>这是方法2 相比 方法1 略显不精准的地方;</p>\n<h3 id=\"方法3-使用-trap-捕获信号\"><a href=\"#方法3-使用-trap-捕获信号\" class=\"headerlink\" title=\"方法3: 使用 trap 捕获信号\"></a><strong>方法3: 使用 trap 捕获信号</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 捕获到 SIGINT 即 exit 0 正常退出</span><br><span class=\"line\">trap &quot;exit 0&quot; SIGINT</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法4-使用-ctrl-z-配合-SIGTERM-信号\"><a href=\"#方法4-使用-ctrl-z-配合-SIGTERM-信号\" class=\"headerlink\" title=\"方法4: 使用 ctrl + z 配合 SIGTERM 信号\"></a><strong>方法4: 使用 ctrl + z 配合 SIGTERM 信号</strong></h3><p>当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ^Z</span></span><br><span class=\"line\">[1]+  Stopped                 COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGTERM 信号给最近一次被挂起的进程</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行的结果</span></span><br><span class=\"line\">[1]+ Terminated               COMMAND</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法5-使用-e-选项\"><a href=\"#方法5-使用-e-选项\" class=\"headerlink\" title=\"方法5: 使用 -e 选项\"></a><strong>方法5: 使用 -e 选项</strong></h3><p>使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">set -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>或者作为 bash 的参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Terminating an infinite loop</a></li>\n<li><a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">3.7.5 Exit Status</a></li>\n<li><a href=\"https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465\" target=\"_blank\" rel=\"noopener\">How to stop the loop bash script in terminal</a></li>\n<li><a href=\"http://blog.csdn.net/todd911/article/details/9954961\" target=\"_blank\" rel=\"noopener\">Unix/Linux 脚本中 “set -e” 的作用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>linux 中有很多实用的工具, 采用了这样一种工作方式:<br>定时执行(1/s, 1/3s 等)一次指定逻辑, 当用户按下 ctrl + c 发出 SIGINT 信号时, 结束进程; 如果接收不到 SIGINT/SIGTERM 等信号, 进程则会一直执行下去;<br>类似的工具包括 ioutil, jmap 等;<br>本文整理了实现上述逻辑的一些典型方法;</p>\n</blockquote>","more":"<h3 id=\"方法1-监听命令返回值\"><a href=\"#方法1-监听命令返回值\" class=\"headerlink\" title=\"方法1: 监听命令返回值\"></a><strong>方法1: 监听命令返回值</strong></h3><p>根据 <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">GNU 相关规范</a>, 如果一个进程是由于响应信号 signal 而终止, 其返回码必须是 128 + signal_number;<br>那么, 可以通过判断其返回码 $? 是否大于 128 而判断 COMMAND 是否响应了信号;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>更精确的, 如果只想判断 COMMAND 是否响应了 SIGINT 信号, 可以直接判断:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIGINT = 2, 128 + SIGINT = 130</span><br><span class=\"line\">test $? -eq 130 &amp;&amp; break</span><br></pre></td></tr></table></figure></p>\n<p>特殊的情况下, COMMAND 忽略了 SIGINT 信号, 可以使用 -e 选项强制其响应 SIGINT 信号:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">    test $? -gt 128 &amp;&amp; break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2-命令返回值短路\"><a href=\"#方法2-命令返回值短路\" class=\"headerlink\" title=\"方法2: 命令返回值短路\"></a><strong>方法2: 命令返回值短路</strong></h3><p>方法2 是方法1 的简化版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e || break</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>其本质是监听 COMMAND 的返回值 $? 是否为 0, 如果是 0, 那么 break 中断命令就被短路了; 如果是非 0, 便会执行 break, 跳出死循环;<br>这种方法巧妙得使用 || 逻辑运算符简化了代码, 但是有一个缺陷: 当 COMMAND 并非因为响应 ctrl + c 而是其他错误返回了非 0 的状态时, 循环也会结束;<br>这是方法2 相比 方法1 略显不精准的地方;</p>\n<h3 id=\"方法3-使用-trap-捕获信号\"><a href=\"#方法3-使用-trap-捕获信号\" class=\"headerlink\" title=\"方法3: 使用 trap 捕获信号\"></a><strong>方法3: 使用 trap 捕获信号</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 捕获到 SIGINT 即 exit 0 正常退出</span><br><span class=\"line\">trap &quot;exit 0&quot; SIGINT</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法4-使用-ctrl-z-配合-SIGTERM-信号\"><a href=\"#方法4-使用-ctrl-z-配合-SIGTERM-信号\" class=\"headerlink\" title=\"方法4: 使用 ctrl + z 配合 SIGTERM 信号\"></a><strong>方法4: 使用 ctrl + z 配合 SIGTERM 信号</strong></h3><p>当命令运行在前台, 使用 ctrl + z 挂起进程, 会得到以下输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ^Z</span></span><br><span class=\"line\">[1]+  Stopped                 COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 是挂起进程的作业号(job number), kill [job_number] 会向该作业发送 SIGtERM 信号</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %1</span><br><span class=\"line\"><span class=\"comment\"># 发送 SIGTERM 信号给最近一次被挂起的进程</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> %%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行的结果</span></span><br><span class=\"line\">[1]+ Terminated               COMMAND</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法5-使用-e-选项\"><a href=\"#方法5-使用-e-选项\" class=\"headerlink\" title=\"方法5: 使用 -e 选项\"></a><strong>方法5: 使用 -e 选项</strong></h3><p>使用 set -e, 开启命令返回码校验功能, 一旦 COMMAND 返回非 0, 立即结束进程;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">set -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>或者作为 bash 的参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -e</span><br><span class=\"line\">while [ 1 ]; do</span><br><span class=\"line\">    COMMAND -e</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://unix.stackexchange.com/questions/42287/terminating-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Terminating an infinite loop</a></li>\n<li><a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status\" target=\"_blank\" rel=\"noopener\">3.7.5 Exit Status</a></li>\n<li><a href=\"https://unix.stackexchange.com/questions/48425/how-to-stop-the-loop-bash-script-in-terminal/48465#48465\" target=\"_blank\" rel=\"noopener\">How to stop the loop bash script in terminal</a></li>\n<li><a href=\"http://blog.csdn.net/todd911/article/details/9954961\" target=\"_blank\" rel=\"noopener\">Unix/Linux 脚本中 “set -e” 的作用</a></li>\n</ul>"},{"title":"rsyncd 配置与运维","date":"2017-10-14T15:20:21.000Z","_content":"\n> 本文主要梳理 rsync server 的基本配置与使用方式;\n\n<!--more-->\n\n### **rsync server 的几个关键配置文件**\n1. /etc/rsyncd.conf: 主配置文件;\n2. /etc/rsyncd.password/rsyncd.secrets: 秘钥文件;\n3. /etc/rsyncd.motd: rysnc 服务器元信息, 非必须;\n\n其中, rsyncd.password 秘钥文件的掩码必须是 600:\n``` bash\n> ll /etc/ | grep rsyncd\n-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf\n-rw-------   1 root root     24 Apr  6  2017 rsyncd.password\n```\n\n### **rsyncd.conf 配置说明**\n一个典型的 rsyncd.conf 文件如下:\n``` bash\n# rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置\nuid=nobody\ngid=nobody\n\n# 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下\nuser chroot = no\n\nmax connections = 200\ntimeout = 600\n\npid file = /data1/trans_file/rsyncd.pid\nlock file = /data1/trans_file/rsyncd.lock\nlog file = /data1/trans_file/rsyncd.log\n# 用户秘钥文件, 可在具体的模块中配置\nsecrets file = /etc/rsyncd.password\n# 服务器元信息, 非必选\n# motd file = /etc/rsyncd/rsyncd.motd\n# 指定不需要压缩就可以直接传输的文件类型\ndont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2\n\n# 模块配置\n[wireless_log]\n# 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输\nauth users = sync\npath = /data1/trans_file/files/wireless_log\nignore errors\n# 是否只读\nread only = no\n# 是否允许列出模块里的内容\nlist = no\n```\n\n### **rsyncd.password / rsyncd.secrets 配置说明**\n以 `:` 分隔, 用户名和密码, 每行一个:\n```\nuser1:password1\nuser2:password2\n```\n\n### **rsyncd 启动方式**\n``` bash\n# 当负载高时, 以守护进程的方式运行 rsyncd\nsudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf\n```\n\n### **参考链接**\n- [centos下配置rsyncd服务器](https://segmentfault.com/a/1190000000444614)\n- [RSync实现文件备份同步](http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html)\n\n","source":"_posts/rsync--rsyncd配置与运行.md","raw":"---\ntitle: rsyncd 配置与运维\ndate: 2017-10-14 23:20:21\ntags:\n  - rsync\ncategories:\n  - rsync\n---\n\n> 本文主要梳理 rsync server 的基本配置与使用方式;\n\n<!--more-->\n\n### **rsync server 的几个关键配置文件**\n1. /etc/rsyncd.conf: 主配置文件;\n2. /etc/rsyncd.password/rsyncd.secrets: 秘钥文件;\n3. /etc/rsyncd.motd: rysnc 服务器元信息, 非必须;\n\n其中, rsyncd.password 秘钥文件的掩码必须是 600:\n``` bash\n> ll /etc/ | grep rsyncd\n-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf\n-rw-------   1 root root     24 Apr  6  2017 rsyncd.password\n```\n\n### **rsyncd.conf 配置说明**\n一个典型的 rsyncd.conf 文件如下:\n``` bash\n# rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置\nuid=nobody\ngid=nobody\n\n# 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下\nuser chroot = no\n\nmax connections = 200\ntimeout = 600\n\npid file = /data1/trans_file/rsyncd.pid\nlock file = /data1/trans_file/rsyncd.lock\nlog file = /data1/trans_file/rsyncd.log\n# 用户秘钥文件, 可在具体的模块中配置\nsecrets file = /etc/rsyncd.password\n# 服务器元信息, 非必选\n# motd file = /etc/rsyncd/rsyncd.motd\n# 指定不需要压缩就可以直接传输的文件类型\ndont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2\n\n# 模块配置\n[wireless_log]\n# 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输\nauth users = sync\npath = /data1/trans_file/files/wireless_log\nignore errors\n# 是否只读\nread only = no\n# 是否允许列出模块里的内容\nlist = no\n```\n\n### **rsyncd.password / rsyncd.secrets 配置说明**\n以 `:` 分隔, 用户名和密码, 每行一个:\n```\nuser1:password1\nuser2:password2\n```\n\n### **rsyncd 启动方式**\n``` bash\n# 当负载高时, 以守护进程的方式运行 rsyncd\nsudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf\n```\n\n### **参考链接**\n- [centos下配置rsyncd服务器](https://segmentfault.com/a/1190000000444614)\n- [RSync实现文件备份同步](http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html)\n\n","slug":"rsync--rsyncd配置与运行","published":1,"updated":"2018-01-27T14:53:07.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd5z000xj1jxyd7zq5wl","content":"<blockquote>\n<p>本文主要梳理 rsync server 的基本配置与使用方式;</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"rsync-server-的几个关键配置文件\"><a href=\"#rsync-server-的几个关键配置文件\" class=\"headerlink\" title=\"rsync server 的几个关键配置文件\"></a><strong>rsync server 的几个关键配置文件</strong></h3><ol>\n<li>/etc/rsyncd.conf: 主配置文件;</li>\n<li>/etc/rsyncd.password/rsyncd.secrets: 秘钥文件;</li>\n<li>/etc/rsyncd.motd: rysnc 服务器元信息, 非必须;</li>\n</ol>\n<p>其中, rsyncd.password 秘钥文件的掩码必须是 600:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ll /etc/ | grep rsyncd</span><br><span class=\"line\">-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf</span><br><span class=\"line\">-rw-------   1 root root     24 Apr  6  2017 rsyncd.password</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-conf-配置说明\"><a href=\"#rsyncd-conf-配置说明\" class=\"headerlink\" title=\"rsyncd.conf 配置说明\"></a><strong>rsyncd.conf 配置说明</strong></h3><p>一个典型的 rsyncd.conf 文件如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置</span></span><br><span class=\"line\">uid=nobody</span><br><span class=\"line\">gid=nobody</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下</span></span><br><span class=\"line\">user chroot = no</span><br><span class=\"line\"></span><br><span class=\"line\">max connections = 200</span><br><span class=\"line\">timeout = 600</span><br><span class=\"line\"></span><br><span class=\"line\">pid file = /data1/trans_file/rsyncd.pid</span><br><span class=\"line\">lock file = /data1/trans_file/rsyncd.lock</span><br><span class=\"line\"><span class=\"built_in\">log</span> file = /data1/trans_file/rsyncd.log</span><br><span class=\"line\"><span class=\"comment\"># 用户秘钥文件, 可在具体的模块中配置</span></span><br><span class=\"line\">secrets file = /etc/rsyncd.password</span><br><span class=\"line\"><span class=\"comment\"># 服务器元信息, 非必选</span></span><br><span class=\"line\"><span class=\"comment\"># motd file = /etc/rsyncd/rsyncd.motd</span></span><br><span class=\"line\"><span class=\"comment\"># 指定不需要压缩就可以直接传输的文件类型</span></span><br><span class=\"line\">dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模块配置</span></span><br><span class=\"line\">[wireless_log]</span><br><span class=\"line\"><span class=\"comment\"># 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输</span></span><br><span class=\"line\">auth users = sync</span><br><span class=\"line\">path = /data1/trans_file/files/wireless_log</span><br><span class=\"line\">ignore errors</span><br><span class=\"line\"><span class=\"comment\"># 是否只读</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> only = no</span><br><span class=\"line\"><span class=\"comment\"># 是否允许列出模块里的内容</span></span><br><span class=\"line\">list = no</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-password-rsyncd-secrets-配置说明\"><a href=\"#rsyncd-password-rsyncd-secrets-配置说明\" class=\"headerlink\" title=\"rsyncd.password / rsyncd.secrets 配置说明\"></a><strong>rsyncd.password / rsyncd.secrets 配置说明</strong></h3><p>以 <code>:</code> 分隔, 用户名和密码, 每行一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user1:password1</span><br><span class=\"line\">user2:password2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-启动方式\"><a href=\"#rsyncd-启动方式\" class=\"headerlink\" title=\"rsyncd 启动方式\"></a><strong>rsyncd 启动方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当负载高时, 以守护进程的方式运行 rsyncd</span></span><br><span class=\"line\">sudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000000444614\" target=\"_blank\" rel=\"noopener\">centos下配置rsyncd服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html\" target=\"_blank\" rel=\"noopener\">RSync实现文件备份同步</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要梳理 rsync server 的基本配置与使用方式;</p>\n</blockquote>","more":"<h3 id=\"rsync-server-的几个关键配置文件\"><a href=\"#rsync-server-的几个关键配置文件\" class=\"headerlink\" title=\"rsync server 的几个关键配置文件\"></a><strong>rsync server 的几个关键配置文件</strong></h3><ol>\n<li>/etc/rsyncd.conf: 主配置文件;</li>\n<li>/etc/rsyncd.password/rsyncd.secrets: 秘钥文件;</li>\n<li>/etc/rsyncd.motd: rysnc 服务器元信息, 非必须;</li>\n</ol>\n<p>其中, rsyncd.password 秘钥文件的掩码必须是 600:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ll /etc/ | grep rsyncd</span><br><span class=\"line\">-rw-r--r--   1 root root    361 Apr  6  2017 rsyncd.conf</span><br><span class=\"line\">-rw-------   1 root root     24 Apr  6  2017 rsyncd.password</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-conf-配置说明\"><a href=\"#rsyncd-conf-配置说明\" class=\"headerlink\" title=\"rsyncd.conf 配置说明\"></a><strong>rsyncd.conf 配置说明</strong></h3><p>一个典型的 rsyncd.conf 文件如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rsyncd 守护进程运行系统用户全局配置, 可在具体的块中配置</span></span><br><span class=\"line\">uid=nobody</span><br><span class=\"line\">gid=nobody</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是否需要 chroot, 若为 yes, 当客户端连接某模块时, 首先 chroot 到 模块的 path 目录下</span></span><br><span class=\"line\">user chroot = no</span><br><span class=\"line\"></span><br><span class=\"line\">max connections = 200</span><br><span class=\"line\">timeout = 600</span><br><span class=\"line\"></span><br><span class=\"line\">pid file = /data1/trans_file/rsyncd.pid</span><br><span class=\"line\">lock file = /data1/trans_file/rsyncd.lock</span><br><span class=\"line\"><span class=\"built_in\">log</span> file = /data1/trans_file/rsyncd.log</span><br><span class=\"line\"><span class=\"comment\"># 用户秘钥文件, 可在具体的模块中配置</span></span><br><span class=\"line\">secrets file = /etc/rsyncd.password</span><br><span class=\"line\"><span class=\"comment\"># 服务器元信息, 非必选</span></span><br><span class=\"line\"><span class=\"comment\"># motd file = /etc/rsyncd/rsyncd.motd</span></span><br><span class=\"line\"><span class=\"comment\"># 指定不需要压缩就可以直接传输的文件类型</span></span><br><span class=\"line\">dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模块配置</span></span><br><span class=\"line\">[wireless_log]</span><br><span class=\"line\"><span class=\"comment\"># 模块使用的 user, 此模块将使用 rsyncd.password 文件中 sync 用户对应的秘钥进行文件传输</span></span><br><span class=\"line\">auth users = sync</span><br><span class=\"line\">path = /data1/trans_file/files/wireless_log</span><br><span class=\"line\">ignore errors</span><br><span class=\"line\"><span class=\"comment\"># 是否只读</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> only = no</span><br><span class=\"line\"><span class=\"comment\"># 是否允许列出模块里的内容</span></span><br><span class=\"line\">list = no</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-password-rsyncd-secrets-配置说明\"><a href=\"#rsyncd-password-rsyncd-secrets-配置说明\" class=\"headerlink\" title=\"rsyncd.password / rsyncd.secrets 配置说明\"></a><strong>rsyncd.password / rsyncd.secrets 配置说明</strong></h3><p>以 <code>:</code> 分隔, 用户名和密码, 每行一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user1:password1</span><br><span class=\"line\">user2:password2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"rsyncd-启动方式\"><a href=\"#rsyncd-启动方式\" class=\"headerlink\" title=\"rsyncd 启动方式\"></a><strong>rsyncd 启动方式</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当负载高时, 以守护进程的方式运行 rsyncd</span></span><br><span class=\"line\">sudo /usr/bin/rsync --daemon --config=/etc/rsyncd.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000000444614\" target=\"_blank\" rel=\"noopener\">centos下配置rsyncd服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/itech/archive/2009/08/10/1542945.html\" target=\"_blank\" rel=\"noopener\">RSync实现文件备份同步</a></li>\n</ul>"},{"title":"nginx module 使用总结: ngx_http_gzip_module","date":"2017-12-21T07:13:33.000Z","_content":"<!--more-->\n","source":"_posts/nginx-module--nginx_module_使用总结_ngx_http_gzip_module.md","raw":"---\ntitle: 'nginx module 使用总结: ngx_http_gzip_module'\ndate: 2017-12-21 15:13:33\ncategories:\n - nginx\n - module\ntags:\n - nginx\n - nginx:module\n---\n<!--more-->\n","slug":"nginx-module--nginx_module_使用总结_ngx_http_gzip_module","published":1,"updated":"2018-03-26T03:43:48.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd610010j1jxsrrl9a9i","content":"<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"","more":""},{"title":"python module 使用总结: 定时调度器","date":"2018-02-23T15:23:21.000Z","_content":"\n> 在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;\n我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:\n1. 简单的实现: sched 与 schedule;\n2. 功能增强版: apscheduler;\n3. 分布式调度器: celery;\n\n<!--more-->\n\n------\n\n## **sched**\nsched 是 python 官方提供的定时调度模块, 其实现非常的简单, sched.py 的代码量只有一百多行, 且只有一个类: scheduler;\n``` python\n# sched.py\nclass scheduler:\n    \"\"\"\n        @param timefunc     能够返回时间戳的计时函数, 要求该函数是一个无参函数\n        @param delayfunc    能够阻塞给定时间的阻塞函数, 要求该函数能接收一个数值类型的参数\n    \"\"\"\n    def __init__(self, timefunc, delayfunc);\n    \n    \"\"\"\n        @param delay        需要延迟的时间\n        @param priority     当多个任务需要在同一个时间调度时的优先级\n        @param action       需要调度的函数\n        @param argument     需要调度函数的参数列表\n    \"\"\"\n    def enter(self, delay, priority, action, argument);\n```\n如上所示, scheduler 是使用构造器传进来的计时函数与阻塞函数去实现调度逻辑的;\n\n### **sched 的局限性与解决方案**\n不过说真的, 把 sched 定义为定时调度模块真的很牵强:\n常规意义上, 我们所理解的定时调度器, 应该是能够像 cron 那样, 按给定的时间间隔或在指定的时间点上循环执行指定的任务; 但是 sched 并不能做到这一点, sched 所做的, 只是从某一个时间点开始, delay 一段我们给定的延时时间, 然后执行给定方法, 仅执行这一次;\n``` python\nimport time\nfrom sched import scheduler\n\ndef do_task(time_str):\n    print('task run: %s' % time_str)\n\ns = scheduler(time.time, time.sleep)\n# delay 5 秒后执行 do_task 函数, 仅执行一次\ns.enter(5, 0, do_task, (time.time(),))\ns.run()\n```\n要想 sched 做到循环执行, 还需要在其基础上包装上一层类似'递归'的概念:\n``` python\ns = scheduler(time.time, time.sleep)\n# 在任务函数中将自己再次用 sched 调度以实现循环\ndef do_task(time_str):\n    s.enter(5, 0, do_task, (time.time(),))\n    print('task run: %s' % time_str)\n    \ns.enter(5, 0, do_task, (time.time(),))\ns.run()\n```\n当然, 这只是将函数自己的引用传给了 scheduler, 神似递归但并非递归, 所以也就不存在找不到递归出口而爆栈的问题了;\n很明显, 采用这种方式才能实现真正的定时调度, 可谓非常麻烦而蹩脚;\n\n### **sched 的调度原理**\nsched 使用 `heapq` 优先队列来管理需要调度的任务(关于 heapq 的详细内容请参考: [python module 使用总结: heapq]()); 在调用了 scheduler 类的 enter 方法后, 其实是生成了一个任务的快照, 并放入了优先队列里:\n``` python\nevent = Event(time, priority, action, argument)\nheapq.heappush(self._queue, event)\n```\n在调用 scheduler.run() 方法后, sched 在一个死循环里, 不断得从优先队列里取出任务执行, 计算最近的下一个任务的等待时间并阻塞:\n``` python\nq = self._queue\n while q:\n    time, priority, action, argument = checked_event = q[0]\n    now = timefunc()\n    if now < time:\n        delayfunc(time - now)\n    else:\n        event = pop(q)\n        if event is checked_event:\n            action(*argument)\n            delayfunc(0)\n        else:\n            heapq.heappush(q, event)\n```\n总体来说, sched 的设计还是比较紧凑清晰的, 轻量化; 但是由于其固有的缺陷, 在复杂的场景中, 往往不能胜任, 我们需要功能更强大的调度框架;\n\n## **schedule**\nschedule 是一个广泛使用的 python 定时调度框架, 其 github 地址如下: [https://github.com/dbader/schedule](https://github.com/dbader/schedule), 目前 4k 多个 stars;\n和 python 官方的 sched 相比, schedule 的 API 要人性化得多, 而且它基本实现了真正意义上的定时调度:\n``` python\nimport schedule\nimport time\n\ndef do_task(time_str=time.time()):\n    print('task run: %s' % time_str)\n\n# 每 10 分钟执行一次任务\nschedule.every(10).minutes.do(do_task)\n# 每隔 5 到 10 分钟之间的任意一个时间执行一次任务\nschedule.every(5).to(10).days.do(do_task)\n# 每 1 小时执行一次任务\nschedule.every().hour.do(do_task, time_str='1519351479.19554')\n# 每天 10:30 执行一次任务\nschedule.every().day.at(\"10:30\").do(do_task)\n\nwhile True:\n    schedule.run_pending()\n    time.sleep(1)\n```\n\n### **schedule 模块的 Scheduler 类**\n其实, schedule 模块的整体设计, 是把任务的自我管理部分做的很详细, 而把上层的调度做的很轻很薄, 关键逻辑点采用回调的方式, 依赖任务的自我管理去实现;\n而上一节所讲的 sched 模块, 则是在上层调度部分使用了复杂的逻辑 (优先队列) 去统一管理, 而任务本身携带的信息很少; sched 与 schedule 两个模块, 在整体设计上, 形成了鲜明的对比;\nScheduler 类的实例中, 维护了一个列表: jobs, 专门存储注册进来的任务快照;\n``` python\nClass Scheduler(object):\n    def __init__(self):\n        self.jobs = []\n```\nScheduler 类最重要的方法是 `run_pending(self)`, 其主要逻辑是遍历 jobs 列表中的所有 job, 从中找出当前时间点需要调度的 job, 并执行;\n这其中最重要的逻辑是判断一个 job 当前时间点是否需要被调度, 而这个过程是一个回调, 具体的逻辑则封装在 job.should_run 方法里, 下一小节将会详细介绍;\n可以发现, 总共只用了三行代码, 以此可见其轻量化;\n``` python\ndef run_pending(self):\n    _jobs = (job for job in self.jobs if job.should_run)\n    for job in sorted(runnable_jobs):\n        self._run_job(job)\n```\n值得注意的是, schedule 模块中并没有专门的逻辑去定时执行 run_pending 方法, 要想让定时调度持续跑起来, 需要自己实现:\n``` python\nwhile True:\n    schedule.run_pending()\n    time.sleep(1)\n```\n相比 sched 模块的 '伪递归' 而言, 这样的设计算是比较人性化的了, 可以认为它基本实现了真正意义上的定时调度;\n\n### **schedule 模块的 Job 类**\n正如上一节所述, schedule 模块实现了非常详细的任务自我管理逻辑; 相比 sched 的 `Event` 类, schedule 定义了一个控制参数更丰富的 `Job` 类:\n``` python\nclass Job(object):\n    def __init__(self, interval, scheduler=None):\n        self.interval = interval  # pause interval * unit between runs\n        self.latest = None  # upper limit to the interval\n        self.job_func = None  # the job job_func to run\n        self.unit = None  # time units, e.g. 'minutes', 'hours', ...\n        self.at_time = None  # optional time at which this job runs\n        self.last_run = None  # datetime of the last run\n        self.next_run = None  # datetime of the next run\n        self.period = None  # timedelta between runs, only valid for\n        self.start_day = None  # Specific day of the week to start on\n        self.tags = set()  # unique set of tags for the job\n        self.scheduler = scheduler  # scheduler to register with\n```\nJob 类的参数众多, 单个任务的调度肯定不可能涉及到所有的参数, 这些参数往往是以局部几个为组合, 控制调度节奏的; 但是无论什么组合, 往往都会以 `scheduler.every(interval=1)` 方法开始, 以 `Job.do(self, job_func, *args, **kwargs)` 方法结束:\n(1) schedule.every 方法构造出一个 `Job` 实例, 并设置该实例的第一个参数 interval;\n``` python\ndefault_scheduler = Scheduler()\n\ndef every(interval=1):\n    return default_scheduler.every(interval)\n\nclass Scheduler(object):\n    def every(self, interval=1):\n        job = Job(interval, self)\n        return job\n```\n这里想吐槽的是, 这个方法出现在 Scheduler 类中有点突兀, 而且方法名叫 every, 只体现了设置 interval 参数的含义, 但并不能从中看出其新构造一个 Job 实例的意图;\n(2) Job.do 方法包装了传递进来的任务函数, 将其设置为自己的 job_func 参数, 并将自己作为一个任务快照放进 scheduler 的任务列表里;\n``` python\nClass Job(object):\n    def do(self, job_func, *args, **kwargs):\n        self.job_func = functools.partial(job_func, *args, **kwargs)\n        try:\n            functools.update_wrapper(self.job_func, job_func)\n        except AttributeError:\n            pass\n        # 计算下一次调度的时间\n        self._schedule_next_run()\n        self.scheduler.jobs.append(self)\n        return self\n```\n在这两个方法之间, 就是通过建造者模式, 构造出其他控制参数的组合, 以实现各种各样的调度节奏;\n下面来重点讲一下各参数组合如何实现调度节奏的控制;\n从上一节关于 Scheduler 类的描述中可以看到, 上层调度中最关键的逻辑, 判断每一个注册的 job 是否应该被调度, 其实是 Job 类的一个回调方法 `should_run`:\n``` python\ndef should_run(self):\n    return datetime.datetime.now() >= self.next_run\n```\n而 should_run 方法中的判断的依据, 是当前时间有没有到达 `next_run` 这个实例字段给出的时间点;\nnext_run 字段的设置则通过在 `Job.do(self, job_func, *args, **kwargs)` 方法 (上文已给出) 和 `Job.run(self)` 方法中调用 `__schedule_next_run()` 方法来实现:\n``` python\ndef run(self):\n    logger.info('Running job %s', self)\n    ret = self.job_func()\n    self.last_run = datetime.datetime.now()\n    # 计算下一次调度的时间\n    self._schedule_next_run()\n    return ret\n```\n所以, 所有的秘密就存在于 `_schedule_next_run()` 方法里了; 下面将结合几大类参数组合的设置, 拆开来分析 _schedule_next_run() 方法的逻辑;\n这些 Job 类的参数组合, 大致可分为这几类:\n#### **总基调: 指定调度的周期**\n以下方法将会设置 unit 参数, 与 interval 参数结合, 定义调度区间间隔:\n``` python\ndef second(self):   def seconds(self):  # self.unit = 'seconds'\ndef minute(self):   def minutes(self):  # self.unit = 'minutes'\ndef hour(self):     def hours(self):    # self.unit = 'hours'\ndef day(self):      def days(self):     # self.unit = 'days'\ndef week(self):     def weeks(self):    # self.unit = 'weeks'\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')\n    if self.latest is not None:\n        assert self.latest >= self.interval\n        interval = random.randint(self.interval, self.latest)\n    else:\n        interval = self.interval\n\n    self.period = datetime.timedelta(**{self.unit: interval})\n    self.next_run = datetime.datetime.now() + self.period\n```\n先不管其中涉及到的 latest 字段 (下文描述), 其他的逻辑清晰可见: 使用 unit 和 interval 构造出一个指定的 timedelta, 加上当前时间得到下次调度的时间;\n&nbsp;\n这是最简单的一类, 定下了整个调度的总体节奏; 而下面几个类别的参数并不能单独决定调度周期, 而是在第一类参数的基础之上实施局部调整, 以达到综合控制;\n#### **局部调整1: 指定调度的起始 weekday**\n以下方法将会设置 start_day 参数, 确定调度开始的时间点; 同时统一设置 unit 参数为 'weeks':\n``` python\ndef monday(self):       \n    self.start_day = 'monday'\n    self.unit = 'weeks'\ndef tuesday(self):      \n    self.start_day = 'tuesday'\n    self.unit = 'weeks'\ndef wednesday(self):    \n    self.start_day = 'wednesday'\n    self.unit = 'weeks'\ndef thursday(self):   \n    self.start_day = 'thurday'\n    self.unit = 'weeks'\ndef friday(self):       \n    self.start_day = 'friday'\n    self.unit = 'weeks'\ndef saturday(self):     \n    self.start_day = 'saturday'\n    self.unit = 'weeks'\ndef sunday(self):     \n    self.start_day = 'sunday'\n    self.unit = 'weeks'\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    if self.start_day is not None:\n        assert self.unit == 'weeks'\n        weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')\n        assert self.start_day in weekdays\n        weekday = weekdays.index(self.start_day)\n        days_ahead = weekday - self.next_run.weekday()\n        if days_ahead <= 0:  # Target day already happened this week\n            days_ahead += 7\n        self.next_run += datetime.timedelta(days_ahead) - self.period\n```\n可以发现, start_day 只是在 next_run 原有的 weekday 基础上增加了一个 offset, 相当于是 delay time;\n#### **局部调整2: 指定调度的起始时间**\n以下方法将会设置 at_time 参数, 其针对 unit == 'hours' 只设置 minute 变量, 而对 unit == 'days' 或 'weeks' 才会设置 hour 变量;\n``` python\ndef at(self, time_str):\n    assert self.unit in ('days', 'hours') or self.start_day\n    hour, minute = time_str.split(':')\n    minute = int(minute)\n    if self.unit == 'days' or self.start_day:\n        hour = int(hour)\n        assert 0 <= hour <= 23\n    elif self.unit == 'hours':\n        hour = 0\n    assert 0 <= minute <= 59\n    self.at_time = datetime.time(hour, minute)\n    return self\n```\n其对应的 _schedule_next_run() 逻辑也与上面类似, 针对 unit == 'days' 或 'weeks' 才设 hour 字段, 否则只设置 minute 和 second;\n``` python\n# def _schedule_next_run(self)\n    if self.at_time is not None:\n        assert self.unit in ('days', 'hours') or self.start_day is not None\n        kwargs = {\n            'minute': self.at_time.minute,\n            'second': self.at_time.second,\n            'microsecond': 0\n        }\n        if self.unit == 'days' or self.start_day is not None:\n            kwargs['hour'] = self.at_time.hour\n        self.next_run = self.next_run.replace(**kwargs)\n```\n#### **局部调整3: 在给定范围内随机安排调度时刻**\n对应的就是上文提及的 latest 参数:\n``` python\ndef to(self, latest):\n    self.latest = latest\n    return self\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    if self.latest is not None:\n        assert self.latest >= self.interval\n        interval = random.randint(self.interval, self.latest)\n    else:\n        interval = self.interval\n```\n具体逻辑就是在给定的 [interval, latest) 区间内, 生成一个随机数作为下次调度的 interval;\n&nbsp;\n至此, Job 类的逻辑就都分析完了;\n\n## **apscheduler**\n\n\n## **celery**\n\n\n## **站内相关文章**\n- [python module 使用总结: heapq]()\n\n## **参考链接**\n- [8.8. sched — Event scheduler](https://docs.python.org/2/library/sched.html)\n- [python sched模块学习](http://blog.csdn.net/leonard_wang/article/details/54017537)\n- [python中的轻量级定时任务调度库: schedule](https://www.cnblogs.com/anpengapple/p/8051923.html)\n\n","source":"_posts/python-module--python_module_使用总结_定时调度器.md","raw":"---\ntitle: 'python module 使用总结: 定时调度器'\ndate: 2018-02-23 23:23:21\ncategories:\n - python\n - module\ntags:\n - python\n - python:module\n---\n\n> 在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;\n我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:\n1. 简单的实现: sched 与 schedule;\n2. 功能增强版: apscheduler;\n3. 分布式调度器: celery;\n\n<!--more-->\n\n------\n\n## **sched**\nsched 是 python 官方提供的定时调度模块, 其实现非常的简单, sched.py 的代码量只有一百多行, 且只有一个类: scheduler;\n``` python\n# sched.py\nclass scheduler:\n    \"\"\"\n        @param timefunc     能够返回时间戳的计时函数, 要求该函数是一个无参函数\n        @param delayfunc    能够阻塞给定时间的阻塞函数, 要求该函数能接收一个数值类型的参数\n    \"\"\"\n    def __init__(self, timefunc, delayfunc);\n    \n    \"\"\"\n        @param delay        需要延迟的时间\n        @param priority     当多个任务需要在同一个时间调度时的优先级\n        @param action       需要调度的函数\n        @param argument     需要调度函数的参数列表\n    \"\"\"\n    def enter(self, delay, priority, action, argument);\n```\n如上所示, scheduler 是使用构造器传进来的计时函数与阻塞函数去实现调度逻辑的;\n\n### **sched 的局限性与解决方案**\n不过说真的, 把 sched 定义为定时调度模块真的很牵强:\n常规意义上, 我们所理解的定时调度器, 应该是能够像 cron 那样, 按给定的时间间隔或在指定的时间点上循环执行指定的任务; 但是 sched 并不能做到这一点, sched 所做的, 只是从某一个时间点开始, delay 一段我们给定的延时时间, 然后执行给定方法, 仅执行这一次;\n``` python\nimport time\nfrom sched import scheduler\n\ndef do_task(time_str):\n    print('task run: %s' % time_str)\n\ns = scheduler(time.time, time.sleep)\n# delay 5 秒后执行 do_task 函数, 仅执行一次\ns.enter(5, 0, do_task, (time.time(),))\ns.run()\n```\n要想 sched 做到循环执行, 还需要在其基础上包装上一层类似'递归'的概念:\n``` python\ns = scheduler(time.time, time.sleep)\n# 在任务函数中将自己再次用 sched 调度以实现循环\ndef do_task(time_str):\n    s.enter(5, 0, do_task, (time.time(),))\n    print('task run: %s' % time_str)\n    \ns.enter(5, 0, do_task, (time.time(),))\ns.run()\n```\n当然, 这只是将函数自己的引用传给了 scheduler, 神似递归但并非递归, 所以也就不存在找不到递归出口而爆栈的问题了;\n很明显, 采用这种方式才能实现真正的定时调度, 可谓非常麻烦而蹩脚;\n\n### **sched 的调度原理**\nsched 使用 `heapq` 优先队列来管理需要调度的任务(关于 heapq 的详细内容请参考: [python module 使用总结: heapq]()); 在调用了 scheduler 类的 enter 方法后, 其实是生成了一个任务的快照, 并放入了优先队列里:\n``` python\nevent = Event(time, priority, action, argument)\nheapq.heappush(self._queue, event)\n```\n在调用 scheduler.run() 方法后, sched 在一个死循环里, 不断得从优先队列里取出任务执行, 计算最近的下一个任务的等待时间并阻塞:\n``` python\nq = self._queue\n while q:\n    time, priority, action, argument = checked_event = q[0]\n    now = timefunc()\n    if now < time:\n        delayfunc(time - now)\n    else:\n        event = pop(q)\n        if event is checked_event:\n            action(*argument)\n            delayfunc(0)\n        else:\n            heapq.heappush(q, event)\n```\n总体来说, sched 的设计还是比较紧凑清晰的, 轻量化; 但是由于其固有的缺陷, 在复杂的场景中, 往往不能胜任, 我们需要功能更强大的调度框架;\n\n## **schedule**\nschedule 是一个广泛使用的 python 定时调度框架, 其 github 地址如下: [https://github.com/dbader/schedule](https://github.com/dbader/schedule), 目前 4k 多个 stars;\n和 python 官方的 sched 相比, schedule 的 API 要人性化得多, 而且它基本实现了真正意义上的定时调度:\n``` python\nimport schedule\nimport time\n\ndef do_task(time_str=time.time()):\n    print('task run: %s' % time_str)\n\n# 每 10 分钟执行一次任务\nschedule.every(10).minutes.do(do_task)\n# 每隔 5 到 10 分钟之间的任意一个时间执行一次任务\nschedule.every(5).to(10).days.do(do_task)\n# 每 1 小时执行一次任务\nschedule.every().hour.do(do_task, time_str='1519351479.19554')\n# 每天 10:30 执行一次任务\nschedule.every().day.at(\"10:30\").do(do_task)\n\nwhile True:\n    schedule.run_pending()\n    time.sleep(1)\n```\n\n### **schedule 模块的 Scheduler 类**\n其实, schedule 模块的整体设计, 是把任务的自我管理部分做的很详细, 而把上层的调度做的很轻很薄, 关键逻辑点采用回调的方式, 依赖任务的自我管理去实现;\n而上一节所讲的 sched 模块, 则是在上层调度部分使用了复杂的逻辑 (优先队列) 去统一管理, 而任务本身携带的信息很少; sched 与 schedule 两个模块, 在整体设计上, 形成了鲜明的对比;\nScheduler 类的实例中, 维护了一个列表: jobs, 专门存储注册进来的任务快照;\n``` python\nClass Scheduler(object):\n    def __init__(self):\n        self.jobs = []\n```\nScheduler 类最重要的方法是 `run_pending(self)`, 其主要逻辑是遍历 jobs 列表中的所有 job, 从中找出当前时间点需要调度的 job, 并执行;\n这其中最重要的逻辑是判断一个 job 当前时间点是否需要被调度, 而这个过程是一个回调, 具体的逻辑则封装在 job.should_run 方法里, 下一小节将会详细介绍;\n可以发现, 总共只用了三行代码, 以此可见其轻量化;\n``` python\ndef run_pending(self):\n    _jobs = (job for job in self.jobs if job.should_run)\n    for job in sorted(runnable_jobs):\n        self._run_job(job)\n```\n值得注意的是, schedule 模块中并没有专门的逻辑去定时执行 run_pending 方法, 要想让定时调度持续跑起来, 需要自己实现:\n``` python\nwhile True:\n    schedule.run_pending()\n    time.sleep(1)\n```\n相比 sched 模块的 '伪递归' 而言, 这样的设计算是比较人性化的了, 可以认为它基本实现了真正意义上的定时调度;\n\n### **schedule 模块的 Job 类**\n正如上一节所述, schedule 模块实现了非常详细的任务自我管理逻辑; 相比 sched 的 `Event` 类, schedule 定义了一个控制参数更丰富的 `Job` 类:\n``` python\nclass Job(object):\n    def __init__(self, interval, scheduler=None):\n        self.interval = interval  # pause interval * unit between runs\n        self.latest = None  # upper limit to the interval\n        self.job_func = None  # the job job_func to run\n        self.unit = None  # time units, e.g. 'minutes', 'hours', ...\n        self.at_time = None  # optional time at which this job runs\n        self.last_run = None  # datetime of the last run\n        self.next_run = None  # datetime of the next run\n        self.period = None  # timedelta between runs, only valid for\n        self.start_day = None  # Specific day of the week to start on\n        self.tags = set()  # unique set of tags for the job\n        self.scheduler = scheduler  # scheduler to register with\n```\nJob 类的参数众多, 单个任务的调度肯定不可能涉及到所有的参数, 这些参数往往是以局部几个为组合, 控制调度节奏的; 但是无论什么组合, 往往都会以 `scheduler.every(interval=1)` 方法开始, 以 `Job.do(self, job_func, *args, **kwargs)` 方法结束:\n(1) schedule.every 方法构造出一个 `Job` 实例, 并设置该实例的第一个参数 interval;\n``` python\ndefault_scheduler = Scheduler()\n\ndef every(interval=1):\n    return default_scheduler.every(interval)\n\nclass Scheduler(object):\n    def every(self, interval=1):\n        job = Job(interval, self)\n        return job\n```\n这里想吐槽的是, 这个方法出现在 Scheduler 类中有点突兀, 而且方法名叫 every, 只体现了设置 interval 参数的含义, 但并不能从中看出其新构造一个 Job 实例的意图;\n(2) Job.do 方法包装了传递进来的任务函数, 将其设置为自己的 job_func 参数, 并将自己作为一个任务快照放进 scheduler 的任务列表里;\n``` python\nClass Job(object):\n    def do(self, job_func, *args, **kwargs):\n        self.job_func = functools.partial(job_func, *args, **kwargs)\n        try:\n            functools.update_wrapper(self.job_func, job_func)\n        except AttributeError:\n            pass\n        # 计算下一次调度的时间\n        self._schedule_next_run()\n        self.scheduler.jobs.append(self)\n        return self\n```\n在这两个方法之间, 就是通过建造者模式, 构造出其他控制参数的组合, 以实现各种各样的调度节奏;\n下面来重点讲一下各参数组合如何实现调度节奏的控制;\n从上一节关于 Scheduler 类的描述中可以看到, 上层调度中最关键的逻辑, 判断每一个注册的 job 是否应该被调度, 其实是 Job 类的一个回调方法 `should_run`:\n``` python\ndef should_run(self):\n    return datetime.datetime.now() >= self.next_run\n```\n而 should_run 方法中的判断的依据, 是当前时间有没有到达 `next_run` 这个实例字段给出的时间点;\nnext_run 字段的设置则通过在 `Job.do(self, job_func, *args, **kwargs)` 方法 (上文已给出) 和 `Job.run(self)` 方法中调用 `__schedule_next_run()` 方法来实现:\n``` python\ndef run(self):\n    logger.info('Running job %s', self)\n    ret = self.job_func()\n    self.last_run = datetime.datetime.now()\n    # 计算下一次调度的时间\n    self._schedule_next_run()\n    return ret\n```\n所以, 所有的秘密就存在于 `_schedule_next_run()` 方法里了; 下面将结合几大类参数组合的设置, 拆开来分析 _schedule_next_run() 方法的逻辑;\n这些 Job 类的参数组合, 大致可分为这几类:\n#### **总基调: 指定调度的周期**\n以下方法将会设置 unit 参数, 与 interval 参数结合, 定义调度区间间隔:\n``` python\ndef second(self):   def seconds(self):  # self.unit = 'seconds'\ndef minute(self):   def minutes(self):  # self.unit = 'minutes'\ndef hour(self):     def hours(self):    # self.unit = 'hours'\ndef day(self):      def days(self):     # self.unit = 'days'\ndef week(self):     def weeks(self):    # self.unit = 'weeks'\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')\n    if self.latest is not None:\n        assert self.latest >= self.interval\n        interval = random.randint(self.interval, self.latest)\n    else:\n        interval = self.interval\n\n    self.period = datetime.timedelta(**{self.unit: interval})\n    self.next_run = datetime.datetime.now() + self.period\n```\n先不管其中涉及到的 latest 字段 (下文描述), 其他的逻辑清晰可见: 使用 unit 和 interval 构造出一个指定的 timedelta, 加上当前时间得到下次调度的时间;\n&nbsp;\n这是最简单的一类, 定下了整个调度的总体节奏; 而下面几个类别的参数并不能单独决定调度周期, 而是在第一类参数的基础之上实施局部调整, 以达到综合控制;\n#### **局部调整1: 指定调度的起始 weekday**\n以下方法将会设置 start_day 参数, 确定调度开始的时间点; 同时统一设置 unit 参数为 'weeks':\n``` python\ndef monday(self):       \n    self.start_day = 'monday'\n    self.unit = 'weeks'\ndef tuesday(self):      \n    self.start_day = 'tuesday'\n    self.unit = 'weeks'\ndef wednesday(self):    \n    self.start_day = 'wednesday'\n    self.unit = 'weeks'\ndef thursday(self):   \n    self.start_day = 'thurday'\n    self.unit = 'weeks'\ndef friday(self):       \n    self.start_day = 'friday'\n    self.unit = 'weeks'\ndef saturday(self):     \n    self.start_day = 'saturday'\n    self.unit = 'weeks'\ndef sunday(self):     \n    self.start_day = 'sunday'\n    self.unit = 'weeks'\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    if self.start_day is not None:\n        assert self.unit == 'weeks'\n        weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')\n        assert self.start_day in weekdays\n        weekday = weekdays.index(self.start_day)\n        days_ahead = weekday - self.next_run.weekday()\n        if days_ahead <= 0:  # Target day already happened this week\n            days_ahead += 7\n        self.next_run += datetime.timedelta(days_ahead) - self.period\n```\n可以发现, start_day 只是在 next_run 原有的 weekday 基础上增加了一个 offset, 相当于是 delay time;\n#### **局部调整2: 指定调度的起始时间**\n以下方法将会设置 at_time 参数, 其针对 unit == 'hours' 只设置 minute 变量, 而对 unit == 'days' 或 'weeks' 才会设置 hour 变量;\n``` python\ndef at(self, time_str):\n    assert self.unit in ('days', 'hours') or self.start_day\n    hour, minute = time_str.split(':')\n    minute = int(minute)\n    if self.unit == 'days' or self.start_day:\n        hour = int(hour)\n        assert 0 <= hour <= 23\n    elif self.unit == 'hours':\n        hour = 0\n    assert 0 <= minute <= 59\n    self.at_time = datetime.time(hour, minute)\n    return self\n```\n其对应的 _schedule_next_run() 逻辑也与上面类似, 针对 unit == 'days' 或 'weeks' 才设 hour 字段, 否则只设置 minute 和 second;\n``` python\n# def _schedule_next_run(self)\n    if self.at_time is not None:\n        assert self.unit in ('days', 'hours') or self.start_day is not None\n        kwargs = {\n            'minute': self.at_time.minute,\n            'second': self.at_time.second,\n            'microsecond': 0\n        }\n        if self.unit == 'days' or self.start_day is not None:\n            kwargs['hour'] = self.at_time.hour\n        self.next_run = self.next_run.replace(**kwargs)\n```\n#### **局部调整3: 在给定范围内随机安排调度时刻**\n对应的就是上文提及的 latest 参数:\n``` python\ndef to(self, latest):\n    self.latest = latest\n    return self\n```\n其对应的 _schedule_next_run() 逻辑如下:\n``` python\n# def _schedule_next_run(self)\n    if self.latest is not None:\n        assert self.latest >= self.interval\n        interval = random.randint(self.interval, self.latest)\n    else:\n        interval = self.interval\n```\n具体逻辑就是在给定的 [interval, latest) 区间内, 生成一个随机数作为下次调度的 interval;\n&nbsp;\n至此, Job 类的逻辑就都分析完了;\n\n## **apscheduler**\n\n\n## **celery**\n\n\n## **站内相关文章**\n- [python module 使用总结: heapq]()\n\n## **参考链接**\n- [8.8. sched — Event scheduler](https://docs.python.org/2/library/sched.html)\n- [python sched模块学习](http://blog.csdn.net/leonard_wang/article/details/54017537)\n- [python中的轻量级定时任务调度库: schedule](https://www.cnblogs.com/anpengapple/p/8051923.html)\n\n","slug":"python-module--python_module_使用总结_定时调度器","published":1,"updated":"2018-03-24T07:08:34.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd630014j1jx45zcdhpz","content":"<blockquote>\n<p>在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;<br>我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:</p>\n<ol>\n<li>简单的实现: sched 与 schedule;</li>\n<li>功能增强版: apscheduler;</li>\n<li>分布式调度器: celery;</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"sched\"><a href=\"#sched\" class=\"headerlink\" title=\"sched\"></a><strong>sched</strong></h2><p>sched 是 python 官方提供的定时调度模块, 其实现非常的简单, sched.py 的代码量只有一百多行, 且只有一个类: scheduler;<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sched.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">scheduler</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        @param timefunc     能够返回时间戳的计时函数, 要求该函数是一个无参函数</span></span><br><span class=\"line\"><span class=\"string\">        @param delayfunc    能够阻塞给定时间的阻塞函数, 要求该函数能接收一个数值类型的参数</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    def __init__(self, timefunc, delayfunc);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        @param delay        需要延迟的时间</span></span><br><span class=\"line\"><span class=\"string\">        @param priority     当多个任务需要在同一个时间调度时的优先级</span></span><br><span class=\"line\"><span class=\"string\">        @param action       需要调度的函数</span></span><br><span class=\"line\"><span class=\"string\">        @param argument     需要调度函数的参数列表</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    def enter(self, delay, priority, action, argument);</span><br></pre></td></tr></table></figure></p>\n<p>如上所示, scheduler 是使用构造器传进来的计时函数与阻塞函数去实现调度逻辑的;</p>\n<h3 id=\"sched-的局限性与解决方案\"><a href=\"#sched-的局限性与解决方案\" class=\"headerlink\" title=\"sched 的局限性与解决方案\"></a><strong>sched 的局限性与解决方案</strong></h3><p>不过说真的, 把 sched 定义为定时调度模块真的很牵强:<br>常规意义上, 我们所理解的定时调度器, 应该是能够像 cron 那样, 按给定的时间间隔或在指定的时间点上循环执行指定的任务; 但是 sched 并不能做到这一点, sched 所做的, 只是从某一个时间点开始, delay 一段我们给定的延时时间, 然后执行给定方法, 仅执行这一次;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> sched <span class=\"keyword\">import</span> scheduler</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\"></span><br><span class=\"line\">s = scheduler(time.time, time.sleep)</span><br><span class=\"line\"><span class=\"comment\"># delay 5 秒后执行 do_task 函数, 仅执行一次</span></span><br><span class=\"line\">s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">s.run()</span><br></pre></td></tr></table></figure></p>\n<p>要想 sched 做到循环执行, 还需要在其基础上包装上一层类似’递归’的概念:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = scheduler(time.time, time.sleep)</span><br><span class=\"line\"><span class=\"comment\"># 在任务函数中将自己再次用 sched 调度以实现循环</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str)</span>:</span></span><br><span class=\"line\">    s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\">    </span><br><span class=\"line\">s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">s.run()</span><br></pre></td></tr></table></figure></p>\n<p>当然, 这只是将函数自己的引用传给了 scheduler, 神似递归但并非递归, 所以也就不存在找不到递归出口而爆栈的问题了;<br>很明显, 采用这种方式才能实现真正的定时调度, 可谓非常麻烦而蹩脚;</p>\n<h3 id=\"sched-的调度原理\"><a href=\"#sched-的调度原理\" class=\"headerlink\" title=\"sched 的调度原理\"></a><strong>sched 的调度原理</strong></h3><p>sched 使用 <code>heapq</code> 优先队列来管理需要调度的任务(关于 heapq 的详细内容请参考: <a href=\"\">python module 使用总结: heapq</a>); 在调用了 scheduler 类的 enter 方法后, 其实是生成了一个任务的快照, 并放入了优先队列里:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event = Event(time, priority, action, argument)</span><br><span class=\"line\">heapq.heappush(self._queue, event)</span><br></pre></td></tr></table></figure></p>\n<p>在调用 scheduler.run() 方法后, sched 在一个死循环里, 不断得从优先队列里取出任务执行, 计算最近的下一个任务的等待时间并阻塞:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = self._queue</span><br><span class=\"line\"> <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">    time, priority, action, argument = checked_event = q[<span class=\"number\">0</span>]</span><br><span class=\"line\">    now = timefunc()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> now &lt; time:</span><br><span class=\"line\">        delayfunc(time - now)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        event = pop(q)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> event <span class=\"keyword\">is</span> checked_event:</span><br><span class=\"line\">            action(*argument)</span><br><span class=\"line\">            delayfunc(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            heapq.heappush(q, event)</span><br></pre></td></tr></table></figure></p>\n<p>总体来说, sched 的设计还是比较紧凑清晰的, 轻量化; 但是由于其固有的缺陷, 在复杂的场景中, 往往不能胜任, 我们需要功能更强大的调度框架;</p>\n<h2 id=\"schedule\"><a href=\"#schedule\" class=\"headerlink\" title=\"schedule\"></a><strong>schedule</strong></h2><p>schedule 是一个广泛使用的 python 定时调度框架, 其 github 地址如下: <a href=\"https://github.com/dbader/schedule\" target=\"_blank\" rel=\"noopener\">https://github.com/dbader/schedule</a>, 目前 4k 多个 stars;<br>和 python 官方的 sched 相比, schedule 的 API 要人性化得多, 而且它基本实现了真正意义上的定时调度:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> schedule</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str=time.time<span class=\"params\">()</span>)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每 10 分钟执行一次任务</span></span><br><span class=\"line\">schedule.every(<span class=\"number\">10</span>).minutes.do(do_task)</span><br><span class=\"line\"><span class=\"comment\"># 每隔 5 到 10 分钟之间的任意一个时间执行一次任务</span></span><br><span class=\"line\">schedule.every(<span class=\"number\">5</span>).to(<span class=\"number\">10</span>).days.do(do_task)</span><br><span class=\"line\"><span class=\"comment\"># 每 1 小时执行一次任务</span></span><br><span class=\"line\">schedule.every().hour.do(do_task, time_str=<span class=\"string\">'1519351479.19554'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 每天 10:30 执行一次任务</span></span><br><span class=\"line\">schedule.every().day.at(<span class=\"string\">\"10:30\"</span>).do(do_task)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    schedule.run_pending()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"schedule-模块的-Scheduler-类\"><a href=\"#schedule-模块的-Scheduler-类\" class=\"headerlink\" title=\"schedule 模块的 Scheduler 类\"></a><strong>schedule 模块的 Scheduler 类</strong></h3><p>其实, schedule 模块的整体设计, 是把任务的自我管理部分做的很详细, 而把上层的调度做的很轻很薄, 关键逻辑点采用回调的方式, 依赖任务的自我管理去实现;<br>而上一节所讲的 sched 模块, 则是在上层调度部分使用了复杂的逻辑 (优先队列) 去统一管理, 而任务本身携带的信息很少; sched 与 schedule 两个模块, 在整体设计上, 形成了鲜明的对比;<br>Scheduler 类的实例中, 维护了一个列表: jobs, 专门存储注册进来的任务快照;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Scheduler(object):</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.jobs = []</span><br></pre></td></tr></table></figure></p>\n<p>Scheduler 类最重要的方法是 <code>run_pending(self)</code>, 其主要逻辑是遍历 jobs 列表中的所有 job, 从中找出当前时间点需要调度的 job, 并执行;<br>这其中最重要的逻辑是判断一个 job 当前时间点是否需要被调度, 而这个过程是一个回调, 具体的逻辑则封装在 job.should_run 方法里, 下一小节将会详细介绍;<br>可以发现, 总共只用了三行代码, 以此可见其轻量化;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_pending</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    _jobs = (job <span class=\"keyword\">for</span> job <span class=\"keyword\">in</span> self.jobs <span class=\"keyword\">if</span> job.should_run)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> job <span class=\"keyword\">in</span> sorted(runnable_jobs):</span><br><span class=\"line\">        self._run_job(job)</span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是, schedule 模块中并没有专门的逻辑去定时执行 run_pending 方法, 要想让定时调度持续跑起来, 需要自己实现:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    schedule.run_pending()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>相比 sched 模块的 ‘伪递归’ 而言, 这样的设计算是比较人性化的了, 可以认为它基本实现了真正意义上的定时调度;</p>\n<h3 id=\"schedule-模块的-Job-类\"><a href=\"#schedule-模块的-Job-类\" class=\"headerlink\" title=\"schedule 模块的 Job 类\"></a><strong>schedule 模块的 Job 类</strong></h3><p>正如上一节所述, schedule 模块实现了非常详细的任务自我管理逻辑; 相比 sched 的 <code>Event</code> 类, schedule 定义了一个控制参数更丰富的 <code>Job</code> 类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, interval, scheduler=None)</span>:</span></span><br><span class=\"line\">        self.interval = interval  <span class=\"comment\"># pause interval * unit between runs</span></span><br><span class=\"line\">        self.latest = <span class=\"keyword\">None</span>  <span class=\"comment\"># upper limit to the interval</span></span><br><span class=\"line\">        self.job_func = <span class=\"keyword\">None</span>  <span class=\"comment\"># the job job_func to run</span></span><br><span class=\"line\">        self.unit = <span class=\"keyword\">None</span>  <span class=\"comment\"># time units, e.g. 'minutes', 'hours', ...</span></span><br><span class=\"line\">        self.at_time = <span class=\"keyword\">None</span>  <span class=\"comment\"># optional time at which this job runs</span></span><br><span class=\"line\">        self.last_run = <span class=\"keyword\">None</span>  <span class=\"comment\"># datetime of the last run</span></span><br><span class=\"line\">        self.next_run = <span class=\"keyword\">None</span>  <span class=\"comment\"># datetime of the next run</span></span><br><span class=\"line\">        self.period = <span class=\"keyword\">None</span>  <span class=\"comment\"># timedelta between runs, only valid for</span></span><br><span class=\"line\">        self.start_day = <span class=\"keyword\">None</span>  <span class=\"comment\"># Specific day of the week to start on</span></span><br><span class=\"line\">        self.tags = set()  <span class=\"comment\"># unique set of tags for the job</span></span><br><span class=\"line\">        self.scheduler = scheduler  <span class=\"comment\"># scheduler to register with</span></span><br></pre></td></tr></table></figure></p>\n<p>Job 类的参数众多, 单个任务的调度肯定不可能涉及到所有的参数, 这些参数往往是以局部几个为组合, 控制调度节奏的; 但是无论什么组合, 往往都会以 <code>scheduler.every(interval=1)</code> 方法开始, 以 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法结束:<br>(1) schedule.every 方法构造出一个 <code>Job</code> 实例, 并设置该实例的第一个参数 interval;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default_scheduler = Scheduler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">every</span><span class=\"params\">(interval=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> default_scheduler.every(interval)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scheduler</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">every</span><span class=\"params\">(self, interval=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">        job = Job(interval, self)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> job</span><br></pre></td></tr></table></figure></p>\n<p>这里想吐槽的是, 这个方法出现在 Scheduler 类中有点突兀, 而且方法名叫 every, 只体现了设置 interval 参数的含义, 但并不能从中看出其新构造一个 Job 实例的意图;<br>(2) Job.do 方法包装了传递进来的任务函数, 将其设置为自己的 job_func 参数, 并将自己作为一个任务快照放进 scheduler 的任务列表里;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Job(object):</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do</span><span class=\"params\">(self, job_func, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        self.job_func = functools.partial(job_func, *args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            functools.update_wrapper(self.job_func, job_func)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> AttributeError:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"comment\"># 计算下一次调度的时间</span></span><br><span class=\"line\">        self._schedule_next_run()</span><br><span class=\"line\">        self.scheduler.jobs.append(self)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>在这两个方法之间, 就是通过建造者模式, 构造出其他控制参数的组合, 以实现各种各样的调度节奏;<br>下面来重点讲一下各参数组合如何实现调度节奏的控制;<br>从上一节关于 Scheduler 类的描述中可以看到, 上层调度中最关键的逻辑, 判断每一个注册的 job 是否应该被调度, 其实是 Job 类的一个回调方法 <code>should_run</code>:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">should_run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> datetime.datetime.now() &gt;= self.next_run</span><br></pre></td></tr></table></figure></p>\n<p>而 should_run 方法中的判断的依据, 是当前时间有没有到达 <code>next_run</code> 这个实例字段给出的时间点;<br>next_run 字段的设置则通过在 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法 (上文已给出) 和 <code>Job.run(self)</code> 方法中调用 <code>__schedule_next_run()</code> 方法来实现:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    logger.info(<span class=\"string\">'Running job %s'</span>, self)</span><br><span class=\"line\">    ret = self.job_func()</span><br><span class=\"line\">    self.last_run = datetime.datetime.now()</span><br><span class=\"line\">    <span class=\"comment\"># 计算下一次调度的时间</span></span><br><span class=\"line\">    self._schedule_next_run()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure></p>\n<p>所以, 所有的秘密就存在于 <code>_schedule_next_run()</code> 方法里了; 下面将结合几大类参数组合的设置, 拆开来分析 _schedule_next_run() 方法的逻辑;<br>这些 Job 类的参数组合, 大致可分为这几类:</p>\n<h4 id=\"总基调-指定调度的周期\"><a href=\"#总基调-指定调度的周期\" class=\"headerlink\" title=\"总基调: 指定调度的周期\"></a><strong>总基调: 指定调度的周期</strong></h4><p>以下方法将会设置 unit 参数, 与 interval 参数结合, 定义调度区间间隔:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self)</span>:</span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">seconds</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># self.unit = 'seconds'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minute</span><span class=\"params\">(self)</span>:</span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minutes</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># self.unit = 'minutes'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hour</span><span class=\"params\">(self)</span>:</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hours</span><span class=\"params\">(self)</span>:</span>    <span class=\"comment\"># self.unit = 'hours'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">day</span><span class=\"params\">(self)</span>:</span>      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">days</span><span class=\"params\">(self)</span>:</span>     <span class=\"comment\"># self.unit = 'days'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">week</span><span class=\"params\">(self)</span>:</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">weeks</span><span class=\"params\">(self)</span>:</span>    <span class=\"comment\"># self.unit = 'weeks'</span></span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'seconds'</span>, <span class=\"string\">'minutes'</span>, <span class=\"string\">'hours'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'weeks'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.latest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.latest &gt;= self.interval</span><br><span class=\"line\">        interval = random.randint(self.interval, self.latest)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        interval = self.interval</span><br><span class=\"line\"></span><br><span class=\"line\">    self.period = datetime.timedelta(**&#123;self.unit: interval&#125;)</span><br><span class=\"line\">    self.next_run = datetime.datetime.now() + self.period</span><br></pre></td></tr></table></figure></p>\n<p>先不管其中涉及到的 latest 字段 (下文描述), 其他的逻辑清晰可见: 使用 unit 和 interval 构造出一个指定的 timedelta, 加上当前时间得到下次调度的时间;<br>&nbsp;<br>这是最简单的一类, 定下了整个调度的总体节奏; 而下面几个类别的参数并不能单独决定调度周期, 而是在第一类参数的基础之上实施局部调整, 以达到综合控制;</p>\n<h4 id=\"局部调整1-指定调度的起始-weekday\"><a href=\"#局部调整1-指定调度的起始-weekday\" class=\"headerlink\" title=\"局部调整1: 指定调度的起始 weekday\"></a><strong>局部调整1: 指定调度的起始 weekday</strong></h4><p>以下方法将会设置 start_day 参数, 确定调度开始的时间点; 同时统一设置 unit 参数为 ‘weeks’:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">monday</span><span class=\"params\">(self)</span>:</span>       </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'monday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tuesday</span><span class=\"params\">(self)</span>:</span>      </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'tuesday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wednesday</span><span class=\"params\">(self)</span>:</span>    </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'wednesday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">thursday</span><span class=\"params\">(self)</span>:</span>   </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'thurday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">friday</span><span class=\"params\">(self)</span>:</span>       </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'friday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saturday</span><span class=\"params\">(self)</span>:</span>     </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'saturday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sunday</span><span class=\"params\">(self)</span>:</span>     </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'sunday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.unit == <span class=\"string\">'weeks'</span></span><br><span class=\"line\">        weekdays = (<span class=\"string\">'monday'</span>, <span class=\"string\">'tuesday'</span>, <span class=\"string\">'wednesday'</span>, <span class=\"string\">'thursday'</span>, <span class=\"string\">'friday'</span>, <span class=\"string\">'saturday'</span>, <span class=\"string\">'sunday'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.start_day <span class=\"keyword\">in</span> weekdays</span><br><span class=\"line\">        weekday = weekdays.index(self.start_day)</span><br><span class=\"line\">        days_ahead = weekday - self.next_run.weekday()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> days_ahead &lt;= <span class=\"number\">0</span>:  <span class=\"comment\"># Target day already happened this week</span></span><br><span class=\"line\">            days_ahead += <span class=\"number\">7</span></span><br><span class=\"line\">        self.next_run += datetime.timedelta(days_ahead) - self.period</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, start_day 只是在 next_run 原有的 weekday 基础上增加了一个 offset, 相当于是 delay time;</p>\n<h4 id=\"局部调整2-指定调度的起始时间\"><a href=\"#局部调整2-指定调度的起始时间\" class=\"headerlink\" title=\"局部调整2: 指定调度的起始时间\"></a><strong>局部调整2: 指定调度的起始时间</strong></h4><p>以下方法将会设置 at_time 参数, 其针对 unit == ‘hours’ 只设置 minute 变量, 而对 unit == ‘days’ 或 ‘weeks’ 才会设置 hour 变量;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">at</span><span class=\"params\">(self, time_str)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'days'</span>, <span class=\"string\">'hours'</span>) <span class=\"keyword\">or</span> self.start_day</span><br><span class=\"line\">    hour, minute = time_str.split(<span class=\"string\">':'</span>)</span><br><span class=\"line\">    minute = int(minute)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.unit == <span class=\"string\">'days'</span> <span class=\"keyword\">or</span> self.start_day:</span><br><span class=\"line\">        hour = int(hour)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"number\">0</span> &lt;= hour &lt;= <span class=\"number\">23</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> self.unit == <span class=\"string\">'hours'</span>:</span><br><span class=\"line\">        hour = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"number\">0</span> &lt;= minute &lt;= <span class=\"number\">59</span></span><br><span class=\"line\">    self.at_time = datetime.time(hour, minute)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑也与上面类似, 针对 unit == ‘days’ 或 ‘weeks’ 才设 hour 字段, 否则只设置 minute 和 second;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.at_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'days'</span>, <span class=\"string\">'hours'</span>) <span class=\"keyword\">or</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        kwargs = &#123;</span><br><span class=\"line\">            <span class=\"string\">'minute'</span>: self.at_time.minute,</span><br><span class=\"line\">            <span class=\"string\">'second'</span>: self.at_time.second,</span><br><span class=\"line\">            <span class=\"string\">'microsecond'</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.unit == <span class=\"string\">'days'</span> <span class=\"keyword\">or</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            kwargs[<span class=\"string\">'hour'</span>] = self.at_time.hour</span><br><span class=\"line\">        self.next_run = self.next_run.replace(**kwargs)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"局部调整3-在给定范围内随机安排调度时刻\"><a href=\"#局部调整3-在给定范围内随机安排调度时刻\" class=\"headerlink\" title=\"局部调整3: 在给定范围内随机安排调度时刻\"></a><strong>局部调整3: 在给定范围内随机安排调度时刻</strong></h4><p>对应的就是上文提及的 latest 参数:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to</span><span class=\"params\">(self, latest)</span>:</span></span><br><span class=\"line\">    self.latest = latest</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.latest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.latest &gt;= self.interval</span><br><span class=\"line\">        interval = random.randint(self.interval, self.latest)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        interval = self.interval</span><br></pre></td></tr></table></figure></p>\n<p>具体逻辑就是在给定的 [interval, latest) 区间内, 生成一个随机数作为下次调度的 interval;<br>&nbsp;<br>至此, Job 类的逻辑就都分析完了;</p>\n<h2 id=\"apscheduler\"><a href=\"#apscheduler\" class=\"headerlink\" title=\"apscheduler\"></a><strong>apscheduler</strong></h2><h2 id=\"celery\"><a href=\"#celery\" class=\"headerlink\" title=\"celery\"></a><strong>celery</strong></h2><h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">python module 使用总结: heapq</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://docs.python.org/2/library/sched.html\" target=\"_blank\" rel=\"noopener\">8.8. sched — Event scheduler</a></li>\n<li><a href=\"http://blog.csdn.net/leonard_wang/article/details/54017537\" target=\"_blank\" rel=\"noopener\">python sched模块学习</a></li>\n<li><a href=\"https://www.cnblogs.com/anpengapple/p/8051923.html\" target=\"_blank\" rel=\"noopener\">python中的轻量级定时任务调度库: schedule</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;<br>我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:</p>\n<ol>\n<li>简单的实现: sched 与 schedule;</li>\n<li>功能增强版: apscheduler;</li>\n<li>分布式调度器: celery;</li>\n</ol>\n</blockquote>","more":"<hr>\n<h2 id=\"sched\"><a href=\"#sched\" class=\"headerlink\" title=\"sched\"></a><strong>sched</strong></h2><p>sched 是 python 官方提供的定时调度模块, 其实现非常的简单, sched.py 的代码量只有一百多行, 且只有一个类: scheduler;<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sched.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">scheduler</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        @param timefunc     能够返回时间戳的计时函数, 要求该函数是一个无参函数</span></span><br><span class=\"line\"><span class=\"string\">        @param delayfunc    能够阻塞给定时间的阻塞函数, 要求该函数能接收一个数值类型的参数</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    def __init__(self, timefunc, delayfunc);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        @param delay        需要延迟的时间</span></span><br><span class=\"line\"><span class=\"string\">        @param priority     当多个任务需要在同一个时间调度时的优先级</span></span><br><span class=\"line\"><span class=\"string\">        @param action       需要调度的函数</span></span><br><span class=\"line\"><span class=\"string\">        @param argument     需要调度函数的参数列表</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    def enter(self, delay, priority, action, argument);</span><br></pre></td></tr></table></figure></p>\n<p>如上所示, scheduler 是使用构造器传进来的计时函数与阻塞函数去实现调度逻辑的;</p>\n<h3 id=\"sched-的局限性与解决方案\"><a href=\"#sched-的局限性与解决方案\" class=\"headerlink\" title=\"sched 的局限性与解决方案\"></a><strong>sched 的局限性与解决方案</strong></h3><p>不过说真的, 把 sched 定义为定时调度模块真的很牵强:<br>常规意义上, 我们所理解的定时调度器, 应该是能够像 cron 那样, 按给定的时间间隔或在指定的时间点上循环执行指定的任务; 但是 sched 并不能做到这一点, sched 所做的, 只是从某一个时间点开始, delay 一段我们给定的延时时间, 然后执行给定方法, 仅执行这一次;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> sched <span class=\"keyword\">import</span> scheduler</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\"></span><br><span class=\"line\">s = scheduler(time.time, time.sleep)</span><br><span class=\"line\"><span class=\"comment\"># delay 5 秒后执行 do_task 函数, 仅执行一次</span></span><br><span class=\"line\">s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">s.run()</span><br></pre></td></tr></table></figure></p>\n<p>要想 sched 做到循环执行, 还需要在其基础上包装上一层类似’递归’的概念:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = scheduler(time.time, time.sleep)</span><br><span class=\"line\"><span class=\"comment\"># 在任务函数中将自己再次用 sched 调度以实现循环</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str)</span>:</span></span><br><span class=\"line\">    s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\">    </span><br><span class=\"line\">s.enter(<span class=\"number\">5</span>, <span class=\"number\">0</span>, do_task, (time.time(),))</span><br><span class=\"line\">s.run()</span><br></pre></td></tr></table></figure></p>\n<p>当然, 这只是将函数自己的引用传给了 scheduler, 神似递归但并非递归, 所以也就不存在找不到递归出口而爆栈的问题了;<br>很明显, 采用这种方式才能实现真正的定时调度, 可谓非常麻烦而蹩脚;</p>\n<h3 id=\"sched-的调度原理\"><a href=\"#sched-的调度原理\" class=\"headerlink\" title=\"sched 的调度原理\"></a><strong>sched 的调度原理</strong></h3><p>sched 使用 <code>heapq</code> 优先队列来管理需要调度的任务(关于 heapq 的详细内容请参考: <a href=\"\">python module 使用总结: heapq</a>); 在调用了 scheduler 类的 enter 方法后, 其实是生成了一个任务的快照, 并放入了优先队列里:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event = Event(time, priority, action, argument)</span><br><span class=\"line\">heapq.heappush(self._queue, event)</span><br></pre></td></tr></table></figure></p>\n<p>在调用 scheduler.run() 方法后, sched 在一个死循环里, 不断得从优先队列里取出任务执行, 计算最近的下一个任务的等待时间并阻塞:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = self._queue</span><br><span class=\"line\"> <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">    time, priority, action, argument = checked_event = q[<span class=\"number\">0</span>]</span><br><span class=\"line\">    now = timefunc()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> now &lt; time:</span><br><span class=\"line\">        delayfunc(time - now)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        event = pop(q)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> event <span class=\"keyword\">is</span> checked_event:</span><br><span class=\"line\">            action(*argument)</span><br><span class=\"line\">            delayfunc(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            heapq.heappush(q, event)</span><br></pre></td></tr></table></figure></p>\n<p>总体来说, sched 的设计还是比较紧凑清晰的, 轻量化; 但是由于其固有的缺陷, 在复杂的场景中, 往往不能胜任, 我们需要功能更强大的调度框架;</p>\n<h2 id=\"schedule\"><a href=\"#schedule\" class=\"headerlink\" title=\"schedule\"></a><strong>schedule</strong></h2><p>schedule 是一个广泛使用的 python 定时调度框架, 其 github 地址如下: <a href=\"https://github.com/dbader/schedule\" target=\"_blank\" rel=\"noopener\">https://github.com/dbader/schedule</a>, 目前 4k 多个 stars;<br>和 python 官方的 sched 相比, schedule 的 API 要人性化得多, 而且它基本实现了真正意义上的定时调度:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> schedule</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task</span><span class=\"params\">(time_str=time.time<span class=\"params\">()</span>)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'task run: %s'</span> % time_str)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每 10 分钟执行一次任务</span></span><br><span class=\"line\">schedule.every(<span class=\"number\">10</span>).minutes.do(do_task)</span><br><span class=\"line\"><span class=\"comment\"># 每隔 5 到 10 分钟之间的任意一个时间执行一次任务</span></span><br><span class=\"line\">schedule.every(<span class=\"number\">5</span>).to(<span class=\"number\">10</span>).days.do(do_task)</span><br><span class=\"line\"><span class=\"comment\"># 每 1 小时执行一次任务</span></span><br><span class=\"line\">schedule.every().hour.do(do_task, time_str=<span class=\"string\">'1519351479.19554'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 每天 10:30 执行一次任务</span></span><br><span class=\"line\">schedule.every().day.at(<span class=\"string\">\"10:30\"</span>).do(do_task)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    schedule.run_pending()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"schedule-模块的-Scheduler-类\"><a href=\"#schedule-模块的-Scheduler-类\" class=\"headerlink\" title=\"schedule 模块的 Scheduler 类\"></a><strong>schedule 模块的 Scheduler 类</strong></h3><p>其实, schedule 模块的整体设计, 是把任务的自我管理部分做的很详细, 而把上层的调度做的很轻很薄, 关键逻辑点采用回调的方式, 依赖任务的自我管理去实现;<br>而上一节所讲的 sched 模块, 则是在上层调度部分使用了复杂的逻辑 (优先队列) 去统一管理, 而任务本身携带的信息很少; sched 与 schedule 两个模块, 在整体设计上, 形成了鲜明的对比;<br>Scheduler 类的实例中, 维护了一个列表: jobs, 专门存储注册进来的任务快照;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Scheduler(object):</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.jobs = []</span><br></pre></td></tr></table></figure></p>\n<p>Scheduler 类最重要的方法是 <code>run_pending(self)</code>, 其主要逻辑是遍历 jobs 列表中的所有 job, 从中找出当前时间点需要调度的 job, 并执行;<br>这其中最重要的逻辑是判断一个 job 当前时间点是否需要被调度, 而这个过程是一个回调, 具体的逻辑则封装在 job.should_run 方法里, 下一小节将会详细介绍;<br>可以发现, 总共只用了三行代码, 以此可见其轻量化;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_pending</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    _jobs = (job <span class=\"keyword\">for</span> job <span class=\"keyword\">in</span> self.jobs <span class=\"keyword\">if</span> job.should_run)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> job <span class=\"keyword\">in</span> sorted(runnable_jobs):</span><br><span class=\"line\">        self._run_job(job)</span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是, schedule 模块中并没有专门的逻辑去定时执行 run_pending 方法, 要想让定时调度持续跑起来, 需要自己实现:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    schedule.run_pending()</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>相比 sched 模块的 ‘伪递归’ 而言, 这样的设计算是比较人性化的了, 可以认为它基本实现了真正意义上的定时调度;</p>\n<h3 id=\"schedule-模块的-Job-类\"><a href=\"#schedule-模块的-Job-类\" class=\"headerlink\" title=\"schedule 模块的 Job 类\"></a><strong>schedule 模块的 Job 类</strong></h3><p>正如上一节所述, schedule 模块实现了非常详细的任务自我管理逻辑; 相比 sched 的 <code>Event</code> 类, schedule 定义了一个控制参数更丰富的 <code>Job</code> 类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, interval, scheduler=None)</span>:</span></span><br><span class=\"line\">        self.interval = interval  <span class=\"comment\"># pause interval * unit between runs</span></span><br><span class=\"line\">        self.latest = <span class=\"keyword\">None</span>  <span class=\"comment\"># upper limit to the interval</span></span><br><span class=\"line\">        self.job_func = <span class=\"keyword\">None</span>  <span class=\"comment\"># the job job_func to run</span></span><br><span class=\"line\">        self.unit = <span class=\"keyword\">None</span>  <span class=\"comment\"># time units, e.g. 'minutes', 'hours', ...</span></span><br><span class=\"line\">        self.at_time = <span class=\"keyword\">None</span>  <span class=\"comment\"># optional time at which this job runs</span></span><br><span class=\"line\">        self.last_run = <span class=\"keyword\">None</span>  <span class=\"comment\"># datetime of the last run</span></span><br><span class=\"line\">        self.next_run = <span class=\"keyword\">None</span>  <span class=\"comment\"># datetime of the next run</span></span><br><span class=\"line\">        self.period = <span class=\"keyword\">None</span>  <span class=\"comment\"># timedelta between runs, only valid for</span></span><br><span class=\"line\">        self.start_day = <span class=\"keyword\">None</span>  <span class=\"comment\"># Specific day of the week to start on</span></span><br><span class=\"line\">        self.tags = set()  <span class=\"comment\"># unique set of tags for the job</span></span><br><span class=\"line\">        self.scheduler = scheduler  <span class=\"comment\"># scheduler to register with</span></span><br></pre></td></tr></table></figure></p>\n<p>Job 类的参数众多, 单个任务的调度肯定不可能涉及到所有的参数, 这些参数往往是以局部几个为组合, 控制调度节奏的; 但是无论什么组合, 往往都会以 <code>scheduler.every(interval=1)</code> 方法开始, 以 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法结束:<br>(1) schedule.every 方法构造出一个 <code>Job</code> 实例, 并设置该实例的第一个参数 interval;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default_scheduler = Scheduler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">every</span><span class=\"params\">(interval=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> default_scheduler.every(interval)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scheduler</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">every</span><span class=\"params\">(self, interval=<span class=\"number\">1</span>)</span>:</span></span><br><span class=\"line\">        job = Job(interval, self)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> job</span><br></pre></td></tr></table></figure></p>\n<p>这里想吐槽的是, 这个方法出现在 Scheduler 类中有点突兀, 而且方法名叫 every, 只体现了设置 interval 参数的含义, 但并不能从中看出其新构造一个 Job 实例的意图;<br>(2) Job.do 方法包装了传递进来的任务函数, 将其设置为自己的 job_func 参数, 并将自己作为一个任务快照放进 scheduler 的任务列表里;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Job(object):</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do</span><span class=\"params\">(self, job_func, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        self.job_func = functools.partial(job_func, *args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            functools.update_wrapper(self.job_func, job_func)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> AttributeError:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"comment\"># 计算下一次调度的时间</span></span><br><span class=\"line\">        self._schedule_next_run()</span><br><span class=\"line\">        self.scheduler.jobs.append(self)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>在这两个方法之间, 就是通过建造者模式, 构造出其他控制参数的组合, 以实现各种各样的调度节奏;<br>下面来重点讲一下各参数组合如何实现调度节奏的控制;<br>从上一节关于 Scheduler 类的描述中可以看到, 上层调度中最关键的逻辑, 判断每一个注册的 job 是否应该被调度, 其实是 Job 类的一个回调方法 <code>should_run</code>:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">should_run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> datetime.datetime.now() &gt;= self.next_run</span><br></pre></td></tr></table></figure></p>\n<p>而 should_run 方法中的判断的依据, 是当前时间有没有到达 <code>next_run</code> 这个实例字段给出的时间点;<br>next_run 字段的设置则通过在 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法 (上文已给出) 和 <code>Job.run(self)</code> 方法中调用 <code>__schedule_next_run()</code> 方法来实现:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    logger.info(<span class=\"string\">'Running job %s'</span>, self)</span><br><span class=\"line\">    ret = self.job_func()</span><br><span class=\"line\">    self.last_run = datetime.datetime.now()</span><br><span class=\"line\">    <span class=\"comment\"># 计算下一次调度的时间</span></span><br><span class=\"line\">    self._schedule_next_run()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure></p>\n<p>所以, 所有的秘密就存在于 <code>_schedule_next_run()</code> 方法里了; 下面将结合几大类参数组合的设置, 拆开来分析 _schedule_next_run() 方法的逻辑;<br>这些 Job 类的参数组合, 大致可分为这几类:</p>\n<h4 id=\"总基调-指定调度的周期\"><a href=\"#总基调-指定调度的周期\" class=\"headerlink\" title=\"总基调: 指定调度的周期\"></a><strong>总基调: 指定调度的周期</strong></h4><p>以下方法将会设置 unit 参数, 与 interval 参数结合, 定义调度区间间隔:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second</span><span class=\"params\">(self)</span>:</span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">seconds</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># self.unit = 'seconds'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minute</span><span class=\"params\">(self)</span>:</span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minutes</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># self.unit = 'minutes'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hour</span><span class=\"params\">(self)</span>:</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hours</span><span class=\"params\">(self)</span>:</span>    <span class=\"comment\"># self.unit = 'hours'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">day</span><span class=\"params\">(self)</span>:</span>      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">days</span><span class=\"params\">(self)</span>:</span>     <span class=\"comment\"># self.unit = 'days'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">week</span><span class=\"params\">(self)</span>:</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">weeks</span><span class=\"params\">(self)</span>:</span>    <span class=\"comment\"># self.unit = 'weeks'</span></span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'seconds'</span>, <span class=\"string\">'minutes'</span>, <span class=\"string\">'hours'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'weeks'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.latest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.latest &gt;= self.interval</span><br><span class=\"line\">        interval = random.randint(self.interval, self.latest)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        interval = self.interval</span><br><span class=\"line\"></span><br><span class=\"line\">    self.period = datetime.timedelta(**&#123;self.unit: interval&#125;)</span><br><span class=\"line\">    self.next_run = datetime.datetime.now() + self.period</span><br></pre></td></tr></table></figure></p>\n<p>先不管其中涉及到的 latest 字段 (下文描述), 其他的逻辑清晰可见: 使用 unit 和 interval 构造出一个指定的 timedelta, 加上当前时间得到下次调度的时间;<br>&nbsp;<br>这是最简单的一类, 定下了整个调度的总体节奏; 而下面几个类别的参数并不能单独决定调度周期, 而是在第一类参数的基础之上实施局部调整, 以达到综合控制;</p>\n<h4 id=\"局部调整1-指定调度的起始-weekday\"><a href=\"#局部调整1-指定调度的起始-weekday\" class=\"headerlink\" title=\"局部调整1: 指定调度的起始 weekday\"></a><strong>局部调整1: 指定调度的起始 weekday</strong></h4><p>以下方法将会设置 start_day 参数, 确定调度开始的时间点; 同时统一设置 unit 参数为 ‘weeks’:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">monday</span><span class=\"params\">(self)</span>:</span>       </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'monday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tuesday</span><span class=\"params\">(self)</span>:</span>      </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'tuesday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wednesday</span><span class=\"params\">(self)</span>:</span>    </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'wednesday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">thursday</span><span class=\"params\">(self)</span>:</span>   </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'thurday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">friday</span><span class=\"params\">(self)</span>:</span>       </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'friday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saturday</span><span class=\"params\">(self)</span>:</span>     </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'saturday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sunday</span><span class=\"params\">(self)</span>:</span>     </span><br><span class=\"line\">    self.start_day = <span class=\"string\">'sunday'</span></span><br><span class=\"line\">    self.unit = <span class=\"string\">'weeks'</span></span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.unit == <span class=\"string\">'weeks'</span></span><br><span class=\"line\">        weekdays = (<span class=\"string\">'monday'</span>, <span class=\"string\">'tuesday'</span>, <span class=\"string\">'wednesday'</span>, <span class=\"string\">'thursday'</span>, <span class=\"string\">'friday'</span>, <span class=\"string\">'saturday'</span>, <span class=\"string\">'sunday'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.start_day <span class=\"keyword\">in</span> weekdays</span><br><span class=\"line\">        weekday = weekdays.index(self.start_day)</span><br><span class=\"line\">        days_ahead = weekday - self.next_run.weekday()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> days_ahead &lt;= <span class=\"number\">0</span>:  <span class=\"comment\"># Target day already happened this week</span></span><br><span class=\"line\">            days_ahead += <span class=\"number\">7</span></span><br><span class=\"line\">        self.next_run += datetime.timedelta(days_ahead) - self.period</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, start_day 只是在 next_run 原有的 weekday 基础上增加了一个 offset, 相当于是 delay time;</p>\n<h4 id=\"局部调整2-指定调度的起始时间\"><a href=\"#局部调整2-指定调度的起始时间\" class=\"headerlink\" title=\"局部调整2: 指定调度的起始时间\"></a><strong>局部调整2: 指定调度的起始时间</strong></h4><p>以下方法将会设置 at_time 参数, 其针对 unit == ‘hours’ 只设置 minute 变量, 而对 unit == ‘days’ 或 ‘weeks’ 才会设置 hour 变量;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">at</span><span class=\"params\">(self, time_str)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'days'</span>, <span class=\"string\">'hours'</span>) <span class=\"keyword\">or</span> self.start_day</span><br><span class=\"line\">    hour, minute = time_str.split(<span class=\"string\">':'</span>)</span><br><span class=\"line\">    minute = int(minute)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.unit == <span class=\"string\">'days'</span> <span class=\"keyword\">or</span> self.start_day:</span><br><span class=\"line\">        hour = int(hour)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"number\">0</span> &lt;= hour &lt;= <span class=\"number\">23</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> self.unit == <span class=\"string\">'hours'</span>:</span><br><span class=\"line\">        hour = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"number\">0</span> &lt;= minute &lt;= <span class=\"number\">59</span></span><br><span class=\"line\">    self.at_time = datetime.time(hour, minute)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑也与上面类似, 针对 unit == ‘days’ 或 ‘weeks’ 才设 hour 字段, 否则只设置 minute 和 second;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.at_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.unit <span class=\"keyword\">in</span> (<span class=\"string\">'days'</span>, <span class=\"string\">'hours'</span>) <span class=\"keyword\">or</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        kwargs = &#123;</span><br><span class=\"line\">            <span class=\"string\">'minute'</span>: self.at_time.minute,</span><br><span class=\"line\">            <span class=\"string\">'second'</span>: self.at_time.second,</span><br><span class=\"line\">            <span class=\"string\">'microsecond'</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.unit == <span class=\"string\">'days'</span> <span class=\"keyword\">or</span> self.start_day <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            kwargs[<span class=\"string\">'hour'</span>] = self.at_time.hour</span><br><span class=\"line\">        self.next_run = self.next_run.replace(**kwargs)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"局部调整3-在给定范围内随机安排调度时刻\"><a href=\"#局部调整3-在给定范围内随机安排调度时刻\" class=\"headerlink\" title=\"局部调整3: 在给定范围内随机安排调度时刻\"></a><strong>局部调整3: 在给定范围内随机安排调度时刻</strong></h4><p>对应的就是上文提及的 latest 参数:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to</span><span class=\"params\">(self, latest)</span>:</span></span><br><span class=\"line\">    self.latest = latest</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self</span><br></pre></td></tr></table></figure></p>\n<p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># def _schedule_next_run(self)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.latest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> self.latest &gt;= self.interval</span><br><span class=\"line\">        interval = random.randint(self.interval, self.latest)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        interval = self.interval</span><br></pre></td></tr></table></figure></p>\n<p>具体逻辑就是在给定的 [interval, latest) 区间内, 生成一个随机数作为下次调度的 interval;<br>&nbsp;<br>至此, Job 类的逻辑就都分析完了;</p>\n<h2 id=\"apscheduler\"><a href=\"#apscheduler\" class=\"headerlink\" title=\"apscheduler\"></a><strong>apscheduler</strong></h2><h2 id=\"celery\"><a href=\"#celery\" class=\"headerlink\" title=\"celery\"></a><strong>celery</strong></h2><h2 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h2><ul>\n<li><a href=\"\">python module 使用总结: heapq</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h2><ul>\n<li><a href=\"https://docs.python.org/2/library/sched.html\" target=\"_blank\" rel=\"noopener\">8.8. sched — Event scheduler</a></li>\n<li><a href=\"http://blog.csdn.net/leonard_wang/article/details/54017537\" target=\"_blank\" rel=\"noopener\">python sched模块学习</a></li>\n<li><a href=\"https://www.cnblogs.com/anpengapple/p/8051923.html\" target=\"_blank\" rel=\"noopener\">python中的轻量级定时任务调度库: schedule</a></li>\n</ul>"},{"title":"jackson 常用配置选项梳理","date":"2017-01-21T07:51:40.000Z","_content":"\n> jackson 有各种各样的配置选项 (Feature), 涵盖了包括 json 语法解析, 语句生成, 序列化 / 反序列化特征, 字段类型处理 等不同层面, 对初学者而言, 很容易造成困惑;\n本文基于 jackson 2.8.x, 着手整理常用的 jackson 配置选项, 并给出一个便捷的工具类, 以友好的方式整合 jackson 的常用配置项;\n\n<!--more-->\n\n------\n### **配置选项分类**\njackson 的配置选项丰富得可以让开发者自定义从 json 语句到 javabean 的方方面面, 总体来说有如下几类:\njson 语句的生成与解析\n``` java\n// json 语句生成的选项\nJsonGenerator.Feature\n// json 语法解析的选项\nJsonParser.Feature\n```\njavabean 的序列化与反序列化\n``` java\n// javabean 序列化选项\nSerializationFeature\n// javabean 反序列化选项\nDeserializationFeature\n```\njavabean 字段\n``` java\n// javabean 字段是否参与序列化\nJsonInclude.Include\n```\n上述各 Feature 或 Include 都是以枚举 (enum) 的形式定义的, 他们分布在 jackson 的如下包中:\n\n* JsonGenerator.Feature: jackson-core\n* JsonParser.Feature: jackson-core\n* SerializationFeature: jackson-databind\n* DeserializationFeature: jackson-databind\n* JsonInclude.Include: jackson-annotations\n\n这样的归类与它们的功能有关:\nJsonGenerator 与 JsonParser 主管 json 的生成与解析, 当属 jackson 的核心功能, 所以归于 jackson-core 包中;\nSerializationFeature 与 DeserializationFeature 主管 javabean 的序列化与反序列化, 属于数据实体绑定范畴, 所以归于 jackson-databind 包中;\nJsonInclude.Include 比较特别, 它理应主管字段是否参与序列化, 是 javabean 序列化的控制细节, 但是它的外部类 JsonInclude 本身是一个注解, 故其被归于 jackson-annotations 包中;\n&nbsp;\n下面将分别总结各类 Feature 中具体的常用选项; 有一点要说的是, 以下选项有些本身就是默认设置, 这里只是拿出来总结一下, 我们需要了解这些设置的存在; 另外, 某些设置可能只针对普遍的情况, 在特殊场景下并不适用 (比如容错性, 在某些严格的环境下就是需要 fast fail, 不需要容错);\n#### **JsonGenerator.Feature**\n其实, JsonGenerator.Feature 是一个比较底层的设置, 在源码注释中被称为 `Low-level I/O / content features`;\n关于 json 的生成的配置项, 主要是三个方面:\n(1) 统一字段的 json 规范形式, 如对引号的要求;\n``` java\n// 必须以 \"双引号\" 的形式包装字段\nobjectMapper.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n```\n(2) 加强 json 生成的容错性, 如 JsonToken (大括号与中括号) 的匹配;\n``` java\n// 允许 json 生成器自动补全未匹配的括号\nobjectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT, true);\n```\n(3) 第三个可能比较少见, 因为大部分业务场景下, 我们只是使用 `objectMapper.writeValueAsString` 方法, 得到其返回的 json 字符串以作他用; 而如果使用 `objectMapper.writeValue` 方法, 则可能涉及到写入流的问题: \n``` java\n// 允许 json 生成器在写入完成后自动关闭写入的流\nobjectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n```\n这个选项默认是开启的, 那么会导致一个问题: 当你希望在往目标输出流里输出 json 之后再输出一些其他内容便会失败, 因为 jackson 已经自动帮你关闭该输出流了; 所以有些时候, 这个选项要设置成 false;\n#### **JsonParser.Feature**\nJsonParser 的配置项, 主要是加强 json 解析的容错性, 并主要体现在三方面:\n(1) 降低字段的 json 规范形式, 如对引号的要求; 可以发现, 当自己生成 json 时, 我们要求严格规范引号的书写, 而当解析别人的 json 时, 却需要放宽规范与形式, 增强容错;\n``` java\n// 允许 json 存在没用引号括起来的 field\nobjectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// 允许 json 存在使用单引号括起来的 field\nobjectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n// 允许 json 存在没用引号括起来的 ascii 控制字符\nobjectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n```\n(2) 扩大数值字段的表现形式, 如前导 0, 无限大等;\n``` java\n// 允许 json number 类型的数存在前导 0 (like: 0001)\nobjectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n// 允许 json 存在 NaN, INF, -INF 作为 number 类型\nobjectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n```\n(3) 允许出现注释;\n``` java\n// 允许 json 存在形如 // 或 /**/ 的注释\nobjectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n```\n#### **SerializationFeature**\nSerializationFeature 的配置项, 主要是针对 javabean 字段序列化作规范与统一;\n比如:\n(1) 输出压缩的 json, 而不要缩进格式化, 浪费流量;\n(2) 统一时间类型的输出为 timestamp, 消除歧义, 方便转换;\n(3) 将空的集合类型以空的形式参与序列化, 而不是不展示它们, 从而始终能得到完整的数据结果;\n``` java\n// 序列化时, 禁止自动缩进 (格式化) 输出的 json (压缩输出)\nobjectMapper.configure(SerializationFeature.INDENT_OUTPUT, false);\n// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示\nobjectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true);\n// 序列化时, map, list 中的 null 值也要参与序列化\nobjectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, true);\n```\n另外也有一些容错方面的设置:\n``` java\n// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错\nobjectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n```\n#### **DeserializationFeature**\n反序列化时配置项, 主要是考虑到容错性, 针对陌生的字段作忽略处理, 从而提高版本之间的兼容性(比如升级某个 api 版本增加字段后, 所有调用方并不需要保持同步升级, 反序列化时对新字段暂时忽略即可);\n``` java\n// 忽略未知的字段\nobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n#### **JsonInclude.Include**\n这与 `SerializationFeature.WRITE_NULL_MAP_VALUES` 有些相似: 就是针对所有的元素, 不管是不是 null, 都要参与序列化, 要展示所有元素的情况, 而不是对空值就忽略不展示了, 那会诱导发生潜在的 bug; 这算是对字段序列化作的规范统一;\n``` java\n// 所有实例中的 空字段, null 字段, 都要参与序列化\nobjectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\nobjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n```\n\n### **jackson 选项控制的良好实践**\n公司的基础公共服务 api 中, 有一组关于 jackson 的良好封装, 旨在以更便捷友好的方式设置 jackson 配置选项, 当时该组件的作者是基础架构部的 [杨淼](mailto:miao.yang@qunar.com); 不过, 该组件源代码维护在 qunar 的私有 gitlab 仓库中, 并不对外开源; 出于与公司的保密协议, 我只能将我一个使用 scala 开发的个人项目中针对此重新编写的代码拿出来与大家分享: [便捷设置 jackson 配置选项的案例](https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json);\n这个案例中, 有两点值得分享:\n**(1) 利用重载方法统一选项设置入口**\n关于 ObjectMapper 设置选项的 configure 方法, 我们可以发现, 它有很多重载方法:\n``` java\npublic ObjectMapper configure(MapperFeature f, boolean state);\npublic ObjectMapper configure(JsonGenerator.Feature f, boolean state);\npublic ObjectMapper configure(JsonParser.Feature f, boolean state);\npublic ObjectMapper configure(SerializationFeature f, boolean state);\npublic ObjectMapper configure(DeserializationFeature f, boolean state);\n```\n以上五个重载方法已经涵盖了上一节中提到的五种 Feature 中的四种; 最后还有一个关于 JsonInclude.Include 的设置方法如下:\n``` java\n// 针对 JsonInclude.Include\npublic ObjectMapper setSerializationInclusion(JsonInclude.Include incl);\n```\n所以, 在我分享的例子中, 便抽出了一个统一设置各个 Feature 的方法:\n``` scala\nprivate def configure(mapper: ObjectMapper, feature: AnyRef, state: Boolean) {\n  feature match {\n    case feature: SerializationFeature => mapper.configure(feature.asInstanceOf[SerializationFeature], state)\n    case feature: DeserializationFeature => mapper.configure(feature.asInstanceOf[DeserializationFeature], state)\n    case feature: JsonParser.Feature => mapper.configure(feature.asInstanceOf[JsonParser.Feature], state)\n    case feature: JsonGenerator.Feature => mapper.configure(feature.asInstanceOf[JsonGenerator.Feature], state)\n    // 兜底逻辑, 针对其余的 Feature\n    case feature: MapperFeature => mapper.configure(feature.asInstanceOf[MapperFeature], state)\n    case feature: Include => if (state) mapper.setSerializationInclusion(feature.asInstanceOf[Include])\n  }\n}\n```\n\n**(2) 使用位运算符巧妙设置选项**\n其实, 在 jackson 自己的源码中, 就已经蕴含着位运算的设计思路 (以 SerializationFeature 为例):\n``` java\n/* SerializationFeature */\npublic ObjectMapper configure(SerializationFeature f, boolean state) {\n    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);\n    return this;\n}\n/* SerializationConfig */\npublic SerializationConfig with(SerializationFeature feature) {\n    int newSerFeatures = _serFeatures | feature.getMask();\n    return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures,\n        newSerFeatures, _generatorFeatures, _generatorFeaturesToChange, _formatWriteFeatures,\n        _formatWriteFeaturesToChange);\n}\n```\n其中, `feature.getMask()` 方法便是得到目标 feature 的掩码 `_mask`, 一个在二进制上与其他 feature 相互错开的整数值:\n``` java\nprivate SerializationFeature(boolean defaultState) {\n    _defaultState = defaultState;\n    _mask = (1 << ordinal());\n}\n\npublic int getMask() { return _mask; }\n```\n可以发现, `1 << ordinal()` 这个操作会给该枚举中的每个值, 依次对 1 作左移, 从而枚举内所有的值, 其二进制表示都只含有一个 1, 且两两错开 (但由于 `_mask` 是一个普通整型, 所以该枚举只能容纳不超过 32 个值);\n那么位或运算 `_serFeatures | feature.getMask()` 便等于将该目标枚举值追加到掩码中了;\n在我分享的例子中, 也是借鉴了这样巧妙的设计思想, 不同之处在于, 我的案例中是将所有常用的选项配置放在了一起, 组成了一个新的枚举, 并添加了一个 enableByDefault, 表示是否默认开启; 在这个新枚举中, 使用位操作对所有常用的配置编码, 统一设置:\n``` java\nval defaults: Long = {\n  var flags = 0\n  for (f <- values if f.enabledByDefault) {\n    flags |= f.getMask\n  }\n  flags\n}\n\nsealed case class JsonFeatureValue (@BeanProperty feature: AnyRef, enabledByDefault: Boolean) extends Val {\n  @BeanProperty val mask = 1 << id\n  def isEnabled(flags: Long): Boolean = (flags & mask) != 0\n  def enable(flags: Long): Long = flags | mask\n  def disable(flags: Long): Long = flags & (~mask)\n}\n```\n当不想使用默认设置时, 构建一个新的 ObjectMapper 实例也十分简洁, 只需传入一个掩码映射的数值即可:\n``` java\nprivate def buildMapperInternal(features: Long): ObjectMapper = {\n  val mapper = new ObjectMapper\n  for (jf <- JsonFeature.values) {\n    configure(mapper, jf.getFeature, jf.isEnabled(features))\n  }\n  mapper\n}\n```\n&nbsp;\n以上便是该案例中两个值得学习的设计要点: 基于 jackson 原生代码, 利用方法重载, 位运算符, 整合分散的配置项, 聚集为一个便捷的工具类;\n\n### **站内相关文章**\n- [便捷设置 jackson 配置选项的案例](https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json)\n\n### **参考链接**\n- [How to avoid null values serialization in HashMap](https://stackoverflow.com/questions/3140563/how-to-avoid-null-values-serialization-in-hashmap)\n- [Java program terminating after ObjectMapper.writeValue(System.out, responseData) - Jackson Library](https://stackoverflow.com/questions/8372549/java-program-terminating-after-objectmapper-writevaluesystem-out-responsedata)\n\n","source":"_posts/ser_deser-jackson--jackson_常用配置选项梳理.md","raw":"---\ntitle: jackson 常用配置选项梳理\ndate: 2017-01-21 15:51:40\ncategories:\n - ser/deser\n - jackson\ntags:\n - jackson\n - json\n---\n\n> jackson 有各种各样的配置选项 (Feature), 涵盖了包括 json 语法解析, 语句生成, 序列化 / 反序列化特征, 字段类型处理 等不同层面, 对初学者而言, 很容易造成困惑;\n本文基于 jackson 2.8.x, 着手整理常用的 jackson 配置选项, 并给出一个便捷的工具类, 以友好的方式整合 jackson 的常用配置项;\n\n<!--more-->\n\n------\n### **配置选项分类**\njackson 的配置选项丰富得可以让开发者自定义从 json 语句到 javabean 的方方面面, 总体来说有如下几类:\njson 语句的生成与解析\n``` java\n// json 语句生成的选项\nJsonGenerator.Feature\n// json 语法解析的选项\nJsonParser.Feature\n```\njavabean 的序列化与反序列化\n``` java\n// javabean 序列化选项\nSerializationFeature\n// javabean 反序列化选项\nDeserializationFeature\n```\njavabean 字段\n``` java\n// javabean 字段是否参与序列化\nJsonInclude.Include\n```\n上述各 Feature 或 Include 都是以枚举 (enum) 的形式定义的, 他们分布在 jackson 的如下包中:\n\n* JsonGenerator.Feature: jackson-core\n* JsonParser.Feature: jackson-core\n* SerializationFeature: jackson-databind\n* DeserializationFeature: jackson-databind\n* JsonInclude.Include: jackson-annotations\n\n这样的归类与它们的功能有关:\nJsonGenerator 与 JsonParser 主管 json 的生成与解析, 当属 jackson 的核心功能, 所以归于 jackson-core 包中;\nSerializationFeature 与 DeserializationFeature 主管 javabean 的序列化与反序列化, 属于数据实体绑定范畴, 所以归于 jackson-databind 包中;\nJsonInclude.Include 比较特别, 它理应主管字段是否参与序列化, 是 javabean 序列化的控制细节, 但是它的外部类 JsonInclude 本身是一个注解, 故其被归于 jackson-annotations 包中;\n&nbsp;\n下面将分别总结各类 Feature 中具体的常用选项; 有一点要说的是, 以下选项有些本身就是默认设置, 这里只是拿出来总结一下, 我们需要了解这些设置的存在; 另外, 某些设置可能只针对普遍的情况, 在特殊场景下并不适用 (比如容错性, 在某些严格的环境下就是需要 fast fail, 不需要容错);\n#### **JsonGenerator.Feature**\n其实, JsonGenerator.Feature 是一个比较底层的设置, 在源码注释中被称为 `Low-level I/O / content features`;\n关于 json 的生成的配置项, 主要是三个方面:\n(1) 统一字段的 json 规范形式, 如对引号的要求;\n``` java\n// 必须以 \"双引号\" 的形式包装字段\nobjectMapper.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n```\n(2) 加强 json 生成的容错性, 如 JsonToken (大括号与中括号) 的匹配;\n``` java\n// 允许 json 生成器自动补全未匹配的括号\nobjectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT, true);\n```\n(3) 第三个可能比较少见, 因为大部分业务场景下, 我们只是使用 `objectMapper.writeValueAsString` 方法, 得到其返回的 json 字符串以作他用; 而如果使用 `objectMapper.writeValue` 方法, 则可能涉及到写入流的问题: \n``` java\n// 允许 json 生成器在写入完成后自动关闭写入的流\nobjectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n```\n这个选项默认是开启的, 那么会导致一个问题: 当你希望在往目标输出流里输出 json 之后再输出一些其他内容便会失败, 因为 jackson 已经自动帮你关闭该输出流了; 所以有些时候, 这个选项要设置成 false;\n#### **JsonParser.Feature**\nJsonParser 的配置项, 主要是加强 json 解析的容错性, 并主要体现在三方面:\n(1) 降低字段的 json 规范形式, 如对引号的要求; 可以发现, 当自己生成 json 时, 我们要求严格规范引号的书写, 而当解析别人的 json 时, 却需要放宽规范与形式, 增强容错;\n``` java\n// 允许 json 存在没用引号括起来的 field\nobjectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// 允许 json 存在使用单引号括起来的 field\nobjectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n// 允许 json 存在没用引号括起来的 ascii 控制字符\nobjectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n```\n(2) 扩大数值字段的表现形式, 如前导 0, 无限大等;\n``` java\n// 允许 json number 类型的数存在前导 0 (like: 0001)\nobjectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n// 允许 json 存在 NaN, INF, -INF 作为 number 类型\nobjectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n```\n(3) 允许出现注释;\n``` java\n// 允许 json 存在形如 // 或 /**/ 的注释\nobjectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n```\n#### **SerializationFeature**\nSerializationFeature 的配置项, 主要是针对 javabean 字段序列化作规范与统一;\n比如:\n(1) 输出压缩的 json, 而不要缩进格式化, 浪费流量;\n(2) 统一时间类型的输出为 timestamp, 消除歧义, 方便转换;\n(3) 将空的集合类型以空的形式参与序列化, 而不是不展示它们, 从而始终能得到完整的数据结果;\n``` java\n// 序列化时, 禁止自动缩进 (格式化) 输出的 json (压缩输出)\nobjectMapper.configure(SerializationFeature.INDENT_OUTPUT, false);\n// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示\nobjectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true);\n// 序列化时, map, list 中的 null 值也要参与序列化\nobjectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, true);\n```\n另外也有一些容错方面的设置:\n``` java\n// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错\nobjectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n```\n#### **DeserializationFeature**\n反序列化时配置项, 主要是考虑到容错性, 针对陌生的字段作忽略处理, 从而提高版本之间的兼容性(比如升级某个 api 版本增加字段后, 所有调用方并不需要保持同步升级, 反序列化时对新字段暂时忽略即可);\n``` java\n// 忽略未知的字段\nobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n#### **JsonInclude.Include**\n这与 `SerializationFeature.WRITE_NULL_MAP_VALUES` 有些相似: 就是针对所有的元素, 不管是不是 null, 都要参与序列化, 要展示所有元素的情况, 而不是对空值就忽略不展示了, 那会诱导发生潜在的 bug; 这算是对字段序列化作的规范统一;\n``` java\n// 所有实例中的 空字段, null 字段, 都要参与序列化\nobjectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\nobjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n```\n\n### **jackson 选项控制的良好实践**\n公司的基础公共服务 api 中, 有一组关于 jackson 的良好封装, 旨在以更便捷友好的方式设置 jackson 配置选项, 当时该组件的作者是基础架构部的 [杨淼](mailto:miao.yang@qunar.com); 不过, 该组件源代码维护在 qunar 的私有 gitlab 仓库中, 并不对外开源; 出于与公司的保密协议, 我只能将我一个使用 scala 开发的个人项目中针对此重新编写的代码拿出来与大家分享: [便捷设置 jackson 配置选项的案例](https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json);\n这个案例中, 有两点值得分享:\n**(1) 利用重载方法统一选项设置入口**\n关于 ObjectMapper 设置选项的 configure 方法, 我们可以发现, 它有很多重载方法:\n``` java\npublic ObjectMapper configure(MapperFeature f, boolean state);\npublic ObjectMapper configure(JsonGenerator.Feature f, boolean state);\npublic ObjectMapper configure(JsonParser.Feature f, boolean state);\npublic ObjectMapper configure(SerializationFeature f, boolean state);\npublic ObjectMapper configure(DeserializationFeature f, boolean state);\n```\n以上五个重载方法已经涵盖了上一节中提到的五种 Feature 中的四种; 最后还有一个关于 JsonInclude.Include 的设置方法如下:\n``` java\n// 针对 JsonInclude.Include\npublic ObjectMapper setSerializationInclusion(JsonInclude.Include incl);\n```\n所以, 在我分享的例子中, 便抽出了一个统一设置各个 Feature 的方法:\n``` scala\nprivate def configure(mapper: ObjectMapper, feature: AnyRef, state: Boolean) {\n  feature match {\n    case feature: SerializationFeature => mapper.configure(feature.asInstanceOf[SerializationFeature], state)\n    case feature: DeserializationFeature => mapper.configure(feature.asInstanceOf[DeserializationFeature], state)\n    case feature: JsonParser.Feature => mapper.configure(feature.asInstanceOf[JsonParser.Feature], state)\n    case feature: JsonGenerator.Feature => mapper.configure(feature.asInstanceOf[JsonGenerator.Feature], state)\n    // 兜底逻辑, 针对其余的 Feature\n    case feature: MapperFeature => mapper.configure(feature.asInstanceOf[MapperFeature], state)\n    case feature: Include => if (state) mapper.setSerializationInclusion(feature.asInstanceOf[Include])\n  }\n}\n```\n\n**(2) 使用位运算符巧妙设置选项**\n其实, 在 jackson 自己的源码中, 就已经蕴含着位运算的设计思路 (以 SerializationFeature 为例):\n``` java\n/* SerializationFeature */\npublic ObjectMapper configure(SerializationFeature f, boolean state) {\n    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);\n    return this;\n}\n/* SerializationConfig */\npublic SerializationConfig with(SerializationFeature feature) {\n    int newSerFeatures = _serFeatures | feature.getMask();\n    return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures,\n        newSerFeatures, _generatorFeatures, _generatorFeaturesToChange, _formatWriteFeatures,\n        _formatWriteFeaturesToChange);\n}\n```\n其中, `feature.getMask()` 方法便是得到目标 feature 的掩码 `_mask`, 一个在二进制上与其他 feature 相互错开的整数值:\n``` java\nprivate SerializationFeature(boolean defaultState) {\n    _defaultState = defaultState;\n    _mask = (1 << ordinal());\n}\n\npublic int getMask() { return _mask; }\n```\n可以发现, `1 << ordinal()` 这个操作会给该枚举中的每个值, 依次对 1 作左移, 从而枚举内所有的值, 其二进制表示都只含有一个 1, 且两两错开 (但由于 `_mask` 是一个普通整型, 所以该枚举只能容纳不超过 32 个值);\n那么位或运算 `_serFeatures | feature.getMask()` 便等于将该目标枚举值追加到掩码中了;\n在我分享的例子中, 也是借鉴了这样巧妙的设计思想, 不同之处在于, 我的案例中是将所有常用的选项配置放在了一起, 组成了一个新的枚举, 并添加了一个 enableByDefault, 表示是否默认开启; 在这个新枚举中, 使用位操作对所有常用的配置编码, 统一设置:\n``` java\nval defaults: Long = {\n  var flags = 0\n  for (f <- values if f.enabledByDefault) {\n    flags |= f.getMask\n  }\n  flags\n}\n\nsealed case class JsonFeatureValue (@BeanProperty feature: AnyRef, enabledByDefault: Boolean) extends Val {\n  @BeanProperty val mask = 1 << id\n  def isEnabled(flags: Long): Boolean = (flags & mask) != 0\n  def enable(flags: Long): Long = flags | mask\n  def disable(flags: Long): Long = flags & (~mask)\n}\n```\n当不想使用默认设置时, 构建一个新的 ObjectMapper 实例也十分简洁, 只需传入一个掩码映射的数值即可:\n``` java\nprivate def buildMapperInternal(features: Long): ObjectMapper = {\n  val mapper = new ObjectMapper\n  for (jf <- JsonFeature.values) {\n    configure(mapper, jf.getFeature, jf.isEnabled(features))\n  }\n  mapper\n}\n```\n&nbsp;\n以上便是该案例中两个值得学习的设计要点: 基于 jackson 原生代码, 利用方法重载, 位运算符, 整合分散的配置项, 聚集为一个便捷的工具类;\n\n### **站内相关文章**\n- [便捷设置 jackson 配置选项的案例](https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json)\n\n### **参考链接**\n- [How to avoid null values serialization in HashMap](https://stackoverflow.com/questions/3140563/how-to-avoid-null-values-serialization-in-hashmap)\n- [Java program terminating after ObjectMapper.writeValue(System.out, responseData) - Jackson Library](https://stackoverflow.com/questions/8372549/java-program-terminating-after-objectmapper-writevaluesystem-out-responsedata)\n\n","slug":"ser_deser-jackson--jackson_常用配置选项梳理","published":1,"updated":"2018-05-01T08:05:10.186Z","_id":"cjgndpd650017j1jxfgr208qz","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>jackson 有各种各样的配置选项 (Feature), 涵盖了包括 json 语法解析, 语句生成, 序列化 / 反序列化特征, 字段类型处理 等不同层面, 对初学者而言, 很容易造成困惑;<br>本文基于 jackson 2.8.x, 着手整理常用的 jackson 配置选项, 并给出一个便捷的工具类, 以友好的方式整合 jackson 的常用配置项;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"配置选项分类\"><a href=\"#配置选项分类\" class=\"headerlink\" title=\"配置选项分类\"></a><strong>配置选项分类</strong></h3><p>jackson 的配置选项丰富得可以让开发者自定义从 json 语句到 javabean 的方方面面, 总体来说有如下几类:<br>json 语句的生成与解析<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// json 语句生成的选项</span></span><br><span class=\"line\">JsonGenerator.Feature</span><br><span class=\"line\"><span class=\"comment\">// json 语法解析的选项</span></span><br><span class=\"line\">JsonParser.Feature</span><br></pre></td></tr></table></figure></p>\n<p>javabean 的序列化与反序列化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javabean 序列化选项</span></span><br><span class=\"line\">SerializationFeature</span><br><span class=\"line\"><span class=\"comment\">// javabean 反序列化选项</span></span><br><span class=\"line\">DeserializationFeature</span><br></pre></td></tr></table></figure></p>\n<p>javabean 字段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javabean 字段是否参与序列化</span></span><br><span class=\"line\">JsonInclude.Include</span><br></pre></td></tr></table></figure></p>\n<p>上述各 Feature 或 Include 都是以枚举 (enum) 的形式定义的, 他们分布在 jackson 的如下包中:</p>\n<ul>\n<li>JsonGenerator.Feature: jackson-core</li>\n<li>JsonParser.Feature: jackson-core</li>\n<li>SerializationFeature: jackson-databind</li>\n<li>DeserializationFeature: jackson-databind</li>\n<li>JsonInclude.Include: jackson-annotations</li>\n</ul>\n<p>这样的归类与它们的功能有关:<br>JsonGenerator 与 JsonParser 主管 json 的生成与解析, 当属 jackson 的核心功能, 所以归于 jackson-core 包中;<br>SerializationFeature 与 DeserializationFeature 主管 javabean 的序列化与反序列化, 属于数据实体绑定范畴, 所以归于 jackson-databind 包中;<br>JsonInclude.Include 比较特别, 它理应主管字段是否参与序列化, 是 javabean 序列化的控制细节, 但是它的外部类 JsonInclude 本身是一个注解, 故其被归于 jackson-annotations 包中;<br>&nbsp;<br>下面将分别总结各类 Feature 中具体的常用选项; 有一点要说的是, 以下选项有些本身就是默认设置, 这里只是拿出来总结一下, 我们需要了解这些设置的存在; 另外, 某些设置可能只针对普遍的情况, 在特殊场景下并不适用 (比如容错性, 在某些严格的环境下就是需要 fast fail, 不需要容错);</p>\n<h4 id=\"JsonGenerator-Feature\"><a href=\"#JsonGenerator-Feature\" class=\"headerlink\" title=\"JsonGenerator.Feature\"></a><strong>JsonGenerator.Feature</strong></h4><p>其实, JsonGenerator.Feature 是一个比较底层的设置, 在源码注释中被称为 <code>Low-level I/O / content features</code>;<br>关于 json 的生成的配置项, 主要是三个方面:<br>(1) 统一字段的 json 规范形式, 如对引号的要求;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 必须以 \"双引号\" 的形式包装字段</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(2) 加强 json 生成的容错性, 如 JsonToken (大括号与中括号) 的匹配;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 生成器自动补全未匹配的括号</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(3) 第三个可能比较少见, 因为大部分业务场景下, 我们只是使用 <code>objectMapper.writeValueAsString</code> 方法, 得到其返回的 json 字符串以作他用; 而如果使用 <code>objectMapper.writeValue</code> 方法, 则可能涉及到写入流的问题:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 生成器在写入完成后自动关闭写入的流</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这个选项默认是开启的, 那么会导致一个问题: 当你希望在往目标输出流里输出 json 之后再输出一些其他内容便会失败, 因为 jackson 已经自动帮你关闭该输出流了; 所以有些时候, 这个选项要设置成 false;</p>\n<h4 id=\"JsonParser-Feature\"><a href=\"#JsonParser-Feature\" class=\"headerlink\" title=\"JsonParser.Feature\"></a><strong>JsonParser.Feature</strong></h4><p>JsonParser 的配置项, 主要是加强 json 解析的容错性, 并主要体现在三方面:<br>(1) 降低字段的 json 规范形式, 如对引号的要求; 可以发现, 当自己生成 json 时, 我们要求严格规范引号的书写, 而当解析别人的 json 时, 却需要放宽规范与形式, 增强容错;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 存在没用引号括起来的 field</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在使用单引号括起来的 field</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在没用引号括起来的 ascii 控制字符</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(2) 扩大数值字段的表现形式, 如前导 0, 无限大等;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json number 类型的数存在前导 0 (like: 0001)</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在 NaN, INF, -INF 作为 number 类型</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(3) 允许出现注释;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 存在形如 // 或 /**/ 的注释</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"SerializationFeature\"><a href=\"#SerializationFeature\" class=\"headerlink\" title=\"SerializationFeature\"></a><strong>SerializationFeature</strong></h4><p>SerializationFeature 的配置项, 主要是针对 javabean 字段序列化作规范与统一;<br>比如:<br>(1) 输出压缩的 json, 而不要缩进格式化, 浪费流量;<br>(2) 统一时间类型的输出为 timestamp, 消除歧义, 方便转换;<br>(3) 将空的集合类型以空的形式参与序列化, 而不是不展示它们, 从而始终能得到完整的数据结果;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化时, 禁止自动缩进 (格式化) 输出的 json (压缩输出)</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.INDENT_OUTPUT, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 序列化时, map, list 中的 null 值也要参与序列化</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>另外也有一些容错方面的设置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DeserializationFeature\"><a href=\"#DeserializationFeature\" class=\"headerlink\" title=\"DeserializationFeature\"></a><strong>DeserializationFeature</strong></h4><p>反序列化时配置项, 主要是考虑到容错性, 针对陌生的字段作忽略处理, 从而提高版本之间的兼容性(比如升级某个 api 版本增加字段后, 所有调用方并不需要保持同步升级, 反序列化时对新字段暂时忽略即可);<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 忽略未知的字段</span></span><br><span class=\"line\">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JsonInclude-Include\"><a href=\"#JsonInclude-Include\" class=\"headerlink\" title=\"JsonInclude.Include\"></a><strong>JsonInclude.Include</strong></h4><p>这与 <code>SerializationFeature.WRITE_NULL_MAP_VALUES</code> 有些相似: 就是针对所有的元素, 不管是不是 null, 都要参与序列化, 要展示所有元素的情况, 而不是对空值就忽略不展示了, 那会诱导发生潜在的 bug; 这算是对字段序列化作的规范统一;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所有实例中的 空字段, null 字段, 都要参与序列化</span></span><br><span class=\"line\">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class=\"line\">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jackson-选项控制的良好实践\"><a href=\"#jackson-选项控制的良好实践\" class=\"headerlink\" title=\"jackson 选项控制的良好实践\"></a><strong>jackson 选项控制的良好实践</strong></h3><p>公司的基础公共服务 api 中, 有一组关于 jackson 的良好封装, 旨在以更便捷友好的方式设置 jackson 配置选项, 当时该组件的作者是基础架构部的 <a href=\"mailto:miao.yang@qunar.com\" target=\"_blank\" rel=\"noopener\">杨淼</a>; 不过, 该组件源代码维护在 qunar 的私有 gitlab 仓库中, 并不对外开源; 出于与公司的保密协议, 我只能将我一个使用 scala 开发的个人项目中针对此重新编写的代码拿出来与大家分享: <a href=\"https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json\" target=\"_blank\" rel=\"noopener\">便捷设置 jackson 配置选项的案例</a>;<br>这个案例中, 有两点值得分享:<br><strong>(1) 利用重载方法统一选项设置入口</strong><br>关于 ObjectMapper 设置选项的 configure 方法, 我们可以发现, 它有很多重载方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(MapperFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(JsonGenerator.Feature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(JsonParser.Feature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(SerializationFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(DeserializationFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>以上五个重载方法已经涵盖了上一节中提到的五种 Feature 中的四种; 最后还有一个关于 JsonInclude.Include 的设置方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 针对 JsonInclude.Include</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">setSerializationInclusion</span><span class=\"params\">(JsonInclude.Include incl)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>所以, 在我分享的例子中, 便抽出了一个统一设置各个 Feature 的方法:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">configure</span></span>(mapper: <span class=\"type\">ObjectMapper</span>, feature: <span class=\"type\">AnyRef</span>, state: <span class=\"type\">Boolean</span>) &#123;</span><br><span class=\"line\">  feature <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">SerializationFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">SerializationFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">DeserializationFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">DeserializationFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">JsonParser</span>.<span class=\"type\">Feature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">JsonParser</span>.<span class=\"type\">Feature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">JsonGenerator</span>.<span class=\"type\">Feature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">JsonGenerator</span>.<span class=\"type\">Feature</span>], state)</span><br><span class=\"line\">    <span class=\"comment\">// 兜底逻辑, 针对其余的 Feature</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">MapperFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">MapperFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">Include</span> =&gt; <span class=\"keyword\">if</span> (state) mapper.setSerializationInclusion(feature.asInstanceOf[<span class=\"type\">Include</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) 使用位运算符巧妙设置选项</strong><br>其实, 在 jackson 自己的源码中, 就已经蕴含着位运算的设计思路 (以 SerializationFeature 为例):<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* SerializationFeature */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(SerializationFeature f, <span class=\"keyword\">boolean</span> state)</span> </span>&#123;</span><br><span class=\"line\">    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* SerializationConfig */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SerializationConfig <span class=\"title\">with</span><span class=\"params\">(SerializationFeature feature)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newSerFeatures = _serFeatures | feature.getMask();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (newSerFeatures == _serFeatures) ? <span class=\"keyword\">this</span> : <span class=\"keyword\">new</span> SerializationConfig(<span class=\"keyword\">this</span>, _mapperFeatures,</span><br><span class=\"line\">        newSerFeatures, _generatorFeatures, _generatorFeaturesToChange, _formatWriteFeatures,</span><br><span class=\"line\">        _formatWriteFeaturesToChange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中, <code>feature.getMask()</code> 方法便是得到目标 feature 的掩码 <code>_mask</code>, 一个在二进制上与其他 feature 相互错开的整数值:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SerializationFeature</span><span class=\"params\">(<span class=\"keyword\">boolean</span> defaultState)</span> </span>&#123;</span><br><span class=\"line\">    _defaultState = defaultState;</span><br><span class=\"line\">    _mask = (<span class=\"number\">1</span> &lt;&lt; ordinal());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMask</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _mask; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, <code>1 &lt;&lt; ordinal()</code> 这个操作会给该枚举中的每个值, 依次对 1 作左移, 从而枚举内所有的值, 其二进制表示都只含有一个 1, 且两两错开 (但由于 <code>_mask</code> 是一个普通整型, 所以该枚举只能容纳不超过 32 个值);<br>那么位或运算 <code>_serFeatures | feature.getMask()</code> 便等于将该目标枚举值追加到掩码中了;<br>在我分享的例子中, 也是借鉴了这样巧妙的设计思想, 不同之处在于, 我的案例中是将所有常用的选项配置放在了一起, 组成了一个新的枚举, 并添加了一个 enableByDefault, 表示是否默认开启; 在这个新枚举中, 使用位操作对所有常用的配置编码, 统一设置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val defaults: Long = &#123;</span><br><span class=\"line\">  var flags = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (f &lt;- values <span class=\"keyword\">if</span> f.enabledByDefault) &#123;</span><br><span class=\"line\">    flags |= f.getMask</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sealed <span class=\"keyword\">case</span> class <span class=\"title\">JsonFeatureValue</span> <span class=\"params\">(@BeanProperty feature: AnyRef, enabledByDefault: Boolean)</span> extends Val </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@BeanProperty</span> val mask = <span class=\"number\">1</span> &lt;&lt; id</span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">isEnabled</span><span class=\"params\">(flags: Long)</span>: Boolean </span>= (flags &amp; mask) != <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">enable</span><span class=\"params\">(flags: Long)</span>: Long </span>= flags | mask</span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">disable</span><span class=\"params\">(flags: Long)</span>: Long </span>= flags &amp; (~mask)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当不想使用默认设置时, 构建一个新的 ObjectMapper 实例也十分简洁, 只需传入一个掩码映射的数值即可:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> def <span class=\"title\">buildMapperInternal</span><span class=\"params\">(features: Long)</span>: ObjectMapper </span>= &#123;</span><br><span class=\"line\">  val mapper = <span class=\"keyword\">new</span> ObjectMapper</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (jf &lt;- JsonFeature.values) &#123;</span><br><span class=\"line\">    configure(mapper, jf.getFeature, jf.isEnabled(features))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mapper</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>以上便是该案例中两个值得学习的设计要点: 基于 jackson 原生代码, 利用方法重载, 位运算符, 整合分散的配置项, 聚集为一个便捷的工具类;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json\" target=\"_blank\" rel=\"noopener\">便捷设置 jackson 配置选项的案例</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/3140563/how-to-avoid-null-values-serialization-in-hashmap\" target=\"_blank\" rel=\"noopener\">How to avoid null values serialization in HashMap</a></li>\n<li><a href=\"https://stackoverflow.com/questions/8372549/java-program-terminating-after-objectmapper-writevaluesystem-out-responsedata\" target=\"_blank\" rel=\"noopener\">Java program terminating after ObjectMapper.writeValue(System.out, responseData) - Jackson Library</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>jackson 有各种各样的配置选项 (Feature), 涵盖了包括 json 语法解析, 语句生成, 序列化 / 反序列化特征, 字段类型处理 等不同层面, 对初学者而言, 很容易造成困惑;<br>本文基于 jackson 2.8.x, 着手整理常用的 jackson 配置选项, 并给出一个便捷的工具类, 以友好的方式整合 jackson 的常用配置项;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"配置选项分类\"><a href=\"#配置选项分类\" class=\"headerlink\" title=\"配置选项分类\"></a><strong>配置选项分类</strong></h3><p>jackson 的配置选项丰富得可以让开发者自定义从 json 语句到 javabean 的方方面面, 总体来说有如下几类:<br>json 语句的生成与解析<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// json 语句生成的选项</span></span><br><span class=\"line\">JsonGenerator.Feature</span><br><span class=\"line\"><span class=\"comment\">// json 语法解析的选项</span></span><br><span class=\"line\">JsonParser.Feature</span><br></pre></td></tr></table></figure></p>\n<p>javabean 的序列化与反序列化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javabean 序列化选项</span></span><br><span class=\"line\">SerializationFeature</span><br><span class=\"line\"><span class=\"comment\">// javabean 反序列化选项</span></span><br><span class=\"line\">DeserializationFeature</span><br></pre></td></tr></table></figure></p>\n<p>javabean 字段<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javabean 字段是否参与序列化</span></span><br><span class=\"line\">JsonInclude.Include</span><br></pre></td></tr></table></figure></p>\n<p>上述各 Feature 或 Include 都是以枚举 (enum) 的形式定义的, 他们分布在 jackson 的如下包中:</p>\n<ul>\n<li>JsonGenerator.Feature: jackson-core</li>\n<li>JsonParser.Feature: jackson-core</li>\n<li>SerializationFeature: jackson-databind</li>\n<li>DeserializationFeature: jackson-databind</li>\n<li>JsonInclude.Include: jackson-annotations</li>\n</ul>\n<p>这样的归类与它们的功能有关:<br>JsonGenerator 与 JsonParser 主管 json 的生成与解析, 当属 jackson 的核心功能, 所以归于 jackson-core 包中;<br>SerializationFeature 与 DeserializationFeature 主管 javabean 的序列化与反序列化, 属于数据实体绑定范畴, 所以归于 jackson-databind 包中;<br>JsonInclude.Include 比较特别, 它理应主管字段是否参与序列化, 是 javabean 序列化的控制细节, 但是它的外部类 JsonInclude 本身是一个注解, 故其被归于 jackson-annotations 包中;<br>&nbsp;<br>下面将分别总结各类 Feature 中具体的常用选项; 有一点要说的是, 以下选项有些本身就是默认设置, 这里只是拿出来总结一下, 我们需要了解这些设置的存在; 另外, 某些设置可能只针对普遍的情况, 在特殊场景下并不适用 (比如容错性, 在某些严格的环境下就是需要 fast fail, 不需要容错);</p>\n<h4 id=\"JsonGenerator-Feature\"><a href=\"#JsonGenerator-Feature\" class=\"headerlink\" title=\"JsonGenerator.Feature\"></a><strong>JsonGenerator.Feature</strong></h4><p>其实, JsonGenerator.Feature 是一个比较底层的设置, 在源码注释中被称为 <code>Low-level I/O / content features</code>;<br>关于 json 的生成的配置项, 主要是三个方面:<br>(1) 统一字段的 json 规范形式, 如对引号的要求;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 必须以 \"双引号\" 的形式包装字段</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(2) 加强 json 生成的容错性, 如 JsonToken (大括号与中括号) 的匹配;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 生成器自动补全未匹配的括号</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(3) 第三个可能比较少见, 因为大部分业务场景下, 我们只是使用 <code>objectMapper.writeValueAsString</code> 方法, 得到其返回的 json 字符串以作他用; 而如果使用 <code>objectMapper.writeValue</code> 方法, 则可能涉及到写入流的问题:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 生成器在写入完成后自动关闭写入的流</span></span><br><span class=\"line\">objectMapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这个选项默认是开启的, 那么会导致一个问题: 当你希望在往目标输出流里输出 json 之后再输出一些其他内容便会失败, 因为 jackson 已经自动帮你关闭该输出流了; 所以有些时候, 这个选项要设置成 false;</p>\n<h4 id=\"JsonParser-Feature\"><a href=\"#JsonParser-Feature\" class=\"headerlink\" title=\"JsonParser.Feature\"></a><strong>JsonParser.Feature</strong></h4><p>JsonParser 的配置项, 主要是加强 json 解析的容错性, 并主要体现在三方面:<br>(1) 降低字段的 json 规范形式, 如对引号的要求; 可以发现, 当自己生成 json 时, 我们要求严格规范引号的书写, 而当解析别人的 json 时, 却需要放宽规范与形式, 增强容错;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 存在没用引号括起来的 field</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在使用单引号括起来的 field</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在没用引号括起来的 ascii 控制字符</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(2) 扩大数值字段的表现形式, 如前导 0, 无限大等;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json number 类型的数存在前导 0 (like: 0001)</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 允许 json 存在 NaN, INF, -INF 作为 number 类型</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>(3) 允许出现注释;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 允许 json 存在形如 // 或 /**/ 的注释</span></span><br><span class=\"line\">objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"SerializationFeature\"><a href=\"#SerializationFeature\" class=\"headerlink\" title=\"SerializationFeature\"></a><strong>SerializationFeature</strong></h4><p>SerializationFeature 的配置项, 主要是针对 javabean 字段序列化作规范与统一;<br>比如:<br>(1) 输出压缩的 json, 而不要缩进格式化, 浪费流量;<br>(2) 统一时间类型的输出为 timestamp, 消除歧义, 方便转换;<br>(3) 将空的集合类型以空的形式参与序列化, 而不是不展示它们, 从而始终能得到完整的数据结果;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化时, 禁止自动缩进 (格式化) 输出的 json (压缩输出)</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.INDENT_OUTPUT, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 序列化时, map, list 中的 null 值也要参与序列化</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>另外也有一些容错方面的设置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错</span></span><br><span class=\"line\">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DeserializationFeature\"><a href=\"#DeserializationFeature\" class=\"headerlink\" title=\"DeserializationFeature\"></a><strong>DeserializationFeature</strong></h4><p>反序列化时配置项, 主要是考虑到容错性, 针对陌生的字段作忽略处理, 从而提高版本之间的兼容性(比如升级某个 api 版本增加字段后, 所有调用方并不需要保持同步升级, 反序列化时对新字段暂时忽略即可);<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 忽略未知的字段</span></span><br><span class=\"line\">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JsonInclude-Include\"><a href=\"#JsonInclude-Include\" class=\"headerlink\" title=\"JsonInclude.Include\"></a><strong>JsonInclude.Include</strong></h4><p>这与 <code>SerializationFeature.WRITE_NULL_MAP_VALUES</code> 有些相似: 就是针对所有的元素, 不管是不是 null, 都要参与序列化, 要展示所有元素的情况, 而不是对空值就忽略不展示了, 那会诱导发生潜在的 bug; 这算是对字段序列化作的规范统一;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所有实例中的 空字段, null 字段, 都要参与序列化</span></span><br><span class=\"line\">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class=\"line\">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jackson-选项控制的良好实践\"><a href=\"#jackson-选项控制的良好实践\" class=\"headerlink\" title=\"jackson 选项控制的良好实践\"></a><strong>jackson 选项控制的良好实践</strong></h3><p>公司的基础公共服务 api 中, 有一组关于 jackson 的良好封装, 旨在以更便捷友好的方式设置 jackson 配置选项, 当时该组件的作者是基础架构部的 <a href=\"mailto:miao.yang@qunar.com\" target=\"_blank\" rel=\"noopener\">杨淼</a>; 不过, 该组件源代码维护在 qunar 的私有 gitlab 仓库中, 并不对外开源; 出于与公司的保密协议, 我只能将我一个使用 scala 开发的个人项目中针对此重新编写的代码拿出来与大家分享: <a href=\"https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json\" target=\"_blank\" rel=\"noopener\">便捷设置 jackson 配置选项的案例</a>;<br>这个案例中, 有两点值得分享:<br><strong>(1) 利用重载方法统一选项设置入口</strong><br>关于 ObjectMapper 设置选项的 configure 方法, 我们可以发现, 它有很多重载方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(MapperFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(JsonGenerator.Feature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(JsonParser.Feature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(SerializationFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(DeserializationFeature f, <span class=\"keyword\">boolean</span> state)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>以上五个重载方法已经涵盖了上一节中提到的五种 Feature 中的四种; 最后还有一个关于 JsonInclude.Include 的设置方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 针对 JsonInclude.Include</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">setSerializationInclusion</span><span class=\"params\">(JsonInclude.Include incl)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>所以, 在我分享的例子中, 便抽出了一个统一设置各个 Feature 的方法:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">configure</span></span>(mapper: <span class=\"type\">ObjectMapper</span>, feature: <span class=\"type\">AnyRef</span>, state: <span class=\"type\">Boolean</span>) &#123;</span><br><span class=\"line\">  feature <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">SerializationFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">SerializationFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">DeserializationFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">DeserializationFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">JsonParser</span>.<span class=\"type\">Feature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">JsonParser</span>.<span class=\"type\">Feature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">JsonGenerator</span>.<span class=\"type\">Feature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">JsonGenerator</span>.<span class=\"type\">Feature</span>], state)</span><br><span class=\"line\">    <span class=\"comment\">// 兜底逻辑, 针对其余的 Feature</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">MapperFeature</span> =&gt; mapper.configure(feature.asInstanceOf[<span class=\"type\">MapperFeature</span>], state)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> feature: <span class=\"type\">Include</span> =&gt; <span class=\"keyword\">if</span> (state) mapper.setSerializationInclusion(feature.asInstanceOf[<span class=\"type\">Include</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) 使用位运算符巧妙设置选项</strong><br>其实, 在 jackson 自己的源码中, 就已经蕴含着位运算的设计思路 (以 SerializationFeature 为例):<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* SerializationFeature */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">configure</span><span class=\"params\">(SerializationFeature f, <span class=\"keyword\">boolean</span> state)</span> </span>&#123;</span><br><span class=\"line\">    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* SerializationConfig */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SerializationConfig <span class=\"title\">with</span><span class=\"params\">(SerializationFeature feature)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newSerFeatures = _serFeatures | feature.getMask();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (newSerFeatures == _serFeatures) ? <span class=\"keyword\">this</span> : <span class=\"keyword\">new</span> SerializationConfig(<span class=\"keyword\">this</span>, _mapperFeatures,</span><br><span class=\"line\">        newSerFeatures, _generatorFeatures, _generatorFeaturesToChange, _formatWriteFeatures,</span><br><span class=\"line\">        _formatWriteFeaturesToChange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中, <code>feature.getMask()</code> 方法便是得到目标 feature 的掩码 <code>_mask</code>, 一个在二进制上与其他 feature 相互错开的整数值:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SerializationFeature</span><span class=\"params\">(<span class=\"keyword\">boolean</span> defaultState)</span> </span>&#123;</span><br><span class=\"line\">    _defaultState = defaultState;</span><br><span class=\"line\">    _mask = (<span class=\"number\">1</span> &lt;&lt; ordinal());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMask</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _mask; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以发现, <code>1 &lt;&lt; ordinal()</code> 这个操作会给该枚举中的每个值, 依次对 1 作左移, 从而枚举内所有的值, 其二进制表示都只含有一个 1, 且两两错开 (但由于 <code>_mask</code> 是一个普通整型, 所以该枚举只能容纳不超过 32 个值);<br>那么位或运算 <code>_serFeatures | feature.getMask()</code> 便等于将该目标枚举值追加到掩码中了;<br>在我分享的例子中, 也是借鉴了这样巧妙的设计思想, 不同之处在于, 我的案例中是将所有常用的选项配置放在了一起, 组成了一个新的枚举, 并添加了一个 enableByDefault, 表示是否默认开启; 在这个新枚举中, 使用位操作对所有常用的配置编码, 统一设置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val defaults: Long = &#123;</span><br><span class=\"line\">  var flags = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (f &lt;- values <span class=\"keyword\">if</span> f.enabledByDefault) &#123;</span><br><span class=\"line\">    flags |= f.getMask</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sealed <span class=\"keyword\">case</span> class <span class=\"title\">JsonFeatureValue</span> <span class=\"params\">(@BeanProperty feature: AnyRef, enabledByDefault: Boolean)</span> extends Val </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@BeanProperty</span> val mask = <span class=\"number\">1</span> &lt;&lt; id</span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">isEnabled</span><span class=\"params\">(flags: Long)</span>: Boolean </span>= (flags &amp; mask) != <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">enable</span><span class=\"params\">(flags: Long)</span>: Long </span>= flags | mask</span><br><span class=\"line\">  <span class=\"function\">def <span class=\"title\">disable</span><span class=\"params\">(flags: Long)</span>: Long </span>= flags &amp; (~mask)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当不想使用默认设置时, 构建一个新的 ObjectMapper 实例也十分简洁, 只需传入一个掩码映射的数值即可:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> def <span class=\"title\">buildMapperInternal</span><span class=\"params\">(features: Long)</span>: ObjectMapper </span>= &#123;</span><br><span class=\"line\">  val mapper = <span class=\"keyword\">new</span> ObjectMapper</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (jf &lt;- JsonFeature.values) &#123;</span><br><span class=\"line\">    configure(mapper, jf.getFeature, jf.isEnabled(features))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mapper</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;<br>以上便是该案例中两个值得学习的设计要点: 基于 jackson 原生代码, 利用方法重载, 位运算符, 整合分散的配置项, 聚集为一个便捷的工具类;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"https://github.com/spark-bypass-common/common-base/tree/master/src/main/scala/com/qunar/spark/base/json\" target=\"_blank\" rel=\"noopener\">便捷设置 jackson 配置选项的案例</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/3140563/how-to-avoid-null-values-serialization-in-hashmap\" target=\"_blank\" rel=\"noopener\">How to avoid null values serialization in HashMap</a></li>\n<li><a href=\"https://stackoverflow.com/questions/8372549/java-program-terminating-after-objectmapper-writevaluesystem-out-responsedata\" target=\"_blank\" rel=\"noopener\">Java program terminating after ObjectMapper.writeValue(System.out, responseData) - Jackson Library</a></li>\n</ul>"},{"title":"python module 使用总结: MySQLdb","date":"2017-08-01T15:06:08.000Z","_content":"\n> `MySQLdb` 模块是 python 与 mysql 交互的较为底层的接口, 不过它依然是在更为底层的 `_mysql` 模块之上又作了一层包装;\n`_mysql` 才是真正的直接面向 mysql 原生 C 接口的简单适配层, 而 `MySQLdb` 则在 `_mysql` 之上作了更多的关于类型转换等抽象包装;\n考虑到 `MySQLdb` 模块与一些 python ORM 框架的关系, `MySQLdb` 与 python 的关系可以类比为 jdbc 之于 java;\n如果是复杂的系统, 我们肯定会选择 ORM 框架, 不过对于一些简单的小工具, 定时小任务等, 本身没什么复杂的数据库操作, 那就用 MySQLdb 最方便了;\n本文基于 `MySQL-python 1.2.5` 对 MySQLdb 作一些使用上的总结;\n\n<!--more-->\n\n------\n\n### **MySQLdb 的基本操作**\n``` python\nimport MySQLdb\n# 获得 mysql 的一个连接\nconn = MySQLdb.connect(host='10.64.0.11', user='xxx', passwd='yyy', db=\"zzz\", port=3306, charset=\"utf8\")\ntry:\n    # cursor 游标, 是 MySQLdb 中与 mysql 增删改查数据交互的对象\n    cur = conn.cursor()\n    # 数据库操作\n    cur.execute(\"...sql...\")\n    ...\n    # 提交事务\n    conn.commit()\nexcept Exception, e:\n    # 回滚\n    conn.rollback()\nfinally:\n    # 关闭连接, 释放资源\n    conn.close()\n```\n以上是一个 MySQLdb 使用的完整流程, 下面是具体的使用细节与注意点总结;\n\n### **MySQLdb cursor.execute / cursor.executemany 方法**\n#### **cursor.execute 方法**\nMySQLdb 执行数据操纵的关键点就在于 cursor.execute 方法, 所有包括增删改查在内皆是以此方法执行的, 以下是该方法的代码:\n``` python\ndef execute(self, query, args=None):\n    del self.messages[:]\n    db = self._get_db()\n    if isinstance(query, unicode):\n        query = query.encode(db.unicode_literal.charset)\n    if args is not None:\n        # 针对 args 为 dict 的特殊情况处理\n        if isinstance(args, dict):\n            query = query % dict((key, db.literal(item)) for key, item in args.iteritems())\n        # 其余的情况: args 为 tuple 或单个 value\n        else:\n            query = query % tuple([db.literal(item) for item in args])\n    try:\n        r = None\n        r = self._query(query)\n    except TypeError, m:\n        if m.args[0] in (\"not enough arguments for format string\", \"not all arguments converted\"):\n            self.messages.append((ProgrammingError, m.args[0]))\n            self.errorhandler(self, ProgrammingError, m.args[0])\n        else:\n            self.messages.append((TypeError, m)) \n            self.errorhandler(self, TypeError, m)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        exc, value, tb = sys.exc_info()\n        del tb\n        self.messages.append((exc, value))\n        self.errorhandler(self, exc, value)\n    self._executed = query\n    if not self._defer_warnings: self._warning_check()\n    return r\n```\n该方法接收一个名为 `query` 的 sql 字符串, 另外还可选附带参数 `args`, 所以该方法存在两种主要的用法:\n1.预先格式化好 sql 字符串, 然后不带参数直接 execute:\n``` python\nsql = \"select * from xxx where update_time = %s\" % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\ncursor.execute(sql)\n```\n这种是保守的方法, 参数处理完全由 python 原生的格式化字符串完成, cursor.execute 方法只管执行 sql 就好;\n这种方法的优点是省事, 坑少;\n&nbsp;\n2.将参数传给 execute 方法的 `args`, 这种使用方法有几个坑, 需要注意一下;\n该方法有一段注释, 我单独提了出来, 注释中对 args 参数有如下描述:\n``` python\n\"\"\"\n    args -- optional sequence or mapping, parameters to use with query.\n\n    Note: If args is a sequence, then %s must be used as the\n    parameter placeholder in the query. If a mapping is used,\n    %(key)s must be used as the placeholder.\n\"\"\"\n```\n(1) 注释中提到的坑, 就是说无论传的参数是一个 list/tuple, 还是 dict, 参数占位符类型都必须是字符串(%s | %(key)s ):\n``` python\n# 不能是 id = %d, 只能是 id = %s\nsql = 'select * from xxx where id  = %s'\n```\n因为 execute 方法里处理参数时, 会对参数作 `db.literal(item)` 处理, 将参数首先转为字符串, 这时占位符如果是 %d 等其他类型, 就报错了;\n\n&nbsp;\n(2) 注释中另一个隐型的坑, 是这个 `args` 必须是 list / tuple / dict 中的一个, 哪怕只有一个占位数据, 也必须写成 list 或 tuple 类型:\n``` python\ncursor.execute(sql, (2,))\ncursor.execute(sql, [2])\n```\n如果希望以 tuple 形式表示唯一一个参数, 必须注意加上 逗号, 因为不加逗号就算外面包了括号也会识别为其本身的类型:\n``` python\n>>> print type((1))\n<type 'int'>\n>>> print type(('1'))\n<type 'str'>\n>>> print type((1,))\n<type 'tuple'>\n>>> print type(('1',))\n<type 'tuple'>\n```\n其实这个坑是在 MySQL-python 1.2.5 版本中出现的问题; 在 1.2.3 版本中, execute 方法的逻辑是这么写的:\n``` python\nif args is not None:\n    query = query % db.literal(args)\n```\n只要 args 非空, 就一律把它 to string; 而至于参数怎么转, 转成什么样, 就看参数自己了;\n这么做确实灵活了, 但是也可能带来一些不确定性, 1.2.5 的版本将参数限定为 list / tuple / dict, 然后对集合内的每个元素再针对性 to string, 一定程度上控制了参数的规范性;\n&nbsp;\n#### **cursor.executemany 方法**\nexecutemany 方法是 execute 方法的批量化, 这个方法的有效使用范围其实很狭窄, 仅针对 insert 操作有性能提升, 其余操作在性能上均与 execute 无异;\n下面是该方法的代码:\n``` python\n        del self.messages[:]\n        db = self._get_db()\n        if not args: return\n        if isinstance(query, unicode):\n            query = query.encode(db.unicode_literal.charset)\n        # 正则匹配 insert 操作\n        m = insert_values.search(query)\n        # 不是 insert 操作, 那就 for 循环挨个执行而已\n        if not m:\n            r = 0\n            for a in args:\n                r = r + self.execute(query, a)\n            return r\n        p = m.start(1)\n        e = m.end(1)\n        qv = m.group(1)\n        # 下面是针对 insert 的处理\n        try:\n            q = []\n            for a in args:\n                if isinstance(a, dict):\n                    q.append(qv % dict((key, db.literal(item))\n                                       for key, item in a.iteritems()))\n                else:\n                    q.append(qv % tuple([db.literal(item) for item in a]))\n        except TypeError, msg:\n            if msg.args[0] in (\"not enough arguments for format string\",\n                               \"not all arguments converted\"):\n                self.errorhandler(self, ProgrammingError, msg.args[0])\n            else:\n                self.errorhandler(self, TypeError, msg)\n        except (SystemExit, KeyboardInterrupt):\n            raise\n        except:\n            exc, value, tb = sys.exc_info()\n            del tb\n            self.errorhandler(self, exc, value)\n        # 批量化执行, 提高处理性能\n        r = self._query('\\n'.join([query[:p], ',\\n'.join(q), query[e:]]))\n        if not self._defer_warnings: self._warning_check()\n        return r\n```\n从代码里可以看到, 方法先对传入的 sql 语句作一次匹配, 判断其是否是 insert 操作, 其中 insert_values 是一个 regex, 专门匹配 insert 语句:\n``` python\nrestr = r\"\\svalues\\s*(\\([^()']*(?:(?:(?:\\(.*\\))|'[^\\\\']*(?:\\\\.[^\\\\']*)*')[^()']*)*\\))\"\ninsert_values = re.compile(restr, re.S | re.I | re.X)\n```\n针对 insert 语句, 其最后的执行是批量的, 以提高执行效率:\n``` python\nr = self._query('\\n'.join([query[:p], ',\\n'.join(q), query[e:]]))\n```\n但是而其他的语句, 却只能在一个 for 循环里, 挨个执行 execute 方法, 这就没什么优势了;\n不过这个方法还有一个大坑: 对于 update 和 delete 操作, 使用 executemany 至少不会比 execute 差, 但是对于 query, 它批量执行完一堆 query 操作后去 fetch 结果集, 只能拿到最后执行的 query 的结果, 前面的都被覆盖了; 所以, query 操作不能使用 executemany 方法;\n&nbsp;\n在使用方面, executemany 的坑和 execute 是差不多的, 下面是一个例子:\n``` python\n# executemany 传入的 args 可以是 list 也可以是 tuple\ncur.executemany('select * from xxx where yyy = %s', [(1,), (2,)])\n```\n\n### **MySQLdb 的 query 结果集操作**\nMySQLdb 的 query 操作, 主要有以下三种结果集的获取方法:\n``` python\ncursor.execute(\"...sql...\")\n\n# 获得所有的 tuple 结果集的一个 list\n@return list[tuple(elem1, elem2, elem3 ...)]\ntuple_data_list = cursor.fetchall()\nfor tuple_data in tuple_data_list:\n    xxx = tuple_data[0]\n    yyy = tuple_data[1]\n    ...\n    \n\n# 采用迭代器的方式, 返回当前游标所对应的 tuple 结果集, 迭代到最后方法返回 None\n@return tuple(elem1, elem2, elem3 ...)\ntuple_data = cursor.fetchone()\nwhile tuple_data:\n    # deal with tuple_data\n    ...\n    tuple_data = cursor.fetchone()\n    \n    \n# 折中的一种方法, 指定返回 size 个 tuple 结果集 组成一个 list;\n# 若 指定 size 小于 总的结果集数量, 则返回全部数据集;\n@return list[tuple(elem1, elem2, elem3 ...)]\ntuple_data_list = cursor.fetchmany(size)\n...\n```\n\n### **MySQLdb 的事务操作**\nMySQLdb 默认不会自动 commit, 所有的增删改操作都必须手动 commit 才能真正写回数据库;\n``` python\nconn = MySQLdb.connect(host='10.64.0.11', user='xxx', passwd='yyy', db=\"zzz\", port=3306, charset=\"utf8\")\nSQL = 'update xxx set yyy = zzz'\ncur = conn.cursor()\ntry:\n    cur.execute(SQL,(2,))\n    # 手动 commit 提交事务\n    conn.commit()\nexcept Exception, e:\n    # 手动回滚\n    conn.rollback()\nfinally:\n    cur.close()\n    conn.close()\n```\n\n### **参考链接**\n- [MySQLdb的安装与使用](https://www.cnblogs.com/franknihao/p/7267182.html)\n\n","source":"_posts/python-module--python_module_使用总结_MySQLdb.md","raw":"---\ntitle: 'python module 使用总结: MySQLdb'\ndate: 2017-08-01 23:06:08\ncategories:\n - python\n - module\ntags:\n - python\n - python:module\n---\n\n> `MySQLdb` 模块是 python 与 mysql 交互的较为底层的接口, 不过它依然是在更为底层的 `_mysql` 模块之上又作了一层包装;\n`_mysql` 才是真正的直接面向 mysql 原生 C 接口的简单适配层, 而 `MySQLdb` 则在 `_mysql` 之上作了更多的关于类型转换等抽象包装;\n考虑到 `MySQLdb` 模块与一些 python ORM 框架的关系, `MySQLdb` 与 python 的关系可以类比为 jdbc 之于 java;\n如果是复杂的系统, 我们肯定会选择 ORM 框架, 不过对于一些简单的小工具, 定时小任务等, 本身没什么复杂的数据库操作, 那就用 MySQLdb 最方便了;\n本文基于 `MySQL-python 1.2.5` 对 MySQLdb 作一些使用上的总结;\n\n<!--more-->\n\n------\n\n### **MySQLdb 的基本操作**\n``` python\nimport MySQLdb\n# 获得 mysql 的一个连接\nconn = MySQLdb.connect(host='10.64.0.11', user='xxx', passwd='yyy', db=\"zzz\", port=3306, charset=\"utf8\")\ntry:\n    # cursor 游标, 是 MySQLdb 中与 mysql 增删改查数据交互的对象\n    cur = conn.cursor()\n    # 数据库操作\n    cur.execute(\"...sql...\")\n    ...\n    # 提交事务\n    conn.commit()\nexcept Exception, e:\n    # 回滚\n    conn.rollback()\nfinally:\n    # 关闭连接, 释放资源\n    conn.close()\n```\n以上是一个 MySQLdb 使用的完整流程, 下面是具体的使用细节与注意点总结;\n\n### **MySQLdb cursor.execute / cursor.executemany 方法**\n#### **cursor.execute 方法**\nMySQLdb 执行数据操纵的关键点就在于 cursor.execute 方法, 所有包括增删改查在内皆是以此方法执行的, 以下是该方法的代码:\n``` python\ndef execute(self, query, args=None):\n    del self.messages[:]\n    db = self._get_db()\n    if isinstance(query, unicode):\n        query = query.encode(db.unicode_literal.charset)\n    if args is not None:\n        # 针对 args 为 dict 的特殊情况处理\n        if isinstance(args, dict):\n            query = query % dict((key, db.literal(item)) for key, item in args.iteritems())\n        # 其余的情况: args 为 tuple 或单个 value\n        else:\n            query = query % tuple([db.literal(item) for item in args])\n    try:\n        r = None\n        r = self._query(query)\n    except TypeError, m:\n        if m.args[0] in (\"not enough arguments for format string\", \"not all arguments converted\"):\n            self.messages.append((ProgrammingError, m.args[0]))\n            self.errorhandler(self, ProgrammingError, m.args[0])\n        else:\n            self.messages.append((TypeError, m)) \n            self.errorhandler(self, TypeError, m)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        exc, value, tb = sys.exc_info()\n        del tb\n        self.messages.append((exc, value))\n        self.errorhandler(self, exc, value)\n    self._executed = query\n    if not self._defer_warnings: self._warning_check()\n    return r\n```\n该方法接收一个名为 `query` 的 sql 字符串, 另外还可选附带参数 `args`, 所以该方法存在两种主要的用法:\n1.预先格式化好 sql 字符串, 然后不带参数直接 execute:\n``` python\nsql = \"select * from xxx where update_time = %s\" % datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\ncursor.execute(sql)\n```\n这种是保守的方法, 参数处理完全由 python 原生的格式化字符串完成, cursor.execute 方法只管执行 sql 就好;\n这种方法的优点是省事, 坑少;\n&nbsp;\n2.将参数传给 execute 方法的 `args`, 这种使用方法有几个坑, 需要注意一下;\n该方法有一段注释, 我单独提了出来, 注释中对 args 参数有如下描述:\n``` python\n\"\"\"\n    args -- optional sequence or mapping, parameters to use with query.\n\n    Note: If args is a sequence, then %s must be used as the\n    parameter placeholder in the query. If a mapping is used,\n    %(key)s must be used as the placeholder.\n\"\"\"\n```\n(1) 注释中提到的坑, 就是说无论传的参数是一个 list/tuple, 还是 dict, 参数占位符类型都必须是字符串(%s | %(key)s ):\n``` python\n# 不能是 id = %d, 只能是 id = %s\nsql = 'select * from xxx where id  = %s'\n```\n因为 execute 方法里处理参数时, 会对参数作 `db.literal(item)` 处理, 将参数首先转为字符串, 这时占位符如果是 %d 等其他类型, 就报错了;\n\n&nbsp;\n(2) 注释中另一个隐型的坑, 是这个 `args` 必须是 list / tuple / dict 中的一个, 哪怕只有一个占位数据, 也必须写成 list 或 tuple 类型:\n``` python\ncursor.execute(sql, (2,))\ncursor.execute(sql, [2])\n```\n如果希望以 tuple 形式表示唯一一个参数, 必须注意加上 逗号, 因为不加逗号就算外面包了括号也会识别为其本身的类型:\n``` python\n>>> print type((1))\n<type 'int'>\n>>> print type(('1'))\n<type 'str'>\n>>> print type((1,))\n<type 'tuple'>\n>>> print type(('1',))\n<type 'tuple'>\n```\n其实这个坑是在 MySQL-python 1.2.5 版本中出现的问题; 在 1.2.3 版本中, execute 方法的逻辑是这么写的:\n``` python\nif args is not None:\n    query = query % db.literal(args)\n```\n只要 args 非空, 就一律把它 to string; 而至于参数怎么转, 转成什么样, 就看参数自己了;\n这么做确实灵活了, 但是也可能带来一些不确定性, 1.2.5 的版本将参数限定为 list / tuple / dict, 然后对集合内的每个元素再针对性 to string, 一定程度上控制了参数的规范性;\n&nbsp;\n#### **cursor.executemany 方法**\nexecutemany 方法是 execute 方法的批量化, 这个方法的有效使用范围其实很狭窄, 仅针对 insert 操作有性能提升, 其余操作在性能上均与 execute 无异;\n下面是该方法的代码:\n``` python\n        del self.messages[:]\n        db = self._get_db()\n        if not args: return\n        if isinstance(query, unicode):\n            query = query.encode(db.unicode_literal.charset)\n        # 正则匹配 insert 操作\n        m = insert_values.search(query)\n        # 不是 insert 操作, 那就 for 循环挨个执行而已\n        if not m:\n            r = 0\n            for a in args:\n                r = r + self.execute(query, a)\n            return r\n        p = m.start(1)\n        e = m.end(1)\n        qv = m.group(1)\n        # 下面是针对 insert 的处理\n        try:\n            q = []\n            for a in args:\n                if isinstance(a, dict):\n                    q.append(qv % dict((key, db.literal(item))\n                                       for key, item in a.iteritems()))\n                else:\n                    q.append(qv % tuple([db.literal(item) for item in a]))\n        except TypeError, msg:\n            if msg.args[0] in (\"not enough arguments for format string\",\n                               \"not all arguments converted\"):\n                self.errorhandler(self, ProgrammingError, msg.args[0])\n            else:\n                self.errorhandler(self, TypeError, msg)\n        except (SystemExit, KeyboardInterrupt):\n            raise\n        except:\n            exc, value, tb = sys.exc_info()\n            del tb\n            self.errorhandler(self, exc, value)\n        # 批量化执行, 提高处理性能\n        r = self._query('\\n'.join([query[:p], ',\\n'.join(q), query[e:]]))\n        if not self._defer_warnings: self._warning_check()\n        return r\n```\n从代码里可以看到, 方法先对传入的 sql 语句作一次匹配, 判断其是否是 insert 操作, 其中 insert_values 是一个 regex, 专门匹配 insert 语句:\n``` python\nrestr = r\"\\svalues\\s*(\\([^()']*(?:(?:(?:\\(.*\\))|'[^\\\\']*(?:\\\\.[^\\\\']*)*')[^()']*)*\\))\"\ninsert_values = re.compile(restr, re.S | re.I | re.X)\n```\n针对 insert 语句, 其最后的执行是批量的, 以提高执行效率:\n``` python\nr = self._query('\\n'.join([query[:p], ',\\n'.join(q), query[e:]]))\n```\n但是而其他的语句, 却只能在一个 for 循环里, 挨个执行 execute 方法, 这就没什么优势了;\n不过这个方法还有一个大坑: 对于 update 和 delete 操作, 使用 executemany 至少不会比 execute 差, 但是对于 query, 它批量执行完一堆 query 操作后去 fetch 结果集, 只能拿到最后执行的 query 的结果, 前面的都被覆盖了; 所以, query 操作不能使用 executemany 方法;\n&nbsp;\n在使用方面, executemany 的坑和 execute 是差不多的, 下面是一个例子:\n``` python\n# executemany 传入的 args 可以是 list 也可以是 tuple\ncur.executemany('select * from xxx where yyy = %s', [(1,), (2,)])\n```\n\n### **MySQLdb 的 query 结果集操作**\nMySQLdb 的 query 操作, 主要有以下三种结果集的获取方法:\n``` python\ncursor.execute(\"...sql...\")\n\n# 获得所有的 tuple 结果集的一个 list\n@return list[tuple(elem1, elem2, elem3 ...)]\ntuple_data_list = cursor.fetchall()\nfor tuple_data in tuple_data_list:\n    xxx = tuple_data[0]\n    yyy = tuple_data[1]\n    ...\n    \n\n# 采用迭代器的方式, 返回当前游标所对应的 tuple 结果集, 迭代到最后方法返回 None\n@return tuple(elem1, elem2, elem3 ...)\ntuple_data = cursor.fetchone()\nwhile tuple_data:\n    # deal with tuple_data\n    ...\n    tuple_data = cursor.fetchone()\n    \n    \n# 折中的一种方法, 指定返回 size 个 tuple 结果集 组成一个 list;\n# 若 指定 size 小于 总的结果集数量, 则返回全部数据集;\n@return list[tuple(elem1, elem2, elem3 ...)]\ntuple_data_list = cursor.fetchmany(size)\n...\n```\n\n### **MySQLdb 的事务操作**\nMySQLdb 默认不会自动 commit, 所有的增删改操作都必须手动 commit 才能真正写回数据库;\n``` python\nconn = MySQLdb.connect(host='10.64.0.11', user='xxx', passwd='yyy', db=\"zzz\", port=3306, charset=\"utf8\")\nSQL = 'update xxx set yyy = zzz'\ncur = conn.cursor()\ntry:\n    cur.execute(SQL,(2,))\n    # 手动 commit 提交事务\n    conn.commit()\nexcept Exception, e:\n    # 手动回滚\n    conn.rollback()\nfinally:\n    cur.close()\n    conn.close()\n```\n\n### **参考链接**\n- [MySQLdb的安装与使用](https://www.cnblogs.com/franknihao/p/7267182.html)\n\n","slug":"python-module--python_module_使用总结_MySQLdb","published":1,"updated":"2018-03-24T07:08:03.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd67001aj1jxhb2ejdfi","content":"<blockquote>\n<p><code>MySQLdb</code> 模块是 python 与 mysql 交互的较为底层的接口, 不过它依然是在更为底层的 <code>_mysql</code> 模块之上又作了一层包装;<br><code>_mysql</code> 才是真正的直接面向 mysql 原生 C 接口的简单适配层, 而 <code>MySQLdb</code> 则在 <code>_mysql</code> 之上作了更多的关于类型转换等抽象包装;<br>考虑到 <code>MySQLdb</code> 模块与一些 python ORM 框架的关系, <code>MySQLdb</code> 与 python 的关系可以类比为 jdbc 之于 java;<br>如果是复杂的系统, 我们肯定会选择 ORM 框架, 不过对于一些简单的小工具, 定时小任务等, 本身没什么复杂的数据库操作, 那就用 MySQLdb 最方便了;<br>本文基于 <code>MySQL-python 1.2.5</code> 对 MySQLdb 作一些使用上的总结;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"MySQLdb-的基本操作\"><a href=\"#MySQLdb-的基本操作\" class=\"headerlink\" title=\"MySQLdb 的基本操作\"></a><strong>MySQLdb 的基本操作</strong></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MySQLdb</span><br><span class=\"line\"><span class=\"comment\"># 获得 mysql 的一个连接</span></span><br><span class=\"line\">conn = MySQLdb.connect(host=<span class=\"string\">'10.64.0.11'</span>, user=<span class=\"string\">'xxx'</span>, passwd=<span class=\"string\">'yyy'</span>, db=<span class=\"string\">\"zzz\"</span>, port=<span class=\"number\">3306</span>, charset=<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># cursor 游标, 是 MySQLdb 中与 mysql 增删改查数据交互的对象</span></span><br><span class=\"line\">    cur = conn.cursor()</span><br><span class=\"line\">    <span class=\"comment\"># 数据库操作</span></span><br><span class=\"line\">    cur.execute(<span class=\"string\">\"...sql...\"</span>)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\"># 提交事务</span></span><br><span class=\"line\">    conn.commit()</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">    <span class=\"comment\"># 回滚</span></span><br><span class=\"line\">    conn.rollback()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 关闭连接, 释放资源</span></span><br><span class=\"line\">    conn.close()</span><br></pre></td></tr></table></figure>\n<p>以上是一个 MySQLdb 使用的完整流程, 下面是具体的使用细节与注意点总结;</p>\n<h3 id=\"MySQLdb-cursor-execute-cursor-executemany-方法\"><a href=\"#MySQLdb-cursor-execute-cursor-executemany-方法\" class=\"headerlink\" title=\"MySQLdb cursor.execute / cursor.executemany 方法\"></a><strong>MySQLdb cursor.execute / cursor.executemany 方法</strong></h3><h4 id=\"cursor-execute-方法\"><a href=\"#cursor-execute-方法\" class=\"headerlink\" title=\"cursor.execute 方法\"></a><strong>cursor.execute 方法</strong></h4><p>MySQLdb 执行数据操纵的关键点就在于 cursor.execute 方法, 所有包括增删改查在内皆是以此方法执行的, 以下是该方法的代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">execute</span><span class=\"params\">(self, query, args=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">del</span> self.messages[:]</span><br><span class=\"line\">    db = self._get_db()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(query, unicode):</span><br><span class=\"line\">        query = query.encode(db.unicode_literal.charset)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 针对 args 为 dict 的特殊情况处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(args, dict):</span><br><span class=\"line\">            query = query % dict((key, db.literal(item)) <span class=\"keyword\">for</span> key, item <span class=\"keyword\">in</span> args.iteritems())</span><br><span class=\"line\">        <span class=\"comment\"># 其余的情况: args 为 tuple 或单个 value</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            query = query % tuple([db.literal(item) <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> args])</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = <span class=\"keyword\">None</span></span><br><span class=\"line\">        r = self._query(query)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError, m:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m.args[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> (<span class=\"string\">\"not enough arguments for format string\"</span>, <span class=\"string\">\"not all arguments converted\"</span>):</span><br><span class=\"line\">            self.messages.append((ProgrammingError, m.args[<span class=\"number\">0</span>]))</span><br><span class=\"line\">            self.errorhandler(self, ProgrammingError, m.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.messages.append((TypeError, m)) </span><br><span class=\"line\">            self.errorhandler(self, TypeError, m)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exc, value, tb = sys.exc_info()</span><br><span class=\"line\">        <span class=\"keyword\">del</span> tb</span><br><span class=\"line\">        self.messages.append((exc, value))</span><br><span class=\"line\">        self.errorhandler(self, exc, value)</span><br><span class=\"line\">    self._executed = query</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._defer_warnings: self._warning_check()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br></pre></td></tr></table></figure></p>\n<p>该方法接收一个名为 <code>query</code> 的 sql 字符串, 另外还可选附带参数 <code>args</code>, 所以该方法存在两种主要的用法:<br>1.预先格式化好 sql 字符串, 然后不带参数直接 execute:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sql = <span class=\"string\">\"select * from xxx where update_time = %s\"</span> % datetime.datetime.now().strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>)</span><br><span class=\"line\">cursor.execute(sql)</span><br></pre></td></tr></table></figure></p>\n<p>这种是保守的方法, 参数处理完全由 python 原生的格式化字符串完成, cursor.execute 方法只管执行 sql 就好;<br>这种方法的优点是省事, 坑少;<br>&nbsp;<br>2.将参数传给 execute 方法的 <code>args</code>, 这种使用方法有几个坑, 需要注意一下;<br>该方法有一段注释, 我单独提了出来, 注释中对 args 参数有如下描述:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    args -- optional sequence or mapping, parameters to use with query.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Note: If args is a sequence, then %s must be used as the</span></span><br><span class=\"line\"><span class=\"string\">    parameter placeholder in the query. If a mapping is used,</span></span><br><span class=\"line\"><span class=\"string\">    %(key)s must be used as the placeholder.</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure></p>\n<p>(1) 注释中提到的坑, 就是说无论传的参数是一个 list/tuple, 还是 dict, 参数占位符类型都必须是字符串(%s | %(key)s ):<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不能是 id = %d, 只能是 id = %s</span></span><br><span class=\"line\">sql = <span class=\"string\">'select * from xxx where id  = %s'</span></span><br></pre></td></tr></table></figure></p>\n<p>因为 execute 方法里处理参数时, 会对参数作 <code>db.literal(item)</code> 处理, 将参数首先转为字符串, 这时占位符如果是 %d 等其他类型, 就报错了;</p>\n<p>&nbsp;<br>(2) 注释中另一个隐型的坑, 是这个 <code>args</code> 必须是 list / tuple / dict 中的一个, 哪怕只有一个占位数据, 也必须写成 list 或 tuple 类型:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor.execute(sql, (<span class=\"number\">2</span>,))</span><br><span class=\"line\">cursor.execute(sql, [<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure></p>\n<p>如果希望以 tuple 形式表示唯一一个参数, 必须注意加上 逗号, 因为不加逗号就算外面包了括号也会识别为其本身的类型:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"number\">1</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"string\">'1'</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"number\">1</span>,))</span><br><span class=\"line\">&lt;type <span class=\"string\">'tuple'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"string\">'1'</span>,))</span><br><span class=\"line\">&lt;type <span class=\"string\">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>其实这个坑是在 MySQL-python 1.2.5 版本中出现的问题; 在 1.2.3 版本中, execute 方法的逻辑是这么写的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">    query = query % db.literal(args)</span><br></pre></td></tr></table></figure></p>\n<p>只要 args 非空, 就一律把它 to string; 而至于参数怎么转, 转成什么样, 就看参数自己了;<br>这么做确实灵活了, 但是也可能带来一些不确定性, 1.2.5 的版本将参数限定为 list / tuple / dict, 然后对集合内的每个元素再针对性 to string, 一定程度上控制了参数的规范性;<br>&nbsp;</p>\n<h4 id=\"cursor-executemany-方法\"><a href=\"#cursor-executemany-方法\" class=\"headerlink\" title=\"cursor.executemany 方法\"></a><strong>cursor.executemany 方法</strong></h4><p>executemany 方法是 execute 方法的批量化, 这个方法的有效使用范围其实很狭窄, 仅针对 insert 操作有性能提升, 其余操作在性能上均与 execute 无异;<br>下面是该方法的代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">del</span> self.messages[:]</span><br><span class=\"line\">db = self._get_db()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> args: <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> isinstance(query, unicode):</span><br><span class=\"line\">    query = query.encode(db.unicode_literal.charset)</span><br><span class=\"line\"><span class=\"comment\"># 正则匹配 insert 操作</span></span><br><span class=\"line\">m = insert_values.search(query)</span><br><span class=\"line\"><span class=\"comment\"># 不是 insert 操作, 那就 for 循环挨个执行而已</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> m:</span><br><span class=\"line\">    r = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        r = r + self.execute(query, a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">p = m.start(<span class=\"number\">1</span>)</span><br><span class=\"line\">e = m.end(<span class=\"number\">1</span>)</span><br><span class=\"line\">qv = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 下面是针对 insert 的处理</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(a, dict):</span><br><span class=\"line\">            q.append(qv % dict((key, db.literal(item))</span><br><span class=\"line\">                               <span class=\"keyword\">for</span> key, item <span class=\"keyword\">in</span> a.iteritems()))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            q.append(qv % tuple([db.literal(item) <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> a]))</span><br><span class=\"line\"><span class=\"keyword\">except</span> TypeError, msg:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> msg.args[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> (<span class=\"string\">\"not enough arguments for format string\"</span>,</span><br><span class=\"line\">                       <span class=\"string\">\"not all arguments converted\"</span>):</span><br><span class=\"line\">        self.errorhandler(self, ProgrammingError, msg.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.errorhandler(self, TypeError, msg)</span><br><span class=\"line\"><span class=\"keyword\">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class=\"line\">    <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    exc, value, tb = sys.exc_info()</span><br><span class=\"line\">    <span class=\"keyword\">del</span> tb</span><br><span class=\"line\">    self.errorhandler(self, exc, value)</span><br><span class=\"line\"><span class=\"comment\"># 批量化执行, 提高处理性能</span></span><br><span class=\"line\">r = self._query(<span class=\"string\">'\\n'</span>.join([query[:p], <span class=\"string\">',\\n'</span>.join(q), query[e:]]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._defer_warnings: self._warning_check()</span><br><span class=\"line\"><span class=\"keyword\">return</span> r</span><br></pre></td></tr></table></figure></p>\n<p>从代码里可以看到, 方法先对传入的 sql 语句作一次匹配, 判断其是否是 insert 操作, 其中 insert_values 是一个 regex, 专门匹配 insert 语句:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">restr = <span class=\"string\">r\"\\svalues\\s*(\\([^()']*(?:(?:(?:\\(.*\\))|'[^\\\\']*(?:\\\\.[^\\\\']*)*')[^()']*)*\\))\"</span></span><br><span class=\"line\">insert_values = re.compile(restr, re.S | re.I | re.X)</span><br></pre></td></tr></table></figure></p>\n<p>针对 insert 语句, 其最后的执行是批量的, 以提高执行效率:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = self._query(<span class=\"string\">'\\n'</span>.join([query[:p], <span class=\"string\">',\\n'</span>.join(q), query[e:]]))</span><br></pre></td></tr></table></figure></p>\n<p>但是而其他的语句, 却只能在一个 for 循环里, 挨个执行 execute 方法, 这就没什么优势了;<br>不过这个方法还有一个大坑: 对于 update 和 delete 操作, 使用 executemany 至少不会比 execute 差, 但是对于 query, 它批量执行完一堆 query 操作后去 fetch 结果集, 只能拿到最后执行的 query 的结果, 前面的都被覆盖了; 所以, query 操作不能使用 executemany 方法;<br>&nbsp;<br>在使用方面, executemany 的坑和 execute 是差不多的, 下面是一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># executemany 传入的 args 可以是 list 也可以是 tuple</span></span><br><span class=\"line\">cur.executemany(<span class=\"string\">'select * from xxx where yyy = %s'</span>, [(<span class=\"number\">1</span>,), (<span class=\"number\">2</span>,)])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MySQLdb-的-query-结果集操作\"><a href=\"#MySQLdb-的-query-结果集操作\" class=\"headerlink\" title=\"MySQLdb 的 query 结果集操作\"></a><strong>MySQLdb 的 query 结果集操作</strong></h3><p>MySQLdb 的 query 操作, 主要有以下三种结果集的获取方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor.execute(<span class=\"string\">\"...sql...\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获得所有的 tuple 结果集的一个 list</span></span><br><span class=\"line\"><span class=\"meta\">@return list[tuple(elem1, elem2, elem3 ...)]</span></span><br><span class=\"line\">tuple_data_list = cursor.fetchall()</span><br><span class=\"line\"><span class=\"keyword\">for</span> tuple_data <span class=\"keyword\">in</span> tuple_data_list:</span><br><span class=\"line\">    xxx = tuple_data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    yyy = tuple_data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 采用迭代器的方式, 返回当前游标所对应的 tuple 结果集, 迭代到最后方法返回 None</span></span><br><span class=\"line\"><span class=\"meta\">@return tuple(elem1, elem2, elem3 ...)</span></span><br><span class=\"line\">tuple_data = cursor.fetchone()</span><br><span class=\"line\"><span class=\"keyword\">while</span> tuple_data:</span><br><span class=\"line\">    <span class=\"comment\"># deal with tuple_data</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    tuple_data = cursor.fetchone()</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 折中的一种方法, 指定返回 size 个 tuple 结果集 组成一个 list;</span></span><br><span class=\"line\"><span class=\"comment\"># 若 指定 size 小于 总的结果集数量, 则返回全部数据集;</span></span><br><span class=\"line\"><span class=\"meta\">@return list[tuple(elem1, elem2, elem3 ...)]</span></span><br><span class=\"line\">tuple_data_list = cursor.fetchmany(size)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MySQLdb-的事务操作\"><a href=\"#MySQLdb-的事务操作\" class=\"headerlink\" title=\"MySQLdb 的事务操作\"></a><strong>MySQLdb 的事务操作</strong></h3><p>MySQLdb 默认不会自动 commit, 所有的增删改操作都必须手动 commit 才能真正写回数据库;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = MySQLdb.connect(host=<span class=\"string\">'10.64.0.11'</span>, user=<span class=\"string\">'xxx'</span>, passwd=<span class=\"string\">'yyy'</span>, db=<span class=\"string\">\"zzz\"</span>, port=<span class=\"number\">3306</span>, charset=<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">SQL = <span class=\"string\">'update xxx set yyy = zzz'</span></span><br><span class=\"line\">cur = conn.cursor()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    cur.execute(SQL,(<span class=\"number\">2</span>,))</span><br><span class=\"line\">    <span class=\"comment\"># 手动 commit 提交事务</span></span><br><span class=\"line\">    conn.commit()</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">    <span class=\"comment\"># 手动回滚</span></span><br><span class=\"line\">    conn.rollback()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    cur.close()</span><br><span class=\"line\">    conn.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://www.cnblogs.com/franknihao/p/7267182.html\" target=\"_blank\" rel=\"noopener\">MySQLdb的安装与使用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><code>MySQLdb</code> 模块是 python 与 mysql 交互的较为底层的接口, 不过它依然是在更为底层的 <code>_mysql</code> 模块之上又作了一层包装;<br><code>_mysql</code> 才是真正的直接面向 mysql 原生 C 接口的简单适配层, 而 <code>MySQLdb</code> 则在 <code>_mysql</code> 之上作了更多的关于类型转换等抽象包装;<br>考虑到 <code>MySQLdb</code> 模块与一些 python ORM 框架的关系, <code>MySQLdb</code> 与 python 的关系可以类比为 jdbc 之于 java;<br>如果是复杂的系统, 我们肯定会选择 ORM 框架, 不过对于一些简单的小工具, 定时小任务等, 本身没什么复杂的数据库操作, 那就用 MySQLdb 最方便了;<br>本文基于 <code>MySQL-python 1.2.5</code> 对 MySQLdb 作一些使用上的总结;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"MySQLdb-的基本操作\"><a href=\"#MySQLdb-的基本操作\" class=\"headerlink\" title=\"MySQLdb 的基本操作\"></a><strong>MySQLdb 的基本操作</strong></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MySQLdb</span><br><span class=\"line\"><span class=\"comment\"># 获得 mysql 的一个连接</span></span><br><span class=\"line\">conn = MySQLdb.connect(host=<span class=\"string\">'10.64.0.11'</span>, user=<span class=\"string\">'xxx'</span>, passwd=<span class=\"string\">'yyy'</span>, db=<span class=\"string\">\"zzz\"</span>, port=<span class=\"number\">3306</span>, charset=<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># cursor 游标, 是 MySQLdb 中与 mysql 增删改查数据交互的对象</span></span><br><span class=\"line\">    cur = conn.cursor()</span><br><span class=\"line\">    <span class=\"comment\"># 数据库操作</span></span><br><span class=\"line\">    cur.execute(<span class=\"string\">\"...sql...\"</span>)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\"># 提交事务</span></span><br><span class=\"line\">    conn.commit()</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">    <span class=\"comment\"># 回滚</span></span><br><span class=\"line\">    conn.rollback()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 关闭连接, 释放资源</span></span><br><span class=\"line\">    conn.close()</span><br></pre></td></tr></table></figure>\n<p>以上是一个 MySQLdb 使用的完整流程, 下面是具体的使用细节与注意点总结;</p>\n<h3 id=\"MySQLdb-cursor-execute-cursor-executemany-方法\"><a href=\"#MySQLdb-cursor-execute-cursor-executemany-方法\" class=\"headerlink\" title=\"MySQLdb cursor.execute / cursor.executemany 方法\"></a><strong>MySQLdb cursor.execute / cursor.executemany 方法</strong></h3><h4 id=\"cursor-execute-方法\"><a href=\"#cursor-execute-方法\" class=\"headerlink\" title=\"cursor.execute 方法\"></a><strong>cursor.execute 方法</strong></h4><p>MySQLdb 执行数据操纵的关键点就在于 cursor.execute 方法, 所有包括增删改查在内皆是以此方法执行的, 以下是该方法的代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">execute</span><span class=\"params\">(self, query, args=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">del</span> self.messages[:]</span><br><span class=\"line\">    db = self._get_db()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(query, unicode):</span><br><span class=\"line\">        query = query.encode(db.unicode_literal.charset)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 针对 args 为 dict 的特殊情况处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(args, dict):</span><br><span class=\"line\">            query = query % dict((key, db.literal(item)) <span class=\"keyword\">for</span> key, item <span class=\"keyword\">in</span> args.iteritems())</span><br><span class=\"line\">        <span class=\"comment\"># 其余的情况: args 为 tuple 或单个 value</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            query = query % tuple([db.literal(item) <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> args])</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = <span class=\"keyword\">None</span></span><br><span class=\"line\">        r = self._query(query)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError, m:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m.args[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> (<span class=\"string\">\"not enough arguments for format string\"</span>, <span class=\"string\">\"not all arguments converted\"</span>):</span><br><span class=\"line\">            self.messages.append((ProgrammingError, m.args[<span class=\"number\">0</span>]))</span><br><span class=\"line\">            self.errorhandler(self, ProgrammingError, m.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.messages.append((TypeError, m)) </span><br><span class=\"line\">            self.errorhandler(self, TypeError, m)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exc, value, tb = sys.exc_info()</span><br><span class=\"line\">        <span class=\"keyword\">del</span> tb</span><br><span class=\"line\">        self.messages.append((exc, value))</span><br><span class=\"line\">        self.errorhandler(self, exc, value)</span><br><span class=\"line\">    self._executed = query</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._defer_warnings: self._warning_check()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br></pre></td></tr></table></figure></p>\n<p>该方法接收一个名为 <code>query</code> 的 sql 字符串, 另外还可选附带参数 <code>args</code>, 所以该方法存在两种主要的用法:<br>1.预先格式化好 sql 字符串, 然后不带参数直接 execute:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sql = <span class=\"string\">\"select * from xxx where update_time = %s\"</span> % datetime.datetime.now().strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>)</span><br><span class=\"line\">cursor.execute(sql)</span><br></pre></td></tr></table></figure></p>\n<p>这种是保守的方法, 参数处理完全由 python 原生的格式化字符串完成, cursor.execute 方法只管执行 sql 就好;<br>这种方法的优点是省事, 坑少;<br>&nbsp;<br>2.将参数传给 execute 方法的 <code>args</code>, 这种使用方法有几个坑, 需要注意一下;<br>该方法有一段注释, 我单独提了出来, 注释中对 args 参数有如下描述:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    args -- optional sequence or mapping, parameters to use with query.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Note: If args is a sequence, then %s must be used as the</span></span><br><span class=\"line\"><span class=\"string\">    parameter placeholder in the query. If a mapping is used,</span></span><br><span class=\"line\"><span class=\"string\">    %(key)s must be used as the placeholder.</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure></p>\n<p>(1) 注释中提到的坑, 就是说无论传的参数是一个 list/tuple, 还是 dict, 参数占位符类型都必须是字符串(%s | %(key)s ):<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不能是 id = %d, 只能是 id = %s</span></span><br><span class=\"line\">sql = <span class=\"string\">'select * from xxx where id  = %s'</span></span><br></pre></td></tr></table></figure></p>\n<p>因为 execute 方法里处理参数时, 会对参数作 <code>db.literal(item)</code> 处理, 将参数首先转为字符串, 这时占位符如果是 %d 等其他类型, 就报错了;</p>\n<p>&nbsp;<br>(2) 注释中另一个隐型的坑, 是这个 <code>args</code> 必须是 list / tuple / dict 中的一个, 哪怕只有一个占位数据, 也必须写成 list 或 tuple 类型:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor.execute(sql, (<span class=\"number\">2</span>,))</span><br><span class=\"line\">cursor.execute(sql, [<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure></p>\n<p>如果希望以 tuple 形式表示唯一一个参数, 必须注意加上 逗号, 因为不加逗号就算外面包了括号也会识别为其本身的类型:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"number\">1</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"string\">'1'</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"number\">1</span>,))</span><br><span class=\"line\">&lt;type <span class=\"string\">'tuple'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> type((<span class=\"string\">'1'</span>,))</span><br><span class=\"line\">&lt;type <span class=\"string\">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<p>其实这个坑是在 MySQL-python 1.2.5 版本中出现的问题; 在 1.2.3 版本中, execute 方法的逻辑是这么写的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">    query = query % db.literal(args)</span><br></pre></td></tr></table></figure></p>\n<p>只要 args 非空, 就一律把它 to string; 而至于参数怎么转, 转成什么样, 就看参数自己了;<br>这么做确实灵活了, 但是也可能带来一些不确定性, 1.2.5 的版本将参数限定为 list / tuple / dict, 然后对集合内的每个元素再针对性 to string, 一定程度上控制了参数的规范性;<br>&nbsp;</p>\n<h4 id=\"cursor-executemany-方法\"><a href=\"#cursor-executemany-方法\" class=\"headerlink\" title=\"cursor.executemany 方法\"></a><strong>cursor.executemany 方法</strong></h4><p>executemany 方法是 execute 方法的批量化, 这个方法的有效使用范围其实很狭窄, 仅针对 insert 操作有性能提升, 其余操作在性能上均与 execute 无异;<br>下面是该方法的代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">del</span> self.messages[:]</span><br><span class=\"line\">db = self._get_db()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> args: <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> isinstance(query, unicode):</span><br><span class=\"line\">    query = query.encode(db.unicode_literal.charset)</span><br><span class=\"line\"><span class=\"comment\"># 正则匹配 insert 操作</span></span><br><span class=\"line\">m = insert_values.search(query)</span><br><span class=\"line\"><span class=\"comment\"># 不是 insert 操作, 那就 for 循环挨个执行而已</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> m:</span><br><span class=\"line\">    r = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        r = r + self.execute(query, a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">p = m.start(<span class=\"number\">1</span>)</span><br><span class=\"line\">e = m.end(<span class=\"number\">1</span>)</span><br><span class=\"line\">qv = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 下面是针对 insert 的处理</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(a, dict):</span><br><span class=\"line\">            q.append(qv % dict((key, db.literal(item))</span><br><span class=\"line\">                               <span class=\"keyword\">for</span> key, item <span class=\"keyword\">in</span> a.iteritems()))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            q.append(qv % tuple([db.literal(item) <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> a]))</span><br><span class=\"line\"><span class=\"keyword\">except</span> TypeError, msg:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> msg.args[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> (<span class=\"string\">\"not enough arguments for format string\"</span>,</span><br><span class=\"line\">                       <span class=\"string\">\"not all arguments converted\"</span>):</span><br><span class=\"line\">        self.errorhandler(self, ProgrammingError, msg.args[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.errorhandler(self, TypeError, msg)</span><br><span class=\"line\"><span class=\"keyword\">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class=\"line\">    <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    exc, value, tb = sys.exc_info()</span><br><span class=\"line\">    <span class=\"keyword\">del</span> tb</span><br><span class=\"line\">    self.errorhandler(self, exc, value)</span><br><span class=\"line\"><span class=\"comment\"># 批量化执行, 提高处理性能</span></span><br><span class=\"line\">r = self._query(<span class=\"string\">'\\n'</span>.join([query[:p], <span class=\"string\">',\\n'</span>.join(q), query[e:]]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._defer_warnings: self._warning_check()</span><br><span class=\"line\"><span class=\"keyword\">return</span> r</span><br></pre></td></tr></table></figure></p>\n<p>从代码里可以看到, 方法先对传入的 sql 语句作一次匹配, 判断其是否是 insert 操作, 其中 insert_values 是一个 regex, 专门匹配 insert 语句:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">restr = <span class=\"string\">r\"\\svalues\\s*(\\([^()']*(?:(?:(?:\\(.*\\))|'[^\\\\']*(?:\\\\.[^\\\\']*)*')[^()']*)*\\))\"</span></span><br><span class=\"line\">insert_values = re.compile(restr, re.S | re.I | re.X)</span><br></pre></td></tr></table></figure></p>\n<p>针对 insert 语句, 其最后的执行是批量的, 以提高执行效率:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = self._query(<span class=\"string\">'\\n'</span>.join([query[:p], <span class=\"string\">',\\n'</span>.join(q), query[e:]]))</span><br></pre></td></tr></table></figure></p>\n<p>但是而其他的语句, 却只能在一个 for 循环里, 挨个执行 execute 方法, 这就没什么优势了;<br>不过这个方法还有一个大坑: 对于 update 和 delete 操作, 使用 executemany 至少不会比 execute 差, 但是对于 query, 它批量执行完一堆 query 操作后去 fetch 结果集, 只能拿到最后执行的 query 的结果, 前面的都被覆盖了; 所以, query 操作不能使用 executemany 方法;<br>&nbsp;<br>在使用方面, executemany 的坑和 execute 是差不多的, 下面是一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># executemany 传入的 args 可以是 list 也可以是 tuple</span></span><br><span class=\"line\">cur.executemany(<span class=\"string\">'select * from xxx where yyy = %s'</span>, [(<span class=\"number\">1</span>,), (<span class=\"number\">2</span>,)])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MySQLdb-的-query-结果集操作\"><a href=\"#MySQLdb-的-query-结果集操作\" class=\"headerlink\" title=\"MySQLdb 的 query 结果集操作\"></a><strong>MySQLdb 的 query 结果集操作</strong></h3><p>MySQLdb 的 query 操作, 主要有以下三种结果集的获取方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor.execute(<span class=\"string\">\"...sql...\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获得所有的 tuple 结果集的一个 list</span></span><br><span class=\"line\"><span class=\"meta\">@return list[tuple(elem1, elem2, elem3 ...)]</span></span><br><span class=\"line\">tuple_data_list = cursor.fetchall()</span><br><span class=\"line\"><span class=\"keyword\">for</span> tuple_data <span class=\"keyword\">in</span> tuple_data_list:</span><br><span class=\"line\">    xxx = tuple_data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    yyy = tuple_data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 采用迭代器的方式, 返回当前游标所对应的 tuple 结果集, 迭代到最后方法返回 None</span></span><br><span class=\"line\"><span class=\"meta\">@return tuple(elem1, elem2, elem3 ...)</span></span><br><span class=\"line\">tuple_data = cursor.fetchone()</span><br><span class=\"line\"><span class=\"keyword\">while</span> tuple_data:</span><br><span class=\"line\">    <span class=\"comment\"># deal with tuple_data</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    tuple_data = cursor.fetchone()</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 折中的一种方法, 指定返回 size 个 tuple 结果集 组成一个 list;</span></span><br><span class=\"line\"><span class=\"comment\"># 若 指定 size 小于 总的结果集数量, 则返回全部数据集;</span></span><br><span class=\"line\"><span class=\"meta\">@return list[tuple(elem1, elem2, elem3 ...)]</span></span><br><span class=\"line\">tuple_data_list = cursor.fetchmany(size)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MySQLdb-的事务操作\"><a href=\"#MySQLdb-的事务操作\" class=\"headerlink\" title=\"MySQLdb 的事务操作\"></a><strong>MySQLdb 的事务操作</strong></h3><p>MySQLdb 默认不会自动 commit, 所有的增删改操作都必须手动 commit 才能真正写回数据库;<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = MySQLdb.connect(host=<span class=\"string\">'10.64.0.11'</span>, user=<span class=\"string\">'xxx'</span>, passwd=<span class=\"string\">'yyy'</span>, db=<span class=\"string\">\"zzz\"</span>, port=<span class=\"number\">3306</span>, charset=<span class=\"string\">\"utf8\"</span>)</span><br><span class=\"line\">SQL = <span class=\"string\">'update xxx set yyy = zzz'</span></span><br><span class=\"line\">cur = conn.cursor()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    cur.execute(SQL,(<span class=\"number\">2</span>,))</span><br><span class=\"line\">    <span class=\"comment\"># 手动 commit 提交事务</span></span><br><span class=\"line\">    conn.commit()</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">    <span class=\"comment\"># 手动回滚</span></span><br><span class=\"line\">    conn.rollback()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    cur.close()</span><br><span class=\"line\">    conn.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://www.cnblogs.com/franknihao/p/7267182.html\" target=\"_blank\" rel=\"noopener\">MySQLdb的安装与使用</a></li>\n</ul>"},{"title":"JsonUtil 类 cheat sheet","date":"2016-08-11T07:01:17.000Z","_content":"\n> 在日常工作中, json 的序列化/反序列化 是最频繁使用的动作; 拥有一个封装良好的 json 工具包能极大得提高工作效率;\n本文的目的是总结日常工作经验, 并将其作为一个 cheat sheet, 在某些项目环境中, 方便快速获取;\njackson 是 java 世界里主流的 json 序列化/反序列化 框架, 本文所涉及的 json 工具类正是基于 jackson 实现的;\n\n<!--more-->\n\n------\n\n首先要说的是, 本文不作过多关于 jackson 框架的描述, 其性质更偏向于 cheat sheet; 关于 jackson 及其使用方面的问题, 请参见另一篇文章: [对 jackson 浅层次的概念整理]();\n\n### **相关的 maven 配置**\njackson-databind, jackson-core, jackson-annotations, 这三个构件对大部分人来说, 都是相当熟悉的: 但凡在工程内引 jackson 必定会引它们三个;\n这里比较特殊的是第四个构件: jackson-datatype-joda; 这是 jackson 官方提供的针对 joda time 各种类 序列化/反序列化 的一个 'add-on module';\n在 [Group: FasterXML Jackson Datatype](http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype) 中有各种各样 jackson 官方提供的针对各个 organization 的插件, 包括了 guava, hibernate, 以及 joda time; 其他的插件在我日常的工作中很少使用, 而 joda time 由于其极高的使用频率, jackson-datatype-joda 也自然成为了 jackson 拓展模块中的使用常客;\n``` xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-annotations</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n</dependency>\n<!-- joda time 的拓展模块 -->\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-joda</artifactId>\n</dependency>\n```\n这里有一点需要注意的是, jackson-datatype-joda 的最低版本是 2.0.0;\n\n### **JsonUtil 类代码**\n本类在 static 代码块中设置了各种常用的 jackson 选项, 包括 JsonParser, SerializationFeature, DeserializationFeature, JsonInclude 等; 所有的选项上方都写明了注释, 以方便在使用时针对不同的场景作定制化的修改;\n另外有一点需要补充说明的是, 该 static 代码各配置项虽加上了注释, 但并未说明为何需要设置此选项; 相关的详细说明请参见本站另一篇文章: [jackson 常用配置选项梳理](http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理);\n``` java\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.datatype.joda.JodaModule;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 针对 jackson 的工具封装类:\n * (1) 预设了 Jackson 常用的各种 Feature 选项;\n * (2) 封装了针对 normal object 的 ser / deser 方法;\n * (3) 封装了针对 List, Map 的常用 deser 情景;\n */\npublic class JsonUtil {\n\n    private final static Logger logger = LoggerFactory.getLogger(JsonUtil.class);\n\n    private final static ObjectMapper objectMapper = new ObjectMapper();\n    \n    // 常用的 Feature 设置\n    static {\n        /* json 解析相关选项 */\n\n        // 允许 json 存在形如 // 或 /**/ 的注释\n        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n        // 允许 json 存在没用引号括起来的 field\n        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        // 允许 json 存在使用单引号括起来的 field\n        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n        // 允许 json 存在没用引号括起来的 ascii 控制字符\n        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n        // 允许 json number 类型的数存在前导 0 (like: 0001)\n        objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n        // 允许 json 存在 NaN, INF, -INF 作为 number 类型\n        objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n\n        /* json 序列化与反序列化的行为设置 */\n\n        // 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错\n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n        // 序列化时, 禁止自动缩进 (格式化) 输出的 json\n        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, false);\n        // 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示\n        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true);\n        // 序列化时, map, list 中的 null 值也要参与序列化\n        objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, true);\n        \n        // 反序列化时, 忽略未知的字段\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n        /* 字段的 include 设置 */\n\n        // 所有实例中的空字段都要参与序列化\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\n        // 所有实例中的 null 字段都要参与序列化\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n\n        /* jackson 模块拓展 */\n        \n        // 针对 joda time 定制的 ser/deser 模块\n        objectMapper.registerModule(new JodaModule());\n    }\n\n    /* normal object */\n    \n    public static String encode(Object object) {\n        try {\n            return objectMapper.writeValueAsString(object);\n        } catch (IOException e) {\n            logger.error(\"jackson encode error, obj = {}\", object, e);\n            return \"jackson encode error\";\n        }\n    }\n\n    public static <T> T decode(String json, Class<T> valueType) {\n        try {\n            return objectMapper.readValue(json, valueType);\n        } catch (Exception e) {\n            logger.error(\"jackson decode error, json = {}, class = {}\", json, valueType.getName(), e);\n            return null;\n        }\n    }\n\n    public static JsonNode readTree(String json) throws IOException {\n        try {\n            return objectMapper.readTree(json);\n        } catch (IOException e) {\n            logger.error(\"jackson readTree error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    /* decode list */\n\n    // 方法1, 适用于已知泛型类型 T 的情况\n    public static <T> List<T> decodeList(String json) throws IOException {\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<T>>() {\n            });\n        } catch (IOException e) {\n            logger.error(\"jackson decodeList(String) error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    // 方法2, 适用于泛型类型未知的通用情况\n    public static <T> List<T> decodeList(String json, Class<T> clazz) throws IOException {\n        try {\n            return objectMapper.readValue(json, objectMapper.getTypeFactory()\n                    .constructCollectionType(List.class, clazz));\n        } catch (IOException e) {\n            logger.error(\"jackson decodeList(String, Class<T>) error, json = {}, class = {}\",\n                    json, clazz.getName(), e);\n            return null;\n        }\n    }\n\n    /* decode map */\n\n    // 方法1, 适用于已知泛型类型 <K, V> 的情况\n    public static <K, V> Map<K, V> decodeMap(String json) throws IOException {\n        try {\n            return objectMapper.readValue(json, new TypeReference<Map<K, V>>() {\n            });\n        } catch (IOException e) {\n            logger.error(\"jackson decodeMap(String) error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    // 方法2, 使用于泛型类型未知的通用情况\n    public static <K, V> Map<K, V> decodeMap(String json, Class<K> key, Class<V> value) throws IOException {\n        try {\n            return objectMapper.readValue(json, objectMapper.getTypeFactory()\n                    .constructMapType(Map.class, key, value));\n        } catch (IOException e) {\n            logger.error(\"jackson decodeMap(String, Class<K>, Class<V>) error, json = {}, key = {}, \" +\n                    \"value = {}\", json, key.getName(), value.getName(), e);\n            return null;\n        }\n    }\n\n}\n```\n\n### **站内相关文章**\n- [对 jackson 浅层次的概念整理]()\n- [jackson 常用配置选项梳理](http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理)\n\n### **参考链接**\n- [How to serialize Joda DateTime with Jackson JSON processer](https://stackoverflow.com/questions/3269459/how-to-serialize-joda-datetime-with-jackson-json-processer)\n- [Group: FasterXML Jackson Datatype](http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype)\n\n","source":"_posts/ser_deser-jackson--JsonUtil类cheat_sheet.md","raw":"---\ntitle: JsonUtil 类 cheat sheet\ndate: 2016-08-11 15:01:17\ncategories:\n - ser/deser\n - jackson\ntags:\n - jackson\n - cheat sheet\n - json\n---\n\n> 在日常工作中, json 的序列化/反序列化 是最频繁使用的动作; 拥有一个封装良好的 json 工具包能极大得提高工作效率;\n本文的目的是总结日常工作经验, 并将其作为一个 cheat sheet, 在某些项目环境中, 方便快速获取;\njackson 是 java 世界里主流的 json 序列化/反序列化 框架, 本文所涉及的 json 工具类正是基于 jackson 实现的;\n\n<!--more-->\n\n------\n\n首先要说的是, 本文不作过多关于 jackson 框架的描述, 其性质更偏向于 cheat sheet; 关于 jackson 及其使用方面的问题, 请参见另一篇文章: [对 jackson 浅层次的概念整理]();\n\n### **相关的 maven 配置**\njackson-databind, jackson-core, jackson-annotations, 这三个构件对大部分人来说, 都是相当熟悉的: 但凡在工程内引 jackson 必定会引它们三个;\n这里比较特殊的是第四个构件: jackson-datatype-joda; 这是 jackson 官方提供的针对 joda time 各种类 序列化/反序列化 的一个 'add-on module';\n在 [Group: FasterXML Jackson Datatype](http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype) 中有各种各样 jackson 官方提供的针对各个 organization 的插件, 包括了 guava, hibernate, 以及 joda time; 其他的插件在我日常的工作中很少使用, 而 joda time 由于其极高的使用频率, jackson-datatype-joda 也自然成为了 jackson 拓展模块中的使用常客;\n``` xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-annotations</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n</dependency>\n<!-- joda time 的拓展模块 -->\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-joda</artifactId>\n</dependency>\n```\n这里有一点需要注意的是, jackson-datatype-joda 的最低版本是 2.0.0;\n\n### **JsonUtil 类代码**\n本类在 static 代码块中设置了各种常用的 jackson 选项, 包括 JsonParser, SerializationFeature, DeserializationFeature, JsonInclude 等; 所有的选项上方都写明了注释, 以方便在使用时针对不同的场景作定制化的修改;\n另外有一点需要补充说明的是, 该 static 代码各配置项虽加上了注释, 但并未说明为何需要设置此选项; 相关的详细说明请参见本站另一篇文章: [jackson 常用配置选项梳理](http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理);\n``` java\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.datatype.joda.JodaModule;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 针对 jackson 的工具封装类:\n * (1) 预设了 Jackson 常用的各种 Feature 选项;\n * (2) 封装了针对 normal object 的 ser / deser 方法;\n * (3) 封装了针对 List, Map 的常用 deser 情景;\n */\npublic class JsonUtil {\n\n    private final static Logger logger = LoggerFactory.getLogger(JsonUtil.class);\n\n    private final static ObjectMapper objectMapper = new ObjectMapper();\n    \n    // 常用的 Feature 设置\n    static {\n        /* json 解析相关选项 */\n\n        // 允许 json 存在形如 // 或 /**/ 的注释\n        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n        // 允许 json 存在没用引号括起来的 field\n        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        // 允许 json 存在使用单引号括起来的 field\n        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n        // 允许 json 存在没用引号括起来的 ascii 控制字符\n        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n        // 允许 json number 类型的数存在前导 0 (like: 0001)\n        objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n        // 允许 json 存在 NaN, INF, -INF 作为 number 类型\n        objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n\n        /* json 序列化与反序列化的行为设置 */\n\n        // 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错\n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n        // 序列化时, 禁止自动缩进 (格式化) 输出的 json\n        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, false);\n        // 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示\n        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true);\n        // 序列化时, map, list 中的 null 值也要参与序列化\n        objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, true);\n        \n        // 反序列化时, 忽略未知的字段\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n        /* 字段的 include 设置 */\n\n        // 所有实例中的空字段都要参与序列化\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\n        // 所有实例中的 null 字段都要参与序列化\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n\n        /* jackson 模块拓展 */\n        \n        // 针对 joda time 定制的 ser/deser 模块\n        objectMapper.registerModule(new JodaModule());\n    }\n\n    /* normal object */\n    \n    public static String encode(Object object) {\n        try {\n            return objectMapper.writeValueAsString(object);\n        } catch (IOException e) {\n            logger.error(\"jackson encode error, obj = {}\", object, e);\n            return \"jackson encode error\";\n        }\n    }\n\n    public static <T> T decode(String json, Class<T> valueType) {\n        try {\n            return objectMapper.readValue(json, valueType);\n        } catch (Exception e) {\n            logger.error(\"jackson decode error, json = {}, class = {}\", json, valueType.getName(), e);\n            return null;\n        }\n    }\n\n    public static JsonNode readTree(String json) throws IOException {\n        try {\n            return objectMapper.readTree(json);\n        } catch (IOException e) {\n            logger.error(\"jackson readTree error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    /* decode list */\n\n    // 方法1, 适用于已知泛型类型 T 的情况\n    public static <T> List<T> decodeList(String json) throws IOException {\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<T>>() {\n            });\n        } catch (IOException e) {\n            logger.error(\"jackson decodeList(String) error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    // 方法2, 适用于泛型类型未知的通用情况\n    public static <T> List<T> decodeList(String json, Class<T> clazz) throws IOException {\n        try {\n            return objectMapper.readValue(json, objectMapper.getTypeFactory()\n                    .constructCollectionType(List.class, clazz));\n        } catch (IOException e) {\n            logger.error(\"jackson decodeList(String, Class<T>) error, json = {}, class = {}\",\n                    json, clazz.getName(), e);\n            return null;\n        }\n    }\n\n    /* decode map */\n\n    // 方法1, 适用于已知泛型类型 <K, V> 的情况\n    public static <K, V> Map<K, V> decodeMap(String json) throws IOException {\n        try {\n            return objectMapper.readValue(json, new TypeReference<Map<K, V>>() {\n            });\n        } catch (IOException e) {\n            logger.error(\"jackson decodeMap(String) error, json = {}\", json, e);\n            return null;\n        }\n    }\n\n    // 方法2, 使用于泛型类型未知的通用情况\n    public static <K, V> Map<K, V> decodeMap(String json, Class<K> key, Class<V> value) throws IOException {\n        try {\n            return objectMapper.readValue(json, objectMapper.getTypeFactory()\n                    .constructMapType(Map.class, key, value));\n        } catch (IOException e) {\n            logger.error(\"jackson decodeMap(String, Class<K>, Class<V>) error, json = {}, key = {}, \" +\n                    \"value = {}\", json, key.getName(), value.getName(), e);\n            return null;\n        }\n    }\n\n}\n```\n\n### **站内相关文章**\n- [对 jackson 浅层次的概念整理]()\n- [jackson 常用配置选项梳理](http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理)\n\n### **参考链接**\n- [How to serialize Joda DateTime with Jackson JSON processer](https://stackoverflow.com/questions/3269459/how-to-serialize-joda-datetime-with-jackson-json-processer)\n- [Group: FasterXML Jackson Datatype](http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype)\n\n","slug":"ser_deser-jackson--JsonUtil类cheat_sheet","published":1,"updated":"2018-05-01T08:10:18.477Z","_id":"cjgndpd68001bj1jx6nx1e0wq","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在日常工作中, json 的序列化/反序列化 是最频繁使用的动作; 拥有一个封装良好的 json 工具包能极大得提高工作效率;<br>本文的目的是总结日常工作经验, 并将其作为一个 cheat sheet, 在某些项目环境中, 方便快速获取;<br>jackson 是 java 世界里主流的 json 序列化/反序列化 框架, 本文所涉及的 json 工具类正是基于 jackson 实现的;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<p>首先要说的是, 本文不作过多关于 jackson 框架的描述, 其性质更偏向于 cheat sheet; 关于 jackson 及其使用方面的问题, 请参见另一篇文章: <a href=\"\">对 jackson 浅层次的概念整理</a>;</p>\n<h3 id=\"相关的-maven-配置\"><a href=\"#相关的-maven-配置\" class=\"headerlink\" title=\"相关的 maven 配置\"></a><strong>相关的 maven 配置</strong></h3><p>jackson-databind, jackson-core, jackson-annotations, 这三个构件对大部分人来说, 都是相当熟悉的: 但凡在工程内引 jackson 必定会引它们三个;<br>这里比较特殊的是第四个构件: jackson-datatype-joda; 这是 jackson 官方提供的针对 joda time 各种类 序列化/反序列化 的一个 ‘add-on module’;<br>在 <a href=\"http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype\" target=\"_blank\" rel=\"noopener\">Group: FasterXML Jackson Datatype</a> 中有各种各样 jackson 官方提供的针对各个 organization 的插件, 包括了 guava, hibernate, 以及 joda time; 其他的插件在我日常的工作中很少使用, 而 joda time 由于其极高的使用频率, jackson-datatype-joda 也自然成为了 jackson 拓展模块中的使用常客;<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-annotations<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- joda time 的拓展模块 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-datatype-joda<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有一点需要注意的是, jackson-datatype-joda 的最低版本是 2.0.0;</p>\n<h3 id=\"JsonUtil-类代码\"><a href=\"#JsonUtil-类代码\" class=\"headerlink\" title=\"JsonUtil 类代码\"></a><strong>JsonUtil 类代码</strong></h3><p>本类在 static 代码块中设置了各种常用的 jackson 选项, 包括 JsonParser, SerializationFeature, DeserializationFeature, JsonInclude 等; 所有的选项上方都写明了注释, 以方便在使用时针对不同的场景作定制化的修改;<br>另外有一点需要补充说明的是, 该 static 代码各配置项虽加上了注释, 但并未说明为何需要设置此选项; 相关的详细说明请参见本站另一篇文章: <a href=\"http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理\">jackson 常用配置选项梳理</a>;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.datatype.joda.JodaModule;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 针对 jackson 的工具封装类:</span></span><br><span class=\"line\"><span class=\"comment\"> * (1) 预设了 Jackson 常用的各种 Feature 选项;</span></span><br><span class=\"line\"><span class=\"comment\"> * (2) 封装了针对 normal object 的 ser / deser 方法;</span></span><br><span class=\"line\"><span class=\"comment\"> * (3) 封装了针对 List, Map 的常用 deser 情景;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger logger = LoggerFactory.getLogger(JsonUtil.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> ObjectMapper objectMapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 常用的 Feature 设置</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* json 解析相关选项 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在形如 // 或 /**/ 的注释</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在没用引号括起来的 field</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在使用单引号括起来的 field</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在没用引号括起来的 ascii 控制字符</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json number 类型的数存在前导 0 (like: 0001)</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在 NaN, INF, -INF 作为 number 类型</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* json 序列化与反序列化的行为设置 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 禁止自动缩进 (格式化) 输出的 json</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, map, list 中的 null 值也要参与序列化</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 反序列化时, 忽略未知的字段</span></span><br><span class=\"line\">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 字段的 include 设置 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有实例中的空字段都要参与序列化</span></span><br><span class=\"line\">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class=\"line\">        <span class=\"comment\">// 所有实例中的 null 字段都要参与序列化</span></span><br><span class=\"line\">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* jackson 模块拓展 */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 针对 joda time 定制的 ser/deser 模块</span></span><br><span class=\"line\">        objectMapper.registerModule(<span class=\"keyword\">new</span> JodaModule());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* normal object */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">encode</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.writeValueAsString(object);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson encode error, obj = &#123;&#125;\"</span>, object, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"jackson encode error\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">decode</span><span class=\"params\">(String json, Class&lt;T&gt; valueType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, valueType);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decode error, json = &#123;&#125;, class = &#123;&#125;\"</span>, json, valueType.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonNode <span class=\"title\">readTree</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readTree(json);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson readTree error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* decode list */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法1, 适用于已知泛型类型 T 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">decodeList</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeList(String) error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法2, 适用于泛型类型未知的通用情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">decodeList</span><span class=\"params\">(String json, Class&lt;T&gt; clazz)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, objectMapper.getTypeFactory()</span><br><span class=\"line\">                    .constructCollectionType(List.class, clazz));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeList(String, Class&lt;T&gt;) error, json = &#123;&#125;, class = &#123;&#125;\"</span>,</span><br><span class=\"line\">                    json, clazz.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* decode map */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法1, 适用于已知泛型类型 &lt;K, V&gt; 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; <span class=\"function\">Map&lt;K, V&gt; <span class=\"title\">decodeMap</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, <span class=\"keyword\">new</span> TypeReference&lt;Map&lt;K, V&gt;&gt;() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeMap(String) error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法2, 使用于泛型类型未知的通用情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; <span class=\"function\">Map&lt;K, V&gt; <span class=\"title\">decodeMap</span><span class=\"params\">(String json, Class&lt;K&gt; key, Class&lt;V&gt; value)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, objectMapper.getTypeFactory()</span><br><span class=\"line\">                    .constructMapType(Map.class, key, value));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeMap(String, Class&lt;K&gt;, Class&lt;V&gt;) error, json = &#123;&#125;, key = &#123;&#125;, \"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"value = &#123;&#125;\"</span>, json, key.getName(), value.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">对 jackson 浅层次的概念整理</a></li>\n<li><a href=\"http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理\">jackson 常用配置选项梳理</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/3269459/how-to-serialize-joda-datetime-with-jackson-json-processer\" target=\"_blank\" rel=\"noopener\">How to serialize Joda DateTime with Jackson JSON processer</a></li>\n<li><a href=\"http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype\" target=\"_blank\" rel=\"noopener\">Group: FasterXML Jackson Datatype</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在日常工作中, json 的序列化/反序列化 是最频繁使用的动作; 拥有一个封装良好的 json 工具包能极大得提高工作效率;<br>本文的目的是总结日常工作经验, 并将其作为一个 cheat sheet, 在某些项目环境中, 方便快速获取;<br>jackson 是 java 世界里主流的 json 序列化/反序列化 框架, 本文所涉及的 json 工具类正是基于 jackson 实现的;</p>\n</blockquote>","more":"<hr>\n<p>首先要说的是, 本文不作过多关于 jackson 框架的描述, 其性质更偏向于 cheat sheet; 关于 jackson 及其使用方面的问题, 请参见另一篇文章: <a href=\"\">对 jackson 浅层次的概念整理</a>;</p>\n<h3 id=\"相关的-maven-配置\"><a href=\"#相关的-maven-配置\" class=\"headerlink\" title=\"相关的 maven 配置\"></a><strong>相关的 maven 配置</strong></h3><p>jackson-databind, jackson-core, jackson-annotations, 这三个构件对大部分人来说, 都是相当熟悉的: 但凡在工程内引 jackson 必定会引它们三个;<br>这里比较特殊的是第四个构件: jackson-datatype-joda; 这是 jackson 官方提供的针对 joda time 各种类 序列化/反序列化 的一个 ‘add-on module’;<br>在 <a href=\"http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype\" target=\"_blank\" rel=\"noopener\">Group: FasterXML Jackson Datatype</a> 中有各种各样 jackson 官方提供的针对各个 organization 的插件, 包括了 guava, hibernate, 以及 joda time; 其他的插件在我日常的工作中很少使用, 而 joda time 由于其极高的使用频率, jackson-datatype-joda 也自然成为了 jackson 拓展模块中的使用常客;<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-annotations<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- joda time 的拓展模块 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-datatype-joda<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有一点需要注意的是, jackson-datatype-joda 的最低版本是 2.0.0;</p>\n<h3 id=\"JsonUtil-类代码\"><a href=\"#JsonUtil-类代码\" class=\"headerlink\" title=\"JsonUtil 类代码\"></a><strong>JsonUtil 类代码</strong></h3><p>本类在 static 代码块中设置了各种常用的 jackson 选项, 包括 JsonParser, SerializationFeature, DeserializationFeature, JsonInclude 等; 所有的选项上方都写明了注释, 以方便在使用时针对不同的场景作定制化的修改;<br>另外有一点需要补充说明的是, 该 static 代码各配置项虽加上了注释, 但并未说明为何需要设置此选项; 相关的详细说明请参见本站另一篇文章: <a href=\"http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理\">jackson 常用配置选项梳理</a>;<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.datatype.joda.JodaModule;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 针对 jackson 的工具封装类:</span></span><br><span class=\"line\"><span class=\"comment\"> * (1) 预设了 Jackson 常用的各种 Feature 选项;</span></span><br><span class=\"line\"><span class=\"comment\"> * (2) 封装了针对 normal object 的 ser / deser 方法;</span></span><br><span class=\"line\"><span class=\"comment\"> * (3) 封装了针对 List, Map 的常用 deser 情景;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger logger = LoggerFactory.getLogger(JsonUtil.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> ObjectMapper objectMapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 常用的 Feature 设置</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* json 解析相关选项 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在形如 // 或 /**/ 的注释</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在没用引号括起来的 field</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在使用单引号括起来的 field</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在没用引号括起来的 ascii 控制字符</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json number 类型的数存在前导 0 (like: 0001)</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许 json 存在 NaN, INF, -INF 作为 number 类型</span></span><br><span class=\"line\">        objectMapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* json 序列化与反序列化的行为设置 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 对于没有任何 public methods / properties 的类, 序列化不报错</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 禁止自动缩进 (格式化) 输出的 json</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, 将各种时间日期类型统一序列化为 timestamp 而不是其字符串表示</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化时, map, list 中的 null 值也要参与序列化</span></span><br><span class=\"line\">        objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 反序列化时, 忽略未知的字段</span></span><br><span class=\"line\">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 字段的 include 设置 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有实例中的空字段都要参与序列化</span></span><br><span class=\"line\">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class=\"line\">        <span class=\"comment\">// 所有实例中的 null 字段都要参与序列化</span></span><br><span class=\"line\">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* jackson 模块拓展 */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 针对 joda time 定制的 ser/deser 模块</span></span><br><span class=\"line\">        objectMapper.registerModule(<span class=\"keyword\">new</span> JodaModule());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* normal object */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">encode</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.writeValueAsString(object);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson encode error, obj = &#123;&#125;\"</span>, object, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"jackson encode error\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">decode</span><span class=\"params\">(String json, Class&lt;T&gt; valueType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, valueType);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decode error, json = &#123;&#125;, class = &#123;&#125;\"</span>, json, valueType.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonNode <span class=\"title\">readTree</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readTree(json);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson readTree error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* decode list */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法1, 适用于已知泛型类型 T 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">decodeList</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeList(String) error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法2, 适用于泛型类型未知的通用情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">decodeList</span><span class=\"params\">(String json, Class&lt;T&gt; clazz)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, objectMapper.getTypeFactory()</span><br><span class=\"line\">                    .constructCollectionType(List.class, clazz));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeList(String, Class&lt;T&gt;) error, json = &#123;&#125;, class = &#123;&#125;\"</span>,</span><br><span class=\"line\">                    json, clazz.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* decode map */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法1, 适用于已知泛型类型 &lt;K, V&gt; 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; <span class=\"function\">Map&lt;K, V&gt; <span class=\"title\">decodeMap</span><span class=\"params\">(String json)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, <span class=\"keyword\">new</span> TypeReference&lt;Map&lt;K, V&gt;&gt;() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeMap(String) error, json = &#123;&#125;\"</span>, json, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法2, 使用于泛型类型未知的通用情况</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; <span class=\"function\">Map&lt;K, V&gt; <span class=\"title\">decodeMap</span><span class=\"params\">(String json, Class&lt;K&gt; key, Class&lt;V&gt; value)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.readValue(json, objectMapper.getTypeFactory()</span><br><span class=\"line\">                    .constructMapType(Map.class, key, value));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"jackson decodeMap(String, Class&lt;K&gt;, Class&lt;V&gt;) error, json = &#123;&#125;, key = &#123;&#125;, \"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"value = &#123;&#125;\"</span>, json, key.getName(), value.getName(), e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">对 jackson 浅层次的概念整理</a></li>\n<li><a href=\"http://zshell.cc/2017/01/21/ser_deser-jackson--jackson_常用配置选项梳理\">jackson 常用配置选项梳理</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/3269459/how-to-serialize-joda-datetime-with-jackson-json-processer\" target=\"_blank\" rel=\"noopener\">How to serialize Joda DateTime with Jackson JSON processer</a></li>\n<li><a href=\"http://mvnrepository.com/artifact/com.fasterxml.jackson.datatype\" target=\"_blank\" rel=\"noopener\">Group: FasterXML Jackson Datatype</a></li>\n</ul>"},{"title":"git 忽略文件的特殊场景","date":"2016-07-14T15:17:24.000Z","_content":"\n> git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;\n使用 `.gitignore` 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:\n1.一时疏忽, 将本该忽略的文件提交追踪了;\n2.需要临时忽略某指定文件, 一段时间后再继续追踪;\n本文将讨论以上两种情况下的 git 处理;\n\n<!--more-->\n\n------\n\n### **永远忽略已被跟踪的文件**\n适用场景:\n手误上传了不需要上传的文件, 希望斩草除根, 以后不让 git 追踪该文件;\n``` bash\n# first step\ngit rm --cached file_path/\n# second step\n更新 .gitignore 文件, exclude 目标文件\n```\n### **临时忽略已被跟踪的文件**\n适用场景:\n目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;\n所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;\n``` bash\n# first step\ngit update-index --assume-unchanged file_path/\n# second step\n编辑文件...\n# third step\ngit update-index --no-assume-unchanged file_path/\n```\n### **参考链接**\n- [git忽略已经被提交的文件](https://segmentfault.com/q/1010000000430426)\n\n","source":"_posts/tools-git--git忽略文件的特殊场景.md","raw":"---\ntitle: git 忽略文件的特殊场景\ndate: 2016-07-14 23:17:24\ncategories:\n - tools\n - git\ntags:\n - tools:git\n---\n\n> git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;\n使用 `.gitignore` 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:\n1.一时疏忽, 将本该忽略的文件提交追踪了;\n2.需要临时忽略某指定文件, 一段时间后再继续追踪;\n本文将讨论以上两种情况下的 git 处理;\n\n<!--more-->\n\n------\n\n### **永远忽略已被跟踪的文件**\n适用场景:\n手误上传了不需要上传的文件, 希望斩草除根, 以后不让 git 追踪该文件;\n``` bash\n# first step\ngit rm --cached file_path/\n# second step\n更新 .gitignore 文件, exclude 目标文件\n```\n### **临时忽略已被跟踪的文件**\n适用场景:\n目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;\n所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;\n``` bash\n# first step\ngit update-index --assume-unchanged file_path/\n# second step\n编辑文件...\n# third step\ngit update-index --no-assume-unchanged file_path/\n```\n### **参考链接**\n- [git忽略已经被提交的文件](https://segmentfault.com/q/1010000000430426)\n\n","slug":"tools-git--git忽略文件的特殊场景","published":1,"updated":"2018-02-12T10:51:43.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd6a001fj1jxiw1acfv8","content":"<blockquote>\n<p>git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;<br>使用 <code>.gitignore</code> 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:<br>1.一时疏忽, 将本该忽略的文件提交追踪了;<br>2.需要临时忽略某指定文件, 一段时间后再继续追踪;<br>本文将讨论以上两种情况下的 git 处理;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"永远忽略已被跟踪的文件\"><a href=\"#永远忽略已被跟踪的文件\" class=\"headerlink\" title=\"永远忽略已被跟踪的文件\"></a><strong>永远忽略已被跟踪的文件</strong></h3><p>适用场景:<br>手误上传了不需要上传的文件, 希望斩草除根, 以后不让 git 追踪该文件;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git rm --cached file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">更新 .gitignore 文件, exclude 目标文件</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"临时忽略已被跟踪的文件\"><a href=\"#临时忽略已被跟踪的文件\" class=\"headerlink\" title=\"临时忽略已被跟踪的文件\"></a><strong>临时忽略已被跟踪的文件</strong></h3><p>适用场景:<br>目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;<br>所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git update-index --assume-unchanged file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">编辑文件...</span><br><span class=\"line\"><span class=\"comment\"># third step</span></span><br><span class=\"line\">git update-index --no-assume-unchanged file_path/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/q/1010000000430426\" target=\"_blank\" rel=\"noopener\">git忽略已经被提交的文件</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>git 忽略文件, 其实有两种场景: 永久忽略 与 临时忽略;<br>使用 <code>.gitignore</code> 在最刚开始时永久忽略指定文件是最常见的处理, 但是偶尔也会遇到特殊情况:<br>1.一时疏忽, 将本该忽略的文件提交追踪了;<br>2.需要临时忽略某指定文件, 一段时间后再继续追踪;<br>本文将讨论以上两种情况下的 git 处理;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"永远忽略已被跟踪的文件\"><a href=\"#永远忽略已被跟踪的文件\" class=\"headerlink\" title=\"永远忽略已被跟踪的文件\"></a><strong>永远忽略已被跟踪的文件</strong></h3><p>适用场景:<br>手误上传了不需要上传的文件, 希望斩草除根, 以后不让 git 追踪该文件;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git rm --cached file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">更新 .gitignore 文件, exclude 目标文件</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"临时忽略已被跟踪的文件\"><a href=\"#临时忽略已被跟踪的文件\" class=\"headerlink\" title=\"临时忽略已被跟踪的文件\"></a><strong>临时忽略已被跟踪的文件</strong></h3><p>适用场景:<br>目标文件庞大, 每次修改保存时, git 计算文件的变化并更新 working directory, 触发磁盘IO瓶颈;<br>所以需要临时忽略文件, 待修改完成 commit 时恢复跟踪;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># first step</span></span><br><span class=\"line\">git update-index --assume-unchanged file_path/</span><br><span class=\"line\"><span class=\"comment\"># second step</span></span><br><span class=\"line\">编辑文件...</span><br><span class=\"line\"><span class=\"comment\"># third step</span></span><br><span class=\"line\">git update-index --no-assume-unchanged file_path/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/q/1010000000430426\" target=\"_blank\" rel=\"noopener\">git忽略已经被提交的文件</a></li>\n</ul>"},{"title":"saltstack cheat sheet","date":"2017-05-13T13:42:21.000Z","_content":"\n> 本文主要整理日常 saltstack 使用时的最常用的一些命令,以供快速查阅;\n\n<!--more-->\n\n------\n\n### **自由度最大的模块: cmd 模块**\n适用于登录 salt master 机器, 人工操作时执行;\n``` bash\n# cmd.run: 在 minions 上执行任意命令\nsudo salt * cmd.run \"ls -l /etc/localtime\"\nsudo salt * cmd.run uptime\n\n# cmd.script: 在 master 上下发任意脚本至 minions 执行\nsudo salt * cmd.script salt://minion_exeute.sh \"args1 args2\"\n```\n\n### **控制 minions 的定时任务执行情况: cron 模块**\n``` bash\n# 查看指定用户的 cron 内容\nsudo salt * cron.raw_cron root\n# 为指定用户添加指定任务\nsudo salt * cron.set_job root '*' '*' '*' '*' '*' /home/minion_execute.sh 1>/dev/null\n# 为指定用户删除指定任务\nsudo salt * cron.rm_job root '*' '*' '*' '*' '*' /home/minion_execute.sh 1>/dev/null\n```\n\n### **master 与 minions 的文件传输: cp 模块**\n``` bash\n# 推送文件到 minions 指定路径 (只能推送文件, 不能推送目录)\nsudo salt * cp.get_file salt://target_file /minion_path\n# 推送目录到 minions 指定路径\nsuod salt * cp.get_dir salt://target_dir /minion_path\n# 下载指定 url 的内容到 minions 指定路径 (不限于本地路径, 更加广泛)\nsudo salt * cp.get_url salt://target_file /minion_path\nsudo salt * cp.get_url https://d3kbcqa49mib13.cloudfront.net/spark-2.2.0-bin-hadoop2.7.tgz /minion_path\n```\n\n### **服务启停控制: systemd 模块**\nsalt.modules.systemd 模块是以 systemd 与 systemctl 为基础的, 尽管其命令多以 serice 开头, 不过该模块和 sysvinit 的 service 命令应该没什么关系;\n``` bash\n# 分别对应了 systemctl [enable, disable, start, stop, status, restart] httpd.service\nsudo salt * service.enable httpd\nsudo salt * service.disable httpd\n\nsudo salt * service.start httpd\nsudo salt * service.stop httpd\nsudo salt * service.status httpd\nsudo salt * service.restart httpd\n```\n\n### **远程文件控制相关: file 模块**\n``` bash\n# 创建文件\nsudo salt * file.touch /opt/rsync_passwd\n# 创建目录\nsudo salt * file.mkdir /opt/rsync\n# 删除指定文件\nsudo salt * file.remove /opt/rsync_passwd\n# 删除目录\nsudo salt * file.rmdir /opt/rsync\n\n# sudo chown root:root /opt/rsync_passwd\nsudo salt * file.chown /opt/rsync_passwd root root\n# sudo chmod 600 /etc/rsync_passwd\nsudo salt * file.set_mode /etc/rsync_passwd 600\n```\n\n### **salt 常用的状态检测**\n包括:\nmaster 与 minions 之间的连通性 check_ping 检查;\nminions salt version, dependency version, system version 检查;\nminions network ping 外网检查;\n磁盘容量 check_disk 检查;\n等等;\n``` bash\n# 测试 salt 主从连通性\nsudo salt * test.ping\n# 打印 salt 的版本以及 salt 依赖的第三方组件的版本\nsudo salt * test.versions_report\n# 测试 minions 的网络 ping\nsudo salt * network.ping www.qunar.com\n# 查看 minions 的磁盘使用情况\nsudo salt * disk.usage\n```\n\n### **参考链接**\n- [服务自动化部署平台之Saltstack总结](http://blog.csdn.net/shjh369/article/details/49799269)\n- [Saltstack系列3: Saltstack常用模块及API](https://www.cnblogs.com/MacoLee/p/5753640.html)\n- [SALT.MODULES.FILE](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.file.html#salt.modules.file.rmdir)\n\n","source":"_posts/saltstack--saltstack_cheat_sheet.md","raw":"---\ntitle: saltstack cheat sheet\ndate: 2017-05-13 21:42:21\ncategories:\n - saltstack\ntags:\n - saltstack\n - cheat sheet\n - 运维自动化\n---\n\n> 本文主要整理日常 saltstack 使用时的最常用的一些命令,以供快速查阅;\n\n<!--more-->\n\n------\n\n### **自由度最大的模块: cmd 模块**\n适用于登录 salt master 机器, 人工操作时执行;\n``` bash\n# cmd.run: 在 minions 上执行任意命令\nsudo salt * cmd.run \"ls -l /etc/localtime\"\nsudo salt * cmd.run uptime\n\n# cmd.script: 在 master 上下发任意脚本至 minions 执行\nsudo salt * cmd.script salt://minion_exeute.sh \"args1 args2\"\n```\n\n### **控制 minions 的定时任务执行情况: cron 模块**\n``` bash\n# 查看指定用户的 cron 内容\nsudo salt * cron.raw_cron root\n# 为指定用户添加指定任务\nsudo salt * cron.set_job root '*' '*' '*' '*' '*' /home/minion_execute.sh 1>/dev/null\n# 为指定用户删除指定任务\nsudo salt * cron.rm_job root '*' '*' '*' '*' '*' /home/minion_execute.sh 1>/dev/null\n```\n\n### **master 与 minions 的文件传输: cp 模块**\n``` bash\n# 推送文件到 minions 指定路径 (只能推送文件, 不能推送目录)\nsudo salt * cp.get_file salt://target_file /minion_path\n# 推送目录到 minions 指定路径\nsuod salt * cp.get_dir salt://target_dir /minion_path\n# 下载指定 url 的内容到 minions 指定路径 (不限于本地路径, 更加广泛)\nsudo salt * cp.get_url salt://target_file /minion_path\nsudo salt * cp.get_url https://d3kbcqa49mib13.cloudfront.net/spark-2.2.0-bin-hadoop2.7.tgz /minion_path\n```\n\n### **服务启停控制: systemd 模块**\nsalt.modules.systemd 模块是以 systemd 与 systemctl 为基础的, 尽管其命令多以 serice 开头, 不过该模块和 sysvinit 的 service 命令应该没什么关系;\n``` bash\n# 分别对应了 systemctl [enable, disable, start, stop, status, restart] httpd.service\nsudo salt * service.enable httpd\nsudo salt * service.disable httpd\n\nsudo salt * service.start httpd\nsudo salt * service.stop httpd\nsudo salt * service.status httpd\nsudo salt * service.restart httpd\n```\n\n### **远程文件控制相关: file 模块**\n``` bash\n# 创建文件\nsudo salt * file.touch /opt/rsync_passwd\n# 创建目录\nsudo salt * file.mkdir /opt/rsync\n# 删除指定文件\nsudo salt * file.remove /opt/rsync_passwd\n# 删除目录\nsudo salt * file.rmdir /opt/rsync\n\n# sudo chown root:root /opt/rsync_passwd\nsudo salt * file.chown /opt/rsync_passwd root root\n# sudo chmod 600 /etc/rsync_passwd\nsudo salt * file.set_mode /etc/rsync_passwd 600\n```\n\n### **salt 常用的状态检测**\n包括:\nmaster 与 minions 之间的连通性 check_ping 检查;\nminions salt version, dependency version, system version 检查;\nminions network ping 外网检查;\n磁盘容量 check_disk 检查;\n等等;\n``` bash\n# 测试 salt 主从连通性\nsudo salt * test.ping\n# 打印 salt 的版本以及 salt 依赖的第三方组件的版本\nsudo salt * test.versions_report\n# 测试 minions 的网络 ping\nsudo salt * network.ping www.qunar.com\n# 查看 minions 的磁盘使用情况\nsudo salt * disk.usage\n```\n\n### **参考链接**\n- [服务自动化部署平台之Saltstack总结](http://blog.csdn.net/shjh369/article/details/49799269)\n- [Saltstack系列3: Saltstack常用模块及API](https://www.cnblogs.com/MacoLee/p/5753640.html)\n- [SALT.MODULES.FILE](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.file.html#salt.modules.file.rmdir)\n\n","slug":"saltstack--saltstack_cheat_sheet","published":1,"updated":"2018-01-27T14:53:07.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd6b001ij1jxmj9ksqwj","content":"<blockquote>\n<p>本文主要整理日常 saltstack 使用时的最常用的一些命令,以供快速查阅;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"自由度最大的模块-cmd-模块\"><a href=\"#自由度最大的模块-cmd-模块\" class=\"headerlink\" title=\"自由度最大的模块: cmd 模块\"></a><strong>自由度最大的模块: cmd 模块</strong></h3><p>适用于登录 salt master 机器, 人工操作时执行;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cmd.run: 在 minions 上执行任意命令</span></span><br><span class=\"line\">sudo salt * cmd.run <span class=\"string\">\"ls -l /etc/localtime\"</span></span><br><span class=\"line\">sudo salt * cmd.run uptime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cmd.script: 在 master 上下发任意脚本至 minions 执行</span></span><br><span class=\"line\">sudo salt * cmd.script salt://minion_exeute.sh <span class=\"string\">\"args1 args2\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制-minions-的定时任务执行情况-cron-模块\"><a href=\"#控制-minions-的定时任务执行情况-cron-模块\" class=\"headerlink\" title=\"控制 minions 的定时任务执行情况: cron 模块\"></a><strong>控制 minions 的定时任务执行情况: cron 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定用户的 cron 内容</span></span><br><span class=\"line\">sudo salt * cron.raw_cron root</span><br><span class=\"line\"><span class=\"comment\"># 为指定用户添加指定任务</span></span><br><span class=\"line\">sudo salt * cron.set_job root <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> /home/minion_execute.sh 1&gt;/dev/null</span><br><span class=\"line\"><span class=\"comment\"># 为指定用户删除指定任务</span></span><br><span class=\"line\">sudo salt * cron.rm_job root <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> /home/minion_execute.sh 1&gt;/dev/null</span><br></pre></td></tr></table></figure>\n<h3 id=\"master-与-minions-的文件传输-cp-模块\"><a href=\"#master-与-minions-的文件传输-cp-模块\" class=\"headerlink\" title=\"master 与 minions 的文件传输: cp 模块\"></a><strong>master 与 minions 的文件传输: cp 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送文件到 minions 指定路径 (只能推送文件, 不能推送目录)</span></span><br><span class=\"line\">sudo salt * cp.get_file salt://target_file /minion_path</span><br><span class=\"line\"><span class=\"comment\"># 推送目录到 minions 指定路径</span></span><br><span class=\"line\">suod salt * cp.get_dir salt://target_dir /minion_path</span><br><span class=\"line\"><span class=\"comment\"># 下载指定 url 的内容到 minions 指定路径 (不限于本地路径, 更加广泛)</span></span><br><span class=\"line\">sudo salt * cp.get_url salt://target_file /minion_path</span><br><span class=\"line\">sudo salt * cp.get_url https://d3kbcqa49mib13.cloudfront.net/spark-2.2.0-bin-hadoop2.7.tgz /minion_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务启停控制-systemd-模块\"><a href=\"#服务启停控制-systemd-模块\" class=\"headerlink\" title=\"服务启停控制: systemd 模块\"></a><strong>服务启停控制: systemd 模块</strong></h3><p>salt.modules.systemd 模块是以 systemd 与 systemctl 为基础的, 尽管其命令多以 serice 开头, 不过该模块和 sysvinit 的 service 命令应该没什么关系;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别对应了 systemctl [enable, disable, start, stop, status, restart] httpd.service</span></span><br><span class=\"line\">sudo salt * service.enable httpd</span><br><span class=\"line\">sudo salt * service.disable httpd</span><br><span class=\"line\"></span><br><span class=\"line\">sudo salt * service.start httpd</span><br><span class=\"line\">sudo salt * service.stop httpd</span><br><span class=\"line\">sudo salt * service.status httpd</span><br><span class=\"line\">sudo salt * service.restart httpd</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"远程文件控制相关-file-模块\"><a href=\"#远程文件控制相关-file-模块\" class=\"headerlink\" title=\"远程文件控制相关: file 模块\"></a><strong>远程文件控制相关: file 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建文件</span></span><br><span class=\"line\">sudo salt * file.touch /opt/rsync_passwd</span><br><span class=\"line\"><span class=\"comment\"># 创建目录</span></span><br><span class=\"line\">sudo salt * file.mkdir /opt/rsync</span><br><span class=\"line\"><span class=\"comment\"># 删除指定文件</span></span><br><span class=\"line\">sudo salt * file.remove /opt/rsync_passwd</span><br><span class=\"line\"><span class=\"comment\"># 删除目录</span></span><br><span class=\"line\">sudo salt * file.rmdir /opt/rsync</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sudo chown root:root /opt/rsync_passwd</span></span><br><span class=\"line\">sudo salt * file.chown /opt/rsync_passwd root root</span><br><span class=\"line\"><span class=\"comment\"># sudo chmod 600 /etc/rsync_passwd</span></span><br><span class=\"line\">sudo salt * file.set_mode /etc/rsync_passwd 600</span><br></pre></td></tr></table></figure>\n<h3 id=\"salt-常用的状态检测\"><a href=\"#salt-常用的状态检测\" class=\"headerlink\" title=\"salt 常用的状态检测\"></a><strong>salt 常用的状态检测</strong></h3><p>包括:<br>master 与 minions 之间的连通性 check_ping 检查;<br>minions salt version, dependency version, system version 检查;<br>minions network ping 外网检查;<br>磁盘容量 check_disk 检查;<br>等等;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试 salt 主从连通性</span></span><br><span class=\"line\">sudo salt * test.ping</span><br><span class=\"line\"><span class=\"comment\"># 打印 salt 的版本以及 salt 依赖的第三方组件的版本</span></span><br><span class=\"line\">sudo salt * test.versions_report</span><br><span class=\"line\"><span class=\"comment\"># 测试 minions 的网络 ping</span></span><br><span class=\"line\">sudo salt * network.ping www.qunar.com</span><br><span class=\"line\"><span class=\"comment\"># 查看 minions 的磁盘使用情况</span></span><br><span class=\"line\">sudo salt * disk.usage</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://blog.csdn.net/shjh369/article/details/49799269\" target=\"_blank\" rel=\"noopener\">服务自动化部署平台之Saltstack总结</a></li>\n<li><a href=\"https://www.cnblogs.com/MacoLee/p/5753640.html\" target=\"_blank\" rel=\"noopener\">Saltstack系列3: Saltstack常用模块及API</a></li>\n<li><a href=\"https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.file.html#salt.modules.file.rmdir\" target=\"_blank\" rel=\"noopener\">SALT.MODULES.FILE</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文主要整理日常 saltstack 使用时的最常用的一些命令,以供快速查阅;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"自由度最大的模块-cmd-模块\"><a href=\"#自由度最大的模块-cmd-模块\" class=\"headerlink\" title=\"自由度最大的模块: cmd 模块\"></a><strong>自由度最大的模块: cmd 模块</strong></h3><p>适用于登录 salt master 机器, 人工操作时执行;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cmd.run: 在 minions 上执行任意命令</span></span><br><span class=\"line\">sudo salt * cmd.run <span class=\"string\">\"ls -l /etc/localtime\"</span></span><br><span class=\"line\">sudo salt * cmd.run uptime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cmd.script: 在 master 上下发任意脚本至 minions 执行</span></span><br><span class=\"line\">sudo salt * cmd.script salt://minion_exeute.sh <span class=\"string\">\"args1 args2\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"控制-minions-的定时任务执行情况-cron-模块\"><a href=\"#控制-minions-的定时任务执行情况-cron-模块\" class=\"headerlink\" title=\"控制 minions 的定时任务执行情况: cron 模块\"></a><strong>控制 minions 的定时任务执行情况: cron 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定用户的 cron 内容</span></span><br><span class=\"line\">sudo salt * cron.raw_cron root</span><br><span class=\"line\"><span class=\"comment\"># 为指定用户添加指定任务</span></span><br><span class=\"line\">sudo salt * cron.set_job root <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> /home/minion_execute.sh 1&gt;/dev/null</span><br><span class=\"line\"><span class=\"comment\"># 为指定用户删除指定任务</span></span><br><span class=\"line\">sudo salt * cron.rm_job root <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> <span class=\"string\">'*'</span> /home/minion_execute.sh 1&gt;/dev/null</span><br></pre></td></tr></table></figure>\n<h3 id=\"master-与-minions-的文件传输-cp-模块\"><a href=\"#master-与-minions-的文件传输-cp-模块\" class=\"headerlink\" title=\"master 与 minions 的文件传输: cp 模块\"></a><strong>master 与 minions 的文件传输: cp 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送文件到 minions 指定路径 (只能推送文件, 不能推送目录)</span></span><br><span class=\"line\">sudo salt * cp.get_file salt://target_file /minion_path</span><br><span class=\"line\"><span class=\"comment\"># 推送目录到 minions 指定路径</span></span><br><span class=\"line\">suod salt * cp.get_dir salt://target_dir /minion_path</span><br><span class=\"line\"><span class=\"comment\"># 下载指定 url 的内容到 minions 指定路径 (不限于本地路径, 更加广泛)</span></span><br><span class=\"line\">sudo salt * cp.get_url salt://target_file /minion_path</span><br><span class=\"line\">sudo salt * cp.get_url https://d3kbcqa49mib13.cloudfront.net/spark-2.2.0-bin-hadoop2.7.tgz /minion_path</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务启停控制-systemd-模块\"><a href=\"#服务启停控制-systemd-模块\" class=\"headerlink\" title=\"服务启停控制: systemd 模块\"></a><strong>服务启停控制: systemd 模块</strong></h3><p>salt.modules.systemd 模块是以 systemd 与 systemctl 为基础的, 尽管其命令多以 serice 开头, 不过该模块和 sysvinit 的 service 命令应该没什么关系;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分别对应了 systemctl [enable, disable, start, stop, status, restart] httpd.service</span></span><br><span class=\"line\">sudo salt * service.enable httpd</span><br><span class=\"line\">sudo salt * service.disable httpd</span><br><span class=\"line\"></span><br><span class=\"line\">sudo salt * service.start httpd</span><br><span class=\"line\">sudo salt * service.stop httpd</span><br><span class=\"line\">sudo salt * service.status httpd</span><br><span class=\"line\">sudo salt * service.restart httpd</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"远程文件控制相关-file-模块\"><a href=\"#远程文件控制相关-file-模块\" class=\"headerlink\" title=\"远程文件控制相关: file 模块\"></a><strong>远程文件控制相关: file 模块</strong></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建文件</span></span><br><span class=\"line\">sudo salt * file.touch /opt/rsync_passwd</span><br><span class=\"line\"><span class=\"comment\"># 创建目录</span></span><br><span class=\"line\">sudo salt * file.mkdir /opt/rsync</span><br><span class=\"line\"><span class=\"comment\"># 删除指定文件</span></span><br><span class=\"line\">sudo salt * file.remove /opt/rsync_passwd</span><br><span class=\"line\"><span class=\"comment\"># 删除目录</span></span><br><span class=\"line\">sudo salt * file.rmdir /opt/rsync</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sudo chown root:root /opt/rsync_passwd</span></span><br><span class=\"line\">sudo salt * file.chown /opt/rsync_passwd root root</span><br><span class=\"line\"><span class=\"comment\"># sudo chmod 600 /etc/rsync_passwd</span></span><br><span class=\"line\">sudo salt * file.set_mode /etc/rsync_passwd 600</span><br></pre></td></tr></table></figure>\n<h3 id=\"salt-常用的状态检测\"><a href=\"#salt-常用的状态检测\" class=\"headerlink\" title=\"salt 常用的状态检测\"></a><strong>salt 常用的状态检测</strong></h3><p>包括:<br>master 与 minions 之间的连通性 check_ping 检查;<br>minions salt version, dependency version, system version 检查;<br>minions network ping 外网检查;<br>磁盘容量 check_disk 检查;<br>等等;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试 salt 主从连通性</span></span><br><span class=\"line\">sudo salt * test.ping</span><br><span class=\"line\"><span class=\"comment\"># 打印 salt 的版本以及 salt 依赖的第三方组件的版本</span></span><br><span class=\"line\">sudo salt * test.versions_report</span><br><span class=\"line\"><span class=\"comment\"># 测试 minions 的网络 ping</span></span><br><span class=\"line\">sudo salt * network.ping www.qunar.com</span><br><span class=\"line\"><span class=\"comment\"># 查看 minions 的磁盘使用情况</span></span><br><span class=\"line\">sudo salt * disk.usage</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://blog.csdn.net/shjh369/article/details/49799269\" target=\"_blank\" rel=\"noopener\">服务自动化部署平台之Saltstack总结</a></li>\n<li><a href=\"https://www.cnblogs.com/MacoLee/p/5753640.html\" target=\"_blank\" rel=\"noopener\">Saltstack系列3: Saltstack常用模块及API</a></li>\n<li><a href=\"https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.file.html#salt.modules.file.rmdir\" target=\"_blank\" rel=\"noopener\">SALT.MODULES.FILE</a></li>\n</ul>"},{"title":"财富先锋 2017 年各股池成绩单","date":"2017-12-31T14:00:00.000Z","_content":"\n> 综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;\n'热点轮动', '股东增持' 两个股池系统的收益率达到了 200%, '支撑压力' 股池系统的收益率超过 150%;\n不过 '多头趋势' 股池系统的表现比较糟糕, 2017 年净收益为负;\n另外还有 '深一度' 股池系统的收益率未显示相关指标, 暂无法统计;\n各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;\n\n<!--more-->\n\n------\n\n### **支撑压力**\n![2017 支撑压力 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png)\n\n### **热点轮动**\n![2017 热点轮动 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png)\n\n### **股东增持**\n![2017 股东增持 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png)\n\n### **多头趋势**\n![2017 多头趋势 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png)\n","source":"_posts/证券-财富先锋--财富先锋2017年各股池成绩单.md","raw":"---\ntitle: 财富先锋 2017 年各股池成绩单\ndate: 2017-12-31 22:00:00\ntags:\n  - 证券:财富先锋\ncategories:\n  - 证券\n  - 财富先锋\n---\n\n> 综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;\n'热点轮动', '股东增持' 两个股池系统的收益率达到了 200%, '支撑压力' 股池系统的收益率超过 150%;\n不过 '多头趋势' 股池系统的表现比较糟糕, 2017 年净收益为负;\n另外还有 '深一度' 股池系统的收益率未显示相关指标, 暂无法统计;\n各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;\n\n<!--more-->\n\n------\n\n### **支撑压力**\n![2017 支撑压力 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png)\n\n### **热点轮动**\n![2017 热点轮动 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png)\n\n### **股东增持**\n![2017 股东增持 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png)\n\n### **多头趋势**\n![2017 多头趋势 final review](https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png)\n","slug":"证券-财富先锋--财富先锋2017年各股池成绩单","published":1,"updated":"2018-01-27T14:53:07.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd6d001nj1jxkeo54b5z","content":"<blockquote>\n<p>综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;<br>‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;<br>不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;<br>另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;<br>各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"支撑压力\"><a href=\"#支撑压力\" class=\"headerlink\" title=\"支撑压力\"></a><strong>支撑压力</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png\" alt=\"2017 支撑压力 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 支撑压力 final review</div>\n            </figure>\n<h3 id=\"热点轮动\"><a href=\"#热点轮动\" class=\"headerlink\" title=\"热点轮动\"></a><strong>热点轮动</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png\" alt=\"2017 热点轮动 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 热点轮动 final review</div>\n            </figure>\n<h3 id=\"股东增持\"><a href=\"#股东增持\" class=\"headerlink\" title=\"股东增持\"></a><strong>股东增持</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png\" alt=\"2017 股东增持 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 股东增持 final review</div>\n            </figure>\n<h3 id=\"多头趋势\"><a href=\"#多头趋势\" class=\"headerlink\" title=\"多头趋势\"></a><strong>多头趋势</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png\" alt=\"2017 多头趋势 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 多头趋势 final review</div>\n            </figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;<br>‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;<br>不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;<br>另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;<br>各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"支撑压力\"><a href=\"#支撑压力\" class=\"headerlink\" title=\"支撑压力\"></a><strong>支撑压力</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png\" alt=\"2017 支撑压力 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 支撑压力 final review</div>\n            </figure>\n<h3 id=\"热点轮动\"><a href=\"#热点轮动\" class=\"headerlink\" title=\"热点轮动\"></a><strong>热点轮动</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png\" alt=\"2017 热点轮动 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 热点轮动 final review</div>\n            </figure>\n<h3 id=\"股东增持\"><a href=\"#股东增持\" class=\"headerlink\" title=\"股东增持\"></a><strong>股东增持</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png\" alt=\"2017 股东增持 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 股东增持 final review</div>\n            </figure>\n<h3 id=\"多头趋势\"><a href=\"#多头趋势\" class=\"headerlink\" title=\"多头趋势\"></a><strong>多头趋势</strong></h3><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png\" alt=\"2017 多头趋势 final review\" title=\"\">\n                </div>\n                <div class=\"image-caption\">2017 多头趋势 final review</div>\n            </figure>"},{"title":"maven-assembly-plugin 使用总结","date":"2016-11-19T15:42:40.000Z","_content":"\n> 本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: [在 Apache Spark 中使用 springframework 的一次实践](), 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;\n另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 '丰富而典型' 的配置文件 case 上, 以注释的形式作为每个配置项的释义;\n\n<!--more-->\n\n------\n\n### **pom.xml 中的配置项**\n一段典型的 assembly 插件的 mvn 配置:\n``` xml\n<plugin>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>${assembly.plugin.version}</version>\n    \n    <configuration>\n        <!-- 打包后的包名是否需要追加 assembly 配置文件的 id -->\n        <appendAssemblyId>false</appendAssemblyId>\n        <!-- 最终生成的打包文件输出的路径 -->\n        <outputDirectory>${project.build.directory}/target</outputDirectory>\n        <!-- 定义核心配置文件的访问路径 -->\n        <descriptors>\n            <descriptor>${basedir}/src/main/assembly/client.xml</descriptor>\n            <descriptor>${basedir}/src/main/assembly/server.xml</descriptor>\n        </descriptors>\n    </configuration>\n    \n    <executions>\n        <execution>\n            <!-- 一般运行在 package phase -->\n            <phase>package</phase>\n            <goals>\n                <!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help -->\n                <goal>single</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n&nbsp;\n### **核心配置文件**\n以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 `${basedir}/src/main/assembly/` 目录里, 并如上一节所示, 在 `configuration -> descriptors` 路径下定义加载:\n``` xml\n<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n          \n    <!-- assembly 配置文件id -->\n    <id>deploy</id>\n    <!-- \n        目标打包文件的格式, 支持格式如下:\n            jar, war, zip, tar, tar.gz, tar.bz2 等 \n    -->\n    <formats>\n        <format>jar</format>\n    </formats>\n    \n    <!-- 是否以 ${project.build.finalName}, 作为所有被打包文件的基目录, 默认 true -->\n    <includeBaseDirectory>false</includeBaseDirectory>\n    <!-- 显式定义 所有被打包文件的基目录 -->\n    <baseDirectory>${project.build.finalName}</baseDirectory>\n    \n    <!-- 独立文件的收集 -->\n    <files>\n        <file>\n            <!-- 待收集的文件名 -->\n            <source>LICENSE.txt</source>\n            <!-- 收集到目标文件的相对路径 -->\n            <outputDirectory>/</outputDirectory>\n        </file>\n        <file>\n            <source>NOTICE.txt</source>\n            <outputDirectory>/</outputDirectory>\n            <!-- 将 ${...} 占位符 替换为实际的内容, 默认 false -->\n            <filtered>true</filtered>\n        </file>\n    </files>\n    \n    <!-- 目录的收集 -->\n    <fileSets>\n        <fileSet>\n            <!-- 目录名 -->\n            <directory>${project.basedir}/src/main/resources</directory>\n            <outputDirectory>/</outputDirectory>\n        </fileSet>\n        <fileSet>\n            <directory>${project.basedir}/src/doc</directory>\n            <!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true -->\n            <useDefaultExcludes>true</useDefaultExcludes>\n            <outputDirectory>/doc</outputDirectory>\n        </fileSet>\n    </fileSets>\n    \n    <!-- 依赖的收集 -->\n    <dependencySets>\n        <dependencySet>\n            <outputDirectory>/lib</outputDirectory>\n            <!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true -->\n            <useProjectArtifact>true</useProjectArtifact>\n            <!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false -->\n            <useProjectAttachments>false</useProjectAttachments>\n            <!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false -->\n            <unpack>false</unpack>\n            <!--  -->\n            <scope>runtime</scope>\n            <!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true -->\n            <useTransitiveDependencies>true</useTransitiveDependencies>\n            <!-- \n                includes/excludes 的格式:\n                    groupId:artifactId:type:classifier\n                    groupId:artifactId\n                    groupId:artifactId:type:classifier:version\n                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;\n            -->\n            <excludes>\n                <exclude>org.apache.commons:commons-logging:jar</exclude>\n                <exclude>*:war</exclude>\n            </excludes>\n            <!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false -->\n            <useTransitiveFiltering>true</useTransitiveFiltering>\n        </dependencySet>\n    </dependencySets>\n    \n</assembly>\n```\n\n&nbsp;\n### **使用 assembly 的一些注意事项**\n* 使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 `baseDirectory`, 并将 `includeBaseDirectory` 置为 `false`;\n因为 assembly 生成的 jar 包在 `/META-INF/MANIFEST.MF` 文件中默认不会定义 `Class-Path`, 即 CLASSPATH 默认就是 jar 中的基目录;\n\n``` bash\n# assembly 生成的 /META-INF/MANIFEST.MF\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nCreated-By: 25.151-b12 (Oracle Corporation)\n```\n* 核心配置文件中的 `outputDirectory` 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 `/`, 都不会有影响;\n* assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:\nassembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: [When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies](http://jira.codehaus.org/browse/MASSEMBLY-360) );\n当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;\n\n&nbsp;\n### **关于 assembly 命令**\n除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:\n``` bash\nmvn clean assembly:single\nmvn assembly:help\n```\n由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: [assembly:single](http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html)\n\n&nbsp;\n### **站内相关文章**\n- [在 Apache Spark 中使用 springframework 的一次实践]()\n\n&nbsp;\n### **参考链接**\n- [Apache Maven Assembly Plugin: Assembly](http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html)\n- [Filtering Some Distribution Files](https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html)\n- [8.5. Controlling the Contents of an Assembly](http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html)\n- [Quick Note on All includes and excludes Patterns](https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html)\n\n","source":"_posts/tools-maven--assembly_plugin.md","raw":"---\ntitle: maven-assembly-plugin 使用总结\ndate: 2016-11-19 23:42:40\ncategories:\n - tools\n - maven\ntags:\n - mvn:plugins\n---\n\n> 本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: [在 Apache Spark 中使用 springframework 的一次实践](), 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;\n另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 '丰富而典型' 的配置文件 case 上, 以注释的形式作为每个配置项的释义;\n\n<!--more-->\n\n------\n\n### **pom.xml 中的配置项**\n一段典型的 assembly 插件的 mvn 配置:\n``` xml\n<plugin>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>${assembly.plugin.version}</version>\n    \n    <configuration>\n        <!-- 打包后的包名是否需要追加 assembly 配置文件的 id -->\n        <appendAssemblyId>false</appendAssemblyId>\n        <!-- 最终生成的打包文件输出的路径 -->\n        <outputDirectory>${project.build.directory}/target</outputDirectory>\n        <!-- 定义核心配置文件的访问路径 -->\n        <descriptors>\n            <descriptor>${basedir}/src/main/assembly/client.xml</descriptor>\n            <descriptor>${basedir}/src/main/assembly/server.xml</descriptor>\n        </descriptors>\n    </configuration>\n    \n    <executions>\n        <execution>\n            <!-- 一般运行在 package phase -->\n            <phase>package</phase>\n            <goals>\n                <!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help -->\n                <goal>single</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n&nbsp;\n### **核心配置文件**\n以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 `${basedir}/src/main/assembly/` 目录里, 并如上一节所示, 在 `configuration -> descriptors` 路径下定义加载:\n``` xml\n<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n          \n    <!-- assembly 配置文件id -->\n    <id>deploy</id>\n    <!-- \n        目标打包文件的格式, 支持格式如下:\n            jar, war, zip, tar, tar.gz, tar.bz2 等 \n    -->\n    <formats>\n        <format>jar</format>\n    </formats>\n    \n    <!-- 是否以 ${project.build.finalName}, 作为所有被打包文件的基目录, 默认 true -->\n    <includeBaseDirectory>false</includeBaseDirectory>\n    <!-- 显式定义 所有被打包文件的基目录 -->\n    <baseDirectory>${project.build.finalName}</baseDirectory>\n    \n    <!-- 独立文件的收集 -->\n    <files>\n        <file>\n            <!-- 待收集的文件名 -->\n            <source>LICENSE.txt</source>\n            <!-- 收集到目标文件的相对路径 -->\n            <outputDirectory>/</outputDirectory>\n        </file>\n        <file>\n            <source>NOTICE.txt</source>\n            <outputDirectory>/</outputDirectory>\n            <!-- 将 ${...} 占位符 替换为实际的内容, 默认 false -->\n            <filtered>true</filtered>\n        </file>\n    </files>\n    \n    <!-- 目录的收集 -->\n    <fileSets>\n        <fileSet>\n            <!-- 目录名 -->\n            <directory>${project.basedir}/src/main/resources</directory>\n            <outputDirectory>/</outputDirectory>\n        </fileSet>\n        <fileSet>\n            <directory>${project.basedir}/src/doc</directory>\n            <!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true -->\n            <useDefaultExcludes>true</useDefaultExcludes>\n            <outputDirectory>/doc</outputDirectory>\n        </fileSet>\n    </fileSets>\n    \n    <!-- 依赖的收集 -->\n    <dependencySets>\n        <dependencySet>\n            <outputDirectory>/lib</outputDirectory>\n            <!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true -->\n            <useProjectArtifact>true</useProjectArtifact>\n            <!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false -->\n            <useProjectAttachments>false</useProjectAttachments>\n            <!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false -->\n            <unpack>false</unpack>\n            <!--  -->\n            <scope>runtime</scope>\n            <!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true -->\n            <useTransitiveDependencies>true</useTransitiveDependencies>\n            <!-- \n                includes/excludes 的格式:\n                    groupId:artifactId:type:classifier\n                    groupId:artifactId\n                    groupId:artifactId:type:classifier:version\n                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;\n            -->\n            <excludes>\n                <exclude>org.apache.commons:commons-logging:jar</exclude>\n                <exclude>*:war</exclude>\n            </excludes>\n            <!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false -->\n            <useTransitiveFiltering>true</useTransitiveFiltering>\n        </dependencySet>\n    </dependencySets>\n    \n</assembly>\n```\n\n&nbsp;\n### **使用 assembly 的一些注意事项**\n* 使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 `baseDirectory`, 并将 `includeBaseDirectory` 置为 `false`;\n因为 assembly 生成的 jar 包在 `/META-INF/MANIFEST.MF` 文件中默认不会定义 `Class-Path`, 即 CLASSPATH 默认就是 jar 中的基目录;\n\n``` bash\n# assembly 生成的 /META-INF/MANIFEST.MF\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nCreated-By: 25.151-b12 (Oracle Corporation)\n```\n* 核心配置文件中的 `outputDirectory` 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 `/`, 都不会有影响;\n* assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:\nassembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: [When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies](http://jira.codehaus.org/browse/MASSEMBLY-360) );\n当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;\n\n&nbsp;\n### **关于 assembly 命令**\n除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:\n``` bash\nmvn clean assembly:single\nmvn assembly:help\n```\n由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: [assembly:single](http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html)\n\n&nbsp;\n### **站内相关文章**\n- [在 Apache Spark 中使用 springframework 的一次实践]()\n\n&nbsp;\n### **参考链接**\n- [Apache Maven Assembly Plugin: Assembly](http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html)\n- [Filtering Some Distribution Files](https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html)\n- [8.5. Controlling the Contents of an Assembly](http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html)\n- [Quick Note on All includes and excludes Patterns](https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html)\n\n","slug":"tools-maven--assembly_plugin","published":1,"updated":"2018-01-20T13:20:30.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd6f001qj1jxsmvguqlk","content":"<blockquote>\n<p>本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: <a href=\"\">在 Apache Spark 中使用 springframework 的一次实践</a>, 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;<br>另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 ‘丰富而典型’ 的配置文件 case 上, 以注释的形式作为每个配置项的释义;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"pom-xml-中的配置项\"><a href=\"#pom-xml-中的配置项\" class=\"headerlink\" title=\"pom.xml 中的配置项\"></a><strong>pom.xml 中的配置项</strong></h3><p>一段典型的 assembly 插件的 mvn 配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-assembly-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;assembly.plugin.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 打包后的包名是否需要追加 assembly 配置文件的 id --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appendAssemblyId</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">appendAssemblyId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 最终生成的打包文件输出的路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 定义核心配置文件的访问路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/client.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/server.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 一般运行在 package phase --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help --&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>single<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a><strong>核心配置文件</strong></h3><p>以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 <code>${basedir}/src/main/assembly/</code> 目录里, 并如上一节所示, 在 <code>configuration -&gt; descriptors</code> 路径下定义加载:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">assembly</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- assembly 配置文件id --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>deploy<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        目标打包文件的格式, 支持格式如下:</span></span><br><span class=\"line\"><span class=\"comment\">            jar, war, zip, tar, tar.gz, tar.bz2 等 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">format</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">format</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是否以 $&#123;project.build.finalName&#125;, 作为所有被打包文件的基目录, 默认 true --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeBaseDirectory</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">includeBaseDirectory</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 显式定义 所有被打包文件的基目录 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">baseDirectory</span>&gt;</span>$&#123;project.build.finalName&#125;<span class=\"tag\">&lt;/<span class=\"name\">baseDirectory</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独立文件的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 待收集的文件名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>LICENSE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 收集到目标文件的相对路径 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>NOTICE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 将 $&#123;...&#125; 占位符 替换为实际的内容, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtered</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtered</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目录的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 目录名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/doc<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useDefaultExcludes</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useDefaultExcludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/doc<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/lib<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectArtifact</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useProjectArtifact</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectAttachments</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">useProjectAttachments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">unpack</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">unpack</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--  --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveDependencies</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveDependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">                includes/excludes 的格式:</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier:version</span></span><br><span class=\"line\"><span class=\"comment\">                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;</span></span><br><span class=\"line\"><span class=\"comment\">            --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>org.apache.commons:commons-logging:jar<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>*:war<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveFiltering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveFiltering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"使用-assembly-的一些注意事项\"><a href=\"#使用-assembly-的一些注意事项\" class=\"headerlink\" title=\"使用 assembly 的一些注意事项\"></a><strong>使用 assembly 的一些注意事项</strong></h3><ul>\n<li>使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 <code>baseDirectory</code>, 并将 <code>includeBaseDirectory</code> 置为 <code>false</code>;<br>因为 assembly 生成的 jar 包在 <code>/META-INF/MANIFEST.MF</code> 文件中默认不会定义 <code>Class-Path</code>, 即 CLASSPATH 默认就是 jar 中的基目录;</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># assembly 生成的 /META-INF/MANIFEST.MF</span></span><br><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Archiver-Version: Plexus Archiver</span><br><span class=\"line\">Created-By: 25.151-b12 (Oracle Corporation)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>核心配置文件中的 <code>outputDirectory</code> 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 <code>/</code>, 都不会有影响;</li>\n<li>assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:<br>assembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: <a href=\"http://jira.codehaus.org/browse/MASSEMBLY-360\" target=\"_blank\" rel=\"noopener\">When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies</a> );<br>当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;</li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"关于-assembly-命令\"><a href=\"#关于-assembly-命令\" class=\"headerlink\" title=\"关于 assembly 命令\"></a><strong>关于 assembly 命令</strong></h3><p>除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean assembly:single</span><br><span class=\"line\">mvn assembly:<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></p>\n<p>由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: <a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html\" target=\"_blank\" rel=\"noopener\">assembly:single</a></p>\n<p>&nbsp;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">在 Apache Spark 中使用 springframework 的一次实践</a></li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html\" target=\"_blank\" rel=\"noopener\">Apache Maven Assembly Plugin: Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html\" target=\"_blank\" rel=\"noopener\">Filtering Some Distribution Files</a></li>\n<li><a href=\"http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html\" target=\"_blank\" rel=\"noopener\">8.5. Controlling the Contents of an Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html\" target=\"_blank\" rel=\"noopener\">Quick Note on All includes and excludes Patterns</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文在 Apache Maven 的官方文档上, 结合自己的一些项目经历: <a href=\"\">在 Apache Spark 中使用 springframework 的一次实践</a>, 总结了一些 assembly 插件的使用方式和一些注意事项, 以作备忘;<br>另外, 由于 assembly 的 核心配置文件中可配置项种类繁多, 为了体现直观性, 文本直接在一段 ‘丰富而典型’ 的配置文件 case 上, 以注释的形式作为每个配置项的释义;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"pom-xml-中的配置项\"><a href=\"#pom-xml-中的配置项\" class=\"headerlink\" title=\"pom.xml 中的配置项\"></a><strong>pom.xml 中的配置项</strong></h3><p>一段典型的 assembly 插件的 mvn 配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-assembly-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;assembly.plugin.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 打包后的包名是否需要追加 assembly 配置文件的 id --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appendAssemblyId</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">appendAssemblyId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 最终生成的打包文件输出的路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/target<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 定义核心配置文件的访问路径 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/client.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">descriptor</span>&gt;</span>$&#123;basedir&#125;/src/main/assembly/server.xml<span class=\"tag\">&lt;/<span class=\"name\">descriptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">descriptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 一般运行在 package phase --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!-- assembly 插件中唯一的核心 goal, 另外一个 goal 是 assembly:help --&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>single<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a><strong>核心配置文件</strong></h3><p>以下 assembly 核心配置文件包含了最常用的几种配置项, 该文件习惯上放置在 <code>${basedir}/src/main/assembly/</code> 目录里, 并如上一节所示, 在 <code>configuration -&gt; descriptors</code> 路径下定义加载:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">assembly</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- assembly 配置文件id --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>deploy<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        目标打包文件的格式, 支持格式如下:</span></span><br><span class=\"line\"><span class=\"comment\">            jar, war, zip, tar, tar.gz, tar.bz2 等 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">format</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">format</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">formats</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是否以 $&#123;project.build.finalName&#125;, 作为所有被打包文件的基目录, 默认 true --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeBaseDirectory</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">includeBaseDirectory</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 显式定义 所有被打包文件的基目录 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">baseDirectory</span>&gt;</span>$&#123;project.build.finalName&#125;<span class=\"tag\">&lt;/<span class=\"name\">baseDirectory</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独立文件的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 待收集的文件名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>LICENSE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 收集到目标文件的相对路径 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>NOTICE.txt<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 将 $&#123;...&#125; 占位符 替换为实际的内容, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtered</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtered</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">files</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目录的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 目录名 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/doc<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否使用默认的排除项, 排除范围包括版本控制程序产生的 metadata 等, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useDefaultExcludes</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useDefaultExcludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/doc<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fileSet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fileSets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖的收集 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span>&gt;</span>/lib<span class=\"tag\">&lt;/<span class=\"name\">outputDirectory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 主构件 加入到依赖的收集中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectArtifact</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useProjectArtifact</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将本次构建过程中生成的 附加构件 也加入到依赖的收集中, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useProjectAttachments</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">useProjectAttachments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否将依赖都解包为普通的目录文件放入 outputDirectory, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">unpack</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">unpack</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--  --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让该 dependencySets 收集具有传递性, 即递归地将 dependency 间接依赖的 dependencies 都收集到打包文件中, 默认 true --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveDependencies</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveDependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">                includes/excludes 的格式:</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId</span></span><br><span class=\"line\"><span class=\"comment\">                    groupId:artifactId:type:classifier:version</span></span><br><span class=\"line\"><span class=\"comment\">                支持使用 * 通配, * 可以完整匹配由多个 ':' 分割的 section;</span></span><br><span class=\"line\"><span class=\"comment\">            --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>org.apache.commons:commons-logging:jar<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">exclude</span>&gt;</span>*:war<span class=\"tag\">&lt;/<span class=\"name\">exclude</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">excludes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否让 includes/excludes 具有传递性, 即递归地让指定的 dependency 间接依赖的 dependencies 都被 include/exclude, 默认 false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">useTransitiveFiltering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">useTransitiveFiltering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencySet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencySets</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"使用-assembly-的一些注意事项\"><a href=\"#使用-assembly-的一些注意事项\" class=\"headerlink\" title=\"使用 assembly 的一些注意事项\"></a><strong>使用 assembly 的一些注意事项</strong></h3><ul>\n<li>使用 assembly 打包成需要独立运行的 jar 时, 若无特殊需要显式定义 CLASSPATH,  则在核心配置文件中不应该定义 <code>baseDirectory</code>, 并将 <code>includeBaseDirectory</code> 置为 <code>false</code>;<br>因为 assembly 生成的 jar 包在 <code>/META-INF/MANIFEST.MF</code> 文件中默认不会定义 <code>Class-Path</code>, 即 CLASSPATH 默认就是 jar 中的基目录;</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># assembly 生成的 /META-INF/MANIFEST.MF</span></span><br><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Archiver-Version: Plexus Archiver</span><br><span class=\"line\">Created-By: 25.151-b12 (Oracle Corporation)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>核心配置文件中的 <code>outputDirectory</code> 皆是以目标打包文件的根为相对路径的; 无论是否在路径最前面添加 <code>/</code>, 都不会有影响;</li>\n<li>assembly 2.2 之前的版本, 在涉及到一些复杂第三方依赖, 多个不同的 jar 包中含有同名的文件 (如 org.springframework) 时, 使用 assembly 打包时会遇到一个 bug:<br>assembly 只把第一次遇到的同名文件加入目标打包文件, 其后遇到的同名文件, 则被 skip 掉 ( 详见官方 issue: <a href=\"http://jira.codehaus.org/browse/MASSEMBLY-360\" target=\"_blank\" rel=\"noopener\">When using mulitple Spring dependencies, the files from META-INF (from the Spring jars) overwrite each other in an executable jar-with-dependencies</a> );<br>当然, 在这个 issue 当中, 触发此 bug 还有一个必要条件是将 dependencySet 中的 unpack 置为 true, 这样多个 spring artifact META-INF/ 中的 spring.handlers / spring.schemas / spring.tooling 等文件才会同名冲突;</li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"关于-assembly-命令\"><a href=\"#关于-assembly-命令\" class=\"headerlink\" title=\"关于 assembly 命令\"></a><strong>关于 assembly 命令</strong></h3><p>除了上述以 配置文件 + maven core phase 回调的形式使用 assembly 插件之外, assembly 插件的 goals 也可以命令的形式执行:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean assembly:single</span><br><span class=\"line\">mvn assembly:<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></p>\n<p>由于使用 assembly 命令的场景不多见, 此处不再详述, 详见 maven 官方介绍: <a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html\" target=\"_blank\" rel=\"noopener\">assembly:single</a></p>\n<p>&nbsp;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">在 Apache Spark 中使用 springframework 的一次实践</a></li>\n</ul>\n<p>&nbsp;</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html\" target=\"_blank\" rel=\"noopener\">Apache Maven Assembly Plugin: Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/examples/single/filtering-some-distribution-files.html\" target=\"_blank\" rel=\"noopener\">Filtering Some Distribution Files</a></li>\n<li><a href=\"http://books.sonatype.com/mvnref-book/reference/assemblies-sect-controlling-contents.html\" target=\"_blank\" rel=\"noopener\">8.5. Controlling the Contents of an Assembly</a></li>\n<li><a href=\"https://maven.apache.org/plugins/maven-assembly-plugin/advanced-descriptor-topics.html\" target=\"_blank\" rel=\"noopener\">Quick Note on All includes and excludes Patterns</a></li>\n</ul>"},{"title":"http status code 典型问题总结","date":"2017-03-06T15:27:25.000Z","_content":"\n> 本人根据自身的工作经历, 以一个 java dev 的视角, 总结了一些 http status code 的常见问题, 原因及解决办法;\n这些问题涉及到的系统或技术栈包括了 nginx, tomcat, spring(springMVC), elasticsearch 等等;\n\n<!--more-->\n\n------\n\n## **3XX 重定向系列**\n### **301 Moved Permanently**\n### **302 Found**\n### **303 See Other**\n### **304 Not Modified**\n此状态码需要http header的配合:\n\n### **307**\n## **4XX 客户端错误系列**\n4XX 为客户端请求错误相关的 status code;\n以下为各种 4XX status code 的含义以及可能的对应于常用 web server tomcat 或常用 web 框架 springMVC, 返回此 code 的原因;\n其中, tomcat 的版本为 7.0.47.0, springMVC 的版本为 4.1.8.RELEASE\n&nbsp;\n### **400 Bad Request**\n一般是请求参数错误, 参数个数少了或者参数名与 api 要求不符;\n&nbsp;\n### **401 Unauthorized**\n请求未认证, 如果服务端需要用户密码认证而 request 未携带相关 header 则会返回此 code;\n如果是 chrome 收到 401, 便会弹出内置的登陆框, 让用户输入用户密码;\n如果需要手动发送 http 请求作认证, 需加入如下header:\n``` bash\n# base64_encoded_content 是 username=password 被 BASE64 编码后的序列\nAuthorization: Basic base64_encoded_content\n```\n其中有两个注意点:\n\n1. `Authentication` header 的 value 必须是以 Basic 为前缀, 空一格后跟着 BASE64 编码的内容;\n2. BASE64 编码的内容是 username=password, 其中间的 `=` 不能少; 最方便的生成该编码的方法就是使用 chrome 或者 postman 自动生成, 然后查看 code 即可;\n\n&nbsp;\n### **403 Forbidden**\n禁止访问(非法访问), 一般请求认证失败后返回此 code;\n&nbsp;\n### **404 Not Found**\n找不到资源, 一般在 springMVC 工程里, 这种错误遇到的常见的情况是请求静态资源 (例如 healthcheck.html) 发生 404;\n通常这种错误的原因是 springMVC 的 DispatcherServlet 拦截了所有的请求, 但是对静态资源的请求却又找不到路由处理器, 从而报出 404;\n解决的方案主要有三种:\n(1) web.xml 里配置 tomcat 的 default servlet:\n``` xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>*.html</url-pattern>\n</servlet-mapping>\n```\n另外, 除了 *.html 之外, 其他静态资源亦可一并配置:\n``` xml\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.js</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.css</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.jpg</url-pattern>\n    </servlet-mapping>\n```\n此配置需放在 DispatcherServlet 前面从而在 springMVC 之前被拦截;\n\n(2) 在 mvc-context.xml 中配置 mvc namespace 下的 default-servlet-handler 标签:\n``` xml\n<mvc:default-servlet-handler/> \n```\n\n(3) 在 mvc-context.xml 中配置 mvc namespace 下的 resources 标签:\n``` xml\n<mvc:resources mapping=\"/**\" location=\"/\"/>\n```\n&nbsp;\n### **405 Method Not Supported**\n&nbsp;\n### **406 Not Acceptable**\n服务器端无法提供客户端在 `Accept` header 中给出的媒体类型; 在springMVC 工程里, 这种比较常见的情况, 一般和 json 有关, 往往还需要前端 (比如 ajax) 配合; 因为, 普通的请求, request 报文里一般不会指明 `Accept` header, 那么无论后端返回什么, 哪怕是报错也好, 都不至于造成 406; 而对于如下 ajax 请求:\n``` javascript\n$.ajaxFileUpload({\n    data: fetch_form_data('form_id'),\n    url: '/xxx/yyy/zzz'\n    type: 'post',\n    dataType: 'json',   // 指定了 Accept header 为 application/json\n    success: function(data) { ... },\n    error: function(data, status, e) { ... }\n});\n```\n可以看到, 该 ajax 请求指定了 dataType 为 json, 这会在该 ajax 构造的 request 中追加 `Accept` header, value 为 `application/json`, 这就要求服务器端必须返回 json 类型的数据;\n然后在后端 springMVC 工程里, 有如下几种情况可能会造成 web server 认为无法提供客户端指定的媒体类型:\n(1) Controller 里的方法上没加 `@ResponseBody` 注解, 导致 springMVC 未能根据方法返回值正确推断媒体类型:\n``` java\n@RequestMapping(value = \"/xxx\", method = RequestMethod.POST)\n@ResponseBody   // 该注解使得 springMVC 框架认为该请求需要转化为 json (should be bound to the web response body)\npublic WebResponse handleRequest(@RequestParam(\"xxx\") String xxx) {\n    ......\n    return WebResponse.success(instance);\n}    \n```\n或者更干脆的, 可以对该 Controller 直接使用 `@RestController` 注解, 相当于让所有的方法都被自动加上了 `@ResponseBody`:\n``` java\n/**\n * A convenience annotation that is itself annotated with {@link Controller @Controller}\n * and {@link ResponseBody @ResponseBody}.\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController { ... }\n```\n(2) mvc-context.xml 中, 没有注册 \"注解驱动\":\n``` xml\n<mvc:annotation-driven/>\n```\n这个注解驱动的功能是如此之强大以至于在一般的 springMVC 项目中都不会落下它, 顶多就是覆盖其中部分设置以作微调 (详细的内容请参考: [&lt;mvc:annotation-driven/&gt; 所做事情的详细梳理]());\n当然, 如果不想被 &lt;mvc:annotation-driven/&gt; 支配而又要避免 406 错误, 就需要主动注入 `RequestMappingHandlerAdapter`, 而这是一个十分复杂的 bean, 所以并不建议这么搞;\n(3) 如果第一点和第二点都没有问题却依然报 406 的话, 那么极有可能是 jackson 相关依赖的版本兼容性问题; 在默认的负责读写 json 的 `MappingJackson2HttpMessageConverter` 中 (v4.1.8.RELEASE), 有这么一句注释:\n> Compatible with Jackson 2.1 and higher.\n\n而我在更高的 spring 版本里(比如 master), jackson 的最低兼容版本已经到了 2.9; 可见, 如果项目里的 jackson 版本不能与 spring 保持同步, 便极有可能导致序列化/反序列化失败, 进而导致 406 错误;\n&nbsp;\n### **407**\n### **408 Request Timeout**\n### **409 Confilct**\n### **410**\n### **411**\n### **412**\n### **413 Entity Too Large**\n### **414**\n### **415 Not supported media type**\n### **416**\n### **417**\n### **429 Too Many Requests**\n\n","source":"_posts/web--http_status_code_典型问题总结.md","raw":"---\ntitle: http status code 典型问题总结\ndate: 2017-03-06 23:27:25\ncategories:\n - web\ntags:\n - http\n - tomcat\n - spring\n - spring-mvc\n---\n\n> 本人根据自身的工作经历, 以一个 java dev 的视角, 总结了一些 http status code 的常见问题, 原因及解决办法;\n这些问题涉及到的系统或技术栈包括了 nginx, tomcat, spring(springMVC), elasticsearch 等等;\n\n<!--more-->\n\n------\n\n## **3XX 重定向系列**\n### **301 Moved Permanently**\n### **302 Found**\n### **303 See Other**\n### **304 Not Modified**\n此状态码需要http header的配合:\n\n### **307**\n## **4XX 客户端错误系列**\n4XX 为客户端请求错误相关的 status code;\n以下为各种 4XX status code 的含义以及可能的对应于常用 web server tomcat 或常用 web 框架 springMVC, 返回此 code 的原因;\n其中, tomcat 的版本为 7.0.47.0, springMVC 的版本为 4.1.8.RELEASE\n&nbsp;\n### **400 Bad Request**\n一般是请求参数错误, 参数个数少了或者参数名与 api 要求不符;\n&nbsp;\n### **401 Unauthorized**\n请求未认证, 如果服务端需要用户密码认证而 request 未携带相关 header 则会返回此 code;\n如果是 chrome 收到 401, 便会弹出内置的登陆框, 让用户输入用户密码;\n如果需要手动发送 http 请求作认证, 需加入如下header:\n``` bash\n# base64_encoded_content 是 username=password 被 BASE64 编码后的序列\nAuthorization: Basic base64_encoded_content\n```\n其中有两个注意点:\n\n1. `Authentication` header 的 value 必须是以 Basic 为前缀, 空一格后跟着 BASE64 编码的内容;\n2. BASE64 编码的内容是 username=password, 其中间的 `=` 不能少; 最方便的生成该编码的方法就是使用 chrome 或者 postman 自动生成, 然后查看 code 即可;\n\n&nbsp;\n### **403 Forbidden**\n禁止访问(非法访问), 一般请求认证失败后返回此 code;\n&nbsp;\n### **404 Not Found**\n找不到资源, 一般在 springMVC 工程里, 这种错误遇到的常见的情况是请求静态资源 (例如 healthcheck.html) 发生 404;\n通常这种错误的原因是 springMVC 的 DispatcherServlet 拦截了所有的请求, 但是对静态资源的请求却又找不到路由处理器, 从而报出 404;\n解决的方案主要有三种:\n(1) web.xml 里配置 tomcat 的 default servlet:\n``` xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>*.html</url-pattern>\n</servlet-mapping>\n```\n另外, 除了 *.html 之外, 其他静态资源亦可一并配置:\n``` xml\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.js</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.css</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.jpg</url-pattern>\n    </servlet-mapping>\n```\n此配置需放在 DispatcherServlet 前面从而在 springMVC 之前被拦截;\n\n(2) 在 mvc-context.xml 中配置 mvc namespace 下的 default-servlet-handler 标签:\n``` xml\n<mvc:default-servlet-handler/> \n```\n\n(3) 在 mvc-context.xml 中配置 mvc namespace 下的 resources 标签:\n``` xml\n<mvc:resources mapping=\"/**\" location=\"/\"/>\n```\n&nbsp;\n### **405 Method Not Supported**\n&nbsp;\n### **406 Not Acceptable**\n服务器端无法提供客户端在 `Accept` header 中给出的媒体类型; 在springMVC 工程里, 这种比较常见的情况, 一般和 json 有关, 往往还需要前端 (比如 ajax) 配合; 因为, 普通的请求, request 报文里一般不会指明 `Accept` header, 那么无论后端返回什么, 哪怕是报错也好, 都不至于造成 406; 而对于如下 ajax 请求:\n``` javascript\n$.ajaxFileUpload({\n    data: fetch_form_data('form_id'),\n    url: '/xxx/yyy/zzz'\n    type: 'post',\n    dataType: 'json',   // 指定了 Accept header 为 application/json\n    success: function(data) { ... },\n    error: function(data, status, e) { ... }\n});\n```\n可以看到, 该 ajax 请求指定了 dataType 为 json, 这会在该 ajax 构造的 request 中追加 `Accept` header, value 为 `application/json`, 这就要求服务器端必须返回 json 类型的数据;\n然后在后端 springMVC 工程里, 有如下几种情况可能会造成 web server 认为无法提供客户端指定的媒体类型:\n(1) Controller 里的方法上没加 `@ResponseBody` 注解, 导致 springMVC 未能根据方法返回值正确推断媒体类型:\n``` java\n@RequestMapping(value = \"/xxx\", method = RequestMethod.POST)\n@ResponseBody   // 该注解使得 springMVC 框架认为该请求需要转化为 json (should be bound to the web response body)\npublic WebResponse handleRequest(@RequestParam(\"xxx\") String xxx) {\n    ......\n    return WebResponse.success(instance);\n}    \n```\n或者更干脆的, 可以对该 Controller 直接使用 `@RestController` 注解, 相当于让所有的方法都被自动加上了 `@ResponseBody`:\n``` java\n/**\n * A convenience annotation that is itself annotated with {@link Controller @Controller}\n * and {@link ResponseBody @ResponseBody}.\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController { ... }\n```\n(2) mvc-context.xml 中, 没有注册 \"注解驱动\":\n``` xml\n<mvc:annotation-driven/>\n```\n这个注解驱动的功能是如此之强大以至于在一般的 springMVC 项目中都不会落下它, 顶多就是覆盖其中部分设置以作微调 (详细的内容请参考: [&lt;mvc:annotation-driven/&gt; 所做事情的详细梳理]());\n当然, 如果不想被 &lt;mvc:annotation-driven/&gt; 支配而又要避免 406 错误, 就需要主动注入 `RequestMappingHandlerAdapter`, 而这是一个十分复杂的 bean, 所以并不建议这么搞;\n(3) 如果第一点和第二点都没有问题却依然报 406 的话, 那么极有可能是 jackson 相关依赖的版本兼容性问题; 在默认的负责读写 json 的 `MappingJackson2HttpMessageConverter` 中 (v4.1.8.RELEASE), 有这么一句注释:\n> Compatible with Jackson 2.1 and higher.\n\n而我在更高的 spring 版本里(比如 master), jackson 的最低兼容版本已经到了 2.9; 可见, 如果项目里的 jackson 版本不能与 spring 保持同步, 便极有可能导致序列化/反序列化失败, 进而导致 406 错误;\n&nbsp;\n### **407**\n### **408 Request Timeout**\n### **409 Confilct**\n### **410**\n### **411**\n### **412**\n### **413 Entity Too Large**\n### **414**\n### **415 Not supported media type**\n### **416**\n### **417**\n### **429 Too Many Requests**\n\n","slug":"web--http_status_code_典型问题总结","published":1,"updated":"2018-03-26T15:40:25.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd6j001tj1jxjcbxas3p","content":"<blockquote>\n<p>本人根据自身的工作经历, 以一个 java dev 的视角, 总结了一些 http status code 的常见问题, 原因及解决办法;<br>这些问题涉及到的系统或技术栈包括了 nginx, tomcat, spring(springMVC), elasticsearch 等等;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"3XX-重定向系列\"><a href=\"#3XX-重定向系列\" class=\"headerlink\" title=\"3XX 重定向系列\"></a><strong>3XX 重定向系列</strong></h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a><strong>301 Moved Permanently</strong></h3><h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a><strong>302 Found</strong></h3><h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a><strong>303 See Other</strong></h3><h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a><strong>304 Not Modified</strong></h3><p>此状态码需要http header的配合:</p>\n<h3 id=\"307\"><a href=\"#307\" class=\"headerlink\" title=\"307\"></a><strong>307</strong></h3><h2 id=\"4XX-客户端错误系列\"><a href=\"#4XX-客户端错误系列\" class=\"headerlink\" title=\"4XX 客户端错误系列\"></a><strong>4XX 客户端错误系列</strong></h2><p>4XX 为客户端请求错误相关的 status code;<br>以下为各种 4XX status code 的含义以及可能的对应于常用 web server tomcat 或常用 web 框架 springMVC, 返回此 code 的原因;<br>其中, tomcat 的版本为 7.0.47.0, springMVC 的版本为 4.1.8.RELEASE<br>&nbsp;</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a><strong>400 Bad Request</strong></h3><p>一般是请求参数错误, 参数个数少了或者参数名与 api 要求不符;<br>&nbsp;</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a><strong>401 Unauthorized</strong></h3><p>请求未认证, 如果服务端需要用户密码认证而 request 未携带相关 header 则会返回此 code;<br>如果是 chrome 收到 401, 便会弹出内置的登陆框, 让用户输入用户密码;<br>如果需要手动发送 http 请求作认证, 需加入如下header:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># base64_encoded_content 是 username=password 被 BASE64 编码后的序列</span></span><br><span class=\"line\">Authorization: Basic base64_encoded_content</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个注意点:</p>\n<ol>\n<li><code>Authentication</code> header 的 value 必须是以 Basic 为前缀, 空一格后跟着 BASE64 编码的内容;</li>\n<li>BASE64 编码的内容是 username=password, 其中间的 <code>=</code> 不能少; 最方便的生成该编码的方法就是使用 chrome 或者 postman 自动生成, 然后查看 code 即可;</li>\n</ol>\n<p>&nbsp;</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a><strong>403 Forbidden</strong></h3><p>禁止访问(非法访问), 一般请求认证失败后返回此 code;<br>&nbsp;</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><strong>404 Not Found</strong></h3><p>找不到资源, 一般在 springMVC 工程里, 这种错误遇到的常见的情况是请求静态资源 (例如 healthcheck.html) 发生 404;<br>通常这种错误的原因是 springMVC 的 DispatcherServlet 拦截了所有的请求, 但是对静态资源的请求却又找不到路由处理器, 从而报出 404;<br>解决的方案主要有三种:<br>(1) web.xml 里配置 tomcat 的 default servlet:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.html<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 除了 *.html 之外, 其他静态资源亦可一并配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.js<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.css<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.jpg<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>此配置需放在 DispatcherServlet 前面从而在 springMVC 之前被拦截;</p>\n<p>(2) 在 mvc-context.xml 中配置 mvc namespace 下的 default-servlet-handler 标签:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>(3) 在 mvc-context.xml 中配置 mvc namespace 下的 resources 标签:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/**\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"/\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"405-Method-Not-Supported\"><a href=\"#405-Method-Not-Supported\" class=\"headerlink\" title=\"405 Method Not Supported\"></a><strong>405 Method Not Supported</strong></h3><p>&nbsp;</p>\n<h3 id=\"406-Not-Acceptable\"><a href=\"#406-Not-Acceptable\" class=\"headerlink\" title=\"406 Not Acceptable\"></a><strong>406 Not Acceptable</strong></h3><p>服务器端无法提供客户端在 <code>Accept</code> header 中给出的媒体类型; 在springMVC 工程里, 这种比较常见的情况, 一般和 json 有关, 往往还需要前端 (比如 ajax) 配合; 因为, 普通的请求, request 报文里一般不会指明 <code>Accept</code> header, 那么无论后端返回什么, 哪怕是报错也好, 都不至于造成 406; 而对于如下 ajax 请求:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajaxFileUpload(&#123;</span><br><span class=\"line\">    data: fetch_form_data(<span class=\"string\">'form_id'</span>),</span><br><span class=\"line\">    url: <span class=\"string\">'/xxx/yyy/zzz'</span></span><br><span class=\"line\">    type: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,   <span class=\"comment\">// 指定了 Accept header 为 application/json</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; ... &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, e</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 该 ajax 请求指定了 dataType 为 json, 这会在该 ajax 构造的 request 中追加 <code>Accept</code> header, value 为 <code>application/json</code>, 这就要求服务器端必须返回 json 类型的数据;<br>然后在后端 springMVC 工程里, 有如下几种情况可能会造成 web server 认为无法提供客户端指定的媒体类型:<br>(1) Controller 里的方法上没加 <code>@ResponseBody</code> 注解, 导致 springMVC 未能根据方法返回值正确推断媒体类型:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/xxx\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span>   <span class=\"comment\">// 该注解使得 springMVC 框架认为该请求需要转化为 json (should be bound to the web response body)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebResponse <span class=\"title\">handleRequest</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"xxx\"</span>)</span> String xxx) </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebResponse.success(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者更干脆的, 可以对该 Controller 直接使用 <code>@RestController</code> 注解, 相当于让所有的方法都被自动加上了 <code>@ResponseBody</code>:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A convenience annotation that is itself annotated with &#123;<span class=\"doctag\">@link</span> Controller <span class=\"doctag\">@Controller</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and &#123;<span class=\"doctag\">@link</span> ResponseBody <span class=\"doctag\">@ResponseBody</span>&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RestController &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) mvc-context.xml 中, 没有注册 “注解驱动”:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这个注解驱动的功能是如此之强大以至于在一般的 springMVC 项目中都不会落下它, 顶多就是覆盖其中部分设置以作微调 (详细的内容请参考: <a href=\"\">&lt;mvc:annotation-driven/&gt; 所做事情的详细梳理</a>);<br>当然, 如果不想被 &lt;mvc:annotation-driven/&gt; 支配而又要避免 406 错误, 就需要主动注入 <code>RequestMappingHandlerAdapter</code>, 而这是一个十分复杂的 bean, 所以并不建议这么搞;<br>(3) 如果第一点和第二点都没有问题却依然报 406 的话, 那么极有可能是 jackson 相关依赖的版本兼容性问题; 在默认的负责读写 json 的 <code>MappingJackson2HttpMessageConverter</code> 中 (v4.1.8.RELEASE), 有这么一句注释:</p>\n<blockquote>\n<p>Compatible with Jackson 2.1 and higher.</p>\n</blockquote>\n<p>而我在更高的 spring 版本里(比如 master), jackson 的最低兼容版本已经到了 2.9; 可见, 如果项目里的 jackson 版本不能与 spring 保持同步, 便极有可能导致序列化/反序列化失败, 进而导致 406 错误;<br>&nbsp;</p>\n<h3 id=\"407\"><a href=\"#407\" class=\"headerlink\" title=\"407\"></a><strong>407</strong></h3><h3 id=\"408-Request-Timeout\"><a href=\"#408-Request-Timeout\" class=\"headerlink\" title=\"408 Request Timeout\"></a><strong>408 Request Timeout</strong></h3><h3 id=\"409-Confilct\"><a href=\"#409-Confilct\" class=\"headerlink\" title=\"409 Confilct\"></a><strong>409 Confilct</strong></h3><h3 id=\"410\"><a href=\"#410\" class=\"headerlink\" title=\"410\"></a><strong>410</strong></h3><h3 id=\"411\"><a href=\"#411\" class=\"headerlink\" title=\"411\"></a><strong>411</strong></h3><h3 id=\"412\"><a href=\"#412\" class=\"headerlink\" title=\"412\"></a><strong>412</strong></h3><h3 id=\"413-Entity-Too-Large\"><a href=\"#413-Entity-Too-Large\" class=\"headerlink\" title=\"413 Entity Too Large\"></a><strong>413 Entity Too Large</strong></h3><h3 id=\"414\"><a href=\"#414\" class=\"headerlink\" title=\"414\"></a><strong>414</strong></h3><h3 id=\"415-Not-supported-media-type\"><a href=\"#415-Not-supported-media-type\" class=\"headerlink\" title=\"415 Not supported media type\"></a><strong>415 Not supported media type</strong></h3><h3 id=\"416\"><a href=\"#416\" class=\"headerlink\" title=\"416\"></a><strong>416</strong></h3><h3 id=\"417\"><a href=\"#417\" class=\"headerlink\" title=\"417\"></a><strong>417</strong></h3><h3 id=\"429-Too-Many-Requests\"><a href=\"#429-Too-Many-Requests\" class=\"headerlink\" title=\"429 Too Many Requests\"></a><strong>429 Too Many Requests</strong></h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>本人根据自身的工作经历, 以一个 java dev 的视角, 总结了一些 http status code 的常见问题, 原因及解决办法;<br>这些问题涉及到的系统或技术栈包括了 nginx, tomcat, spring(springMVC), elasticsearch 等等;</p>\n</blockquote>","more":"<hr>\n<h2 id=\"3XX-重定向系列\"><a href=\"#3XX-重定向系列\" class=\"headerlink\" title=\"3XX 重定向系列\"></a><strong>3XX 重定向系列</strong></h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a><strong>301 Moved Permanently</strong></h3><h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a><strong>302 Found</strong></h3><h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a><strong>303 See Other</strong></h3><h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a><strong>304 Not Modified</strong></h3><p>此状态码需要http header的配合:</p>\n<h3 id=\"307\"><a href=\"#307\" class=\"headerlink\" title=\"307\"></a><strong>307</strong></h3><h2 id=\"4XX-客户端错误系列\"><a href=\"#4XX-客户端错误系列\" class=\"headerlink\" title=\"4XX 客户端错误系列\"></a><strong>4XX 客户端错误系列</strong></h2><p>4XX 为客户端请求错误相关的 status code;<br>以下为各种 4XX status code 的含义以及可能的对应于常用 web server tomcat 或常用 web 框架 springMVC, 返回此 code 的原因;<br>其中, tomcat 的版本为 7.0.47.0, springMVC 的版本为 4.1.8.RELEASE<br>&nbsp;</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a><strong>400 Bad Request</strong></h3><p>一般是请求参数错误, 参数个数少了或者参数名与 api 要求不符;<br>&nbsp;</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a><strong>401 Unauthorized</strong></h3><p>请求未认证, 如果服务端需要用户密码认证而 request 未携带相关 header 则会返回此 code;<br>如果是 chrome 收到 401, 便会弹出内置的登陆框, 让用户输入用户密码;<br>如果需要手动发送 http 请求作认证, 需加入如下header:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># base64_encoded_content 是 username=password 被 BASE64 编码后的序列</span></span><br><span class=\"line\">Authorization: Basic base64_encoded_content</span><br></pre></td></tr></table></figure></p>\n<p>其中有两个注意点:</p>\n<ol>\n<li><code>Authentication</code> header 的 value 必须是以 Basic 为前缀, 空一格后跟着 BASE64 编码的内容;</li>\n<li>BASE64 编码的内容是 username=password, 其中间的 <code>=</code> 不能少; 最方便的生成该编码的方法就是使用 chrome 或者 postman 自动生成, 然后查看 code 即可;</li>\n</ol>\n<p>&nbsp;</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a><strong>403 Forbidden</strong></h3><p>禁止访问(非法访问), 一般请求认证失败后返回此 code;<br>&nbsp;</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><strong>404 Not Found</strong></h3><p>找不到资源, 一般在 springMVC 工程里, 这种错误遇到的常见的情况是请求静态资源 (例如 healthcheck.html) 发生 404;<br>通常这种错误的原因是 springMVC 的 DispatcherServlet 拦截了所有的请求, 但是对静态资源的请求却又找不到路由处理器, 从而报出 404;<br>解决的方案主要有三种:<br>(1) web.xml 里配置 tomcat 的 default servlet:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.html<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>另外, 除了 *.html 之外, 其他静态资源亦可一并配置:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.js<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.css<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>default<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.jpg<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>此配置需放在 DispatcherServlet 前面从而在 springMVC 之前被拦截;</p>\n<p>(2) 在 mvc-context.xml 中配置 mvc namespace 下的 default-servlet-handler 标签:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>(3) 在 mvc-context.xml 中配置 mvc namespace 下的 resources 标签:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/**\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"/\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<h3 id=\"405-Method-Not-Supported\"><a href=\"#405-Method-Not-Supported\" class=\"headerlink\" title=\"405 Method Not Supported\"></a><strong>405 Method Not Supported</strong></h3><p>&nbsp;</p>\n<h3 id=\"406-Not-Acceptable\"><a href=\"#406-Not-Acceptable\" class=\"headerlink\" title=\"406 Not Acceptable\"></a><strong>406 Not Acceptable</strong></h3><p>服务器端无法提供客户端在 <code>Accept</code> header 中给出的媒体类型; 在springMVC 工程里, 这种比较常见的情况, 一般和 json 有关, 往往还需要前端 (比如 ajax) 配合; 因为, 普通的请求, request 报文里一般不会指明 <code>Accept</code> header, 那么无论后端返回什么, 哪怕是报错也好, 都不至于造成 406; 而对于如下 ajax 请求:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajaxFileUpload(&#123;</span><br><span class=\"line\">    data: fetch_form_data(<span class=\"string\">'form_id'</span>),</span><br><span class=\"line\">    url: <span class=\"string\">'/xxx/yyy/zzz'</span></span><br><span class=\"line\">    type: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,   <span class=\"comment\">// 指定了 Accept header 为 application/json</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; ... &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, e</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 该 ajax 请求指定了 dataType 为 json, 这会在该 ajax 构造的 request 中追加 <code>Accept</code> header, value 为 <code>application/json</code>, 这就要求服务器端必须返回 json 类型的数据;<br>然后在后端 springMVC 工程里, 有如下几种情况可能会造成 web server 认为无法提供客户端指定的媒体类型:<br>(1) Controller 里的方法上没加 <code>@ResponseBody</code> 注解, 导致 springMVC 未能根据方法返回值正确推断媒体类型:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/xxx\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span>   <span class=\"comment\">// 该注解使得 springMVC 框架认为该请求需要转化为 json (should be bound to the web response body)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebResponse <span class=\"title\">handleRequest</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"xxx\"</span>)</span> String xxx) </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebResponse.success(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者更干脆的, 可以对该 Controller 直接使用 <code>@RestController</code> 注解, 相当于让所有的方法都被自动加上了 <code>@ResponseBody</code>:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A convenience annotation that is itself annotated with &#123;<span class=\"doctag\">@link</span> Controller <span class=\"doctag\">@Controller</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and &#123;<span class=\"doctag\">@link</span> ResponseBody <span class=\"doctag\">@ResponseBody</span>&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RestController &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) mvc-context.xml 中, 没有注册 “注解驱动”:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这个注解驱动的功能是如此之强大以至于在一般的 springMVC 项目中都不会落下它, 顶多就是覆盖其中部分设置以作微调 (详细的内容请参考: <a href=\"\">&lt;mvc:annotation-driven/&gt; 所做事情的详细梳理</a>);<br>当然, 如果不想被 &lt;mvc:annotation-driven/&gt; 支配而又要避免 406 错误, 就需要主动注入 <code>RequestMappingHandlerAdapter</code>, 而这是一个十分复杂的 bean, 所以并不建议这么搞;<br>(3) 如果第一点和第二点都没有问题却依然报 406 的话, 那么极有可能是 jackson 相关依赖的版本兼容性问题; 在默认的负责读写 json 的 <code>MappingJackson2HttpMessageConverter</code> 中 (v4.1.8.RELEASE), 有这么一句注释:</p>\n<blockquote>\n<p>Compatible with Jackson 2.1 and higher.</p>\n</blockquote>\n<p>而我在更高的 spring 版本里(比如 master), jackson 的最低兼容版本已经到了 2.9; 可见, 如果项目里的 jackson 版本不能与 spring 保持同步, 便极有可能导致序列化/反序列化失败, 进而导致 406 错误;<br>&nbsp;</p>\n<h3 id=\"407\"><a href=\"#407\" class=\"headerlink\" title=\"407\"></a><strong>407</strong></h3><h3 id=\"408-Request-Timeout\"><a href=\"#408-Request-Timeout\" class=\"headerlink\" title=\"408 Request Timeout\"></a><strong>408 Request Timeout</strong></h3><h3 id=\"409-Confilct\"><a href=\"#409-Confilct\" class=\"headerlink\" title=\"409 Confilct\"></a><strong>409 Confilct</strong></h3><h3 id=\"410\"><a href=\"#410\" class=\"headerlink\" title=\"410\"></a><strong>410</strong></h3><h3 id=\"411\"><a href=\"#411\" class=\"headerlink\" title=\"411\"></a><strong>411</strong></h3><h3 id=\"412\"><a href=\"#412\" class=\"headerlink\" title=\"412\"></a><strong>412</strong></h3><h3 id=\"413-Entity-Too-Large\"><a href=\"#413-Entity-Too-Large\" class=\"headerlink\" title=\"413 Entity Too Large\"></a><strong>413 Entity Too Large</strong></h3><h3 id=\"414\"><a href=\"#414\" class=\"headerlink\" title=\"414\"></a><strong>414</strong></h3><h3 id=\"415-Not-supported-media-type\"><a href=\"#415-Not-supported-media-type\" class=\"headerlink\" title=\"415 Not supported media type\"></a><strong>415 Not supported media type</strong></h3><h3 id=\"416\"><a href=\"#416\" class=\"headerlink\" title=\"416\"></a><strong>416</strong></h3><h3 id=\"417\"><a href=\"#417\" class=\"headerlink\" title=\"417\"></a><strong>417</strong></h3><h3 id=\"429-Too-Many-Requests\"><a href=\"#429-Too-Many-Requests\" class=\"headerlink\" title=\"429 Too Many Requests\"></a><strong>429 Too Many Requests</strong></h3>"},{"title":"一个 dev 的拙劣前端笔记: 使用 jQuery ajax 上传文件","date":"2018-02-03T13:48:08.000Z","_content":"\n> 从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;\n本文整理了从传统方式到 ajax 方式上传文件的各种方法;\n\n<!--more-->\n\n------\n\n### **传统的上传文件方式**\nform 表单有三种可能的 MIME 编码类型: 默认的 `application/x-www-form-urlencoded`, 不对字符编码而保留原始信息的 `multipart/form-data`, 以及纯文本 `text/plain`;\n如果没有异步刷新的需求, 只需要将 form 表单的 enctype 属性设置为 `multipart/form-data`, 便可以二进制的方式提交表单内容, 以达到上传文件的目的:\n``` html\n<form id=\"form_id\" enctype=\"multipart/form-data\">  \n    <input type=\"text\" name=\"str\" />  \n    <input type=\"file\" name=\"fileAttach\" />  \n    <input type=\"submit\" value=\"upload\" />  \n</form> \n```\n关于 MIME 类型 `multipart/form-data` 的更多内容, 请参见: [一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理]();\n&nbsp;\n**下面来讨论如何使用 ajax 实现文件上传;**\n\n### **使用 jQuery ajaxFileUpload 插件实现文件上传**\najax 默认使用的 MIME 类型是 `application/x-www-form-urlencoded`, 这种方式只适用于传输普通字符串类型的数据; 由于在 HTML4 时代, 没有对 javascript 提供文件读取的接口, 使用 `document.getElementById('field_id').value` 也只能获得文件的 name, 并不能拿到文件的二进制数据; 所以, 想直接使用 ajax 无刷新提交表单是无法做到的;\n所以只能采用间接的方案, 比如基于 jQuery 拓展的 ajaxFileUpload 插件, 其代码逻辑大致如下: \n\n1. function createUploadIframe():\n   创建一个独立的 iframe, 并追加到 body 中;\n2. function createUploadForm(file_elem_id):\n   创建一个独立的 form, 设置 enctype 为 `multipart/form-data`;\n   根据 file_elem_id 找到页面里的目标 `<input type=\"file\" />` 对象, 使用 jQuery.clone 方法, 将新的克隆对象替换到目标对象的位置, 而将原目标对象追加到新建的 form 中(偷梁换柱);\n   最后将新创建的 form 追加到 body 中;\n3. function addOtherRequestsToForm(data, new_form):\n   将页面中目标表单的其他元素数据, 一并追加到新创建的 form 里;\n4. function ajaxFileUpload: \n   调用 createUploadForm 方法创建新 form;\n   调用 addOtherRequestsToForm 方法捎带除 file 之外的其余元素数据;\n   调用 createUploadIFrame 方法创建 iframe;\n   将新 form 的 target 属性设置为新创建 iframe 的 id, 以实现间接的无刷新;\n   submit 提交新 form;\n\n&nbsp;\najaxFileUpload 的实现逻辑并不复杂, 类似这样的插件在 github 上有各种各样的版本, 我选取了一个比较典型的实现: [carlcarl/AjaxFileUpload/ajaxfileupload.js](https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js);\n然后开发者在实际使用时需要调用的是 `jQuery.ajaxFileUpload` 方法, 设置一些参数与回调方法:\n``` javascript\nfunction ajax_submit(field_id) {\n    $.ajaxFileUpload({\n        fileElementId: field_id,    // <input id=\"field_id\" type=\"file\">, 对应元素的 id\n        data: fetch_form_data('form_id'),   // 捎带其余元素的数据\n        url: '/xxx/yyy/upload'\n        type: 'post',\n        dataType: 'json',\n        secureuri: false,   //是否启用安全提交，默认为false\n        async : true,   //是否是异步\n        success: function(data) {\n            if (data['status'] == 0) {\n                window.location.reload();\n                alert(\"提交成功\");\n            } else {\n                window.location.reload();\n                alert(\"提交失败:\" + data['message']);\n            }\n        },\n        error: function(data, status, e) {\n            window.location.reload();\n            alert(\"提交失败:\" + data['message']);\n        }\n    });\n}\n// 将给定的表单数据转为对象\nfunction fetch_form_data(form_id) {\n    var params = $('#' + form_id).serializeArray();  \n    var values = {};  \n    for( x in params ) {  \n        values[params[x].name] = params[x].value;  \n    }  \n    return values\n}\n```\n抛开 iframe 的性能影响不谈, 看起来这样的 api 还是相当友好的, 与 jQuery.ajax 同样方便, 还解决了 ajax 不能传输二进制流的问题;\n另外, 由于这种方式真正提交的表单完全是 javascript 创建出来的, 页面上自己写的那个表单, 只作为数据 clone 的载体, 所以只需要确保表单和其中的 file input 元素有自己的 id, 最后提交按钮的 onclick 事件指向了目标方法即可;\n``` html\n<form id=\"form_id\">\n    <input type=\"text\" name=\"str\" />\n    <input id=\"file_attach\" type=\"file\" name=\"fileAttach\" />\n    <input type=\"button\" onclick=\"ajax_submit('file_attach')\"  value=\"upload\" />\n</form>\n```\n\n### **使用 jQuery ajax 结合 HTML5 API 实现文件上传**\n使用 ajaxFileUplaod 插件, 无论怎么优化改造, 其需要使用 iframe 作间接无刷新的逻辑是没法绕开的; 而使用 iframe 必然会带来额外资源的消耗, 如果有更原生直接的解决方案, 我们一定乐于在项目中取代 ajaxFileUpload;\n于是, 在 HTML5 时代, 出现了一个新的接口: `FormData`, 它给出了完美的解决方案;\n``` javascript\nvar form_content = new FormData(document.getElementById(\"form_id\"));\n```\n这行代码便拿到了目标表单对象的所有信息; 我们只需要确保表单的 enctype 属性为 `multipart/form-data`, 通过该接口获得的 FormData 对象, 便是完整的二进制序列化信息:\n``` html\n<form id=\"form_id\" enctype=\"multipart/form-data\">\n    <input type=\"text\" name=\"str\" />\n    <input type=\"file\" name=\"fileAttach\" />\n    <input type=\"button\" onclick=\"upload_file()\"  value=\"upload\" />\n</form>\n```\n这样, 一个 onclick 事件触发 upload_file 方法, 使用原生的 jQuery ajax 就实现了上传文件的功能了, 同时表单内的其他字符串数据, 也一并以 multi part 的形式上传上去了;\n对应的 javascript upload_file 方法如下: \n``` javascript\nfunction uplaod_file() {\n    var form_content = new FormData(document.getElementById('form_id'));\n    $.ajax({\n        type: 'POST',\n        url: '/xxx/yyy/upload',\n        data: form_content,\n        processData: false,     // 阻止默认的 application/x-www-form-urlencoded 对象处理方法\n        contentType: false,     // 与 processData 保持一直, 不使用默认的 application/x-www-form-urlencoded\n        success: function (data) {\n            if (data['status'] == 0) {\n                window.location.reload();\n                alert(\"提交成功\");\n            } else {\n                window.location.reload();\n                alert(\"提交失败:\" + data['message']);\n            }\n        },\n        fail: function (data) {\n            window.location.reload();\n            alert(\"提交失败:\" + data['message']);\n        }\n    });\n}\n```\n以上代码需要注意的是:\n`processData` 参数默认为 true, 即将 data 转为 url 键值对形式, 这里已经是序列化后的二进制数据, 不需要再次处理,  所以应主动设置其为 false;\n同时, `contentType` 默认为 `application/x-www-form-urlencoded`, 这里不应该使用默认值;\n关于 jQuery ajax 方法, 更多的内容请参见: [jQuery ajax 阅读与理解]();\n&nbsp;\n这便是 HTML5 时代下,  ajax 异步上传文件的最佳实践;\n\n### **站内相关文章**\n- [一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理]()\n- [jQuery ajax 阅读与理解]()\n\n### **参考链接**\n- [jquery Ajax提交表单(使用jquery Ajax上传附件)](http://blog.csdn.net/qq_33556185/article/details/51086114)\n- [JQuery的ajaxFileUpload的使用](https://www.cnblogs.com/zhanghaoliang/p/6513964.html)\n- [carlcarl/AjaxFileUpload/ajaxfileupload.js](https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js)\n- [jquery插件--ajaxfileupload.js上传文件原理分析](http://blog.csdn.net/it_man/article/details/43800957)\n\n","source":"_posts/web--一个dev的拙劣前端笔记_使用jQuery_ajax上传文件.md","raw":"---\ntitle: '一个 dev 的拙劣前端笔记: 使用 jQuery ajax 上传文件'\ndate: 2018-02-03 21:48:08\ncategories:\n - web\ntags:\n - ajax\n - jQuery\n - 文件上传\n---\n\n> 从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;\n本文整理了从传统方式到 ajax 方式上传文件的各种方法;\n\n<!--more-->\n\n------\n\n### **传统的上传文件方式**\nform 表单有三种可能的 MIME 编码类型: 默认的 `application/x-www-form-urlencoded`, 不对字符编码而保留原始信息的 `multipart/form-data`, 以及纯文本 `text/plain`;\n如果没有异步刷新的需求, 只需要将 form 表单的 enctype 属性设置为 `multipart/form-data`, 便可以二进制的方式提交表单内容, 以达到上传文件的目的:\n``` html\n<form id=\"form_id\" enctype=\"multipart/form-data\">  \n    <input type=\"text\" name=\"str\" />  \n    <input type=\"file\" name=\"fileAttach\" />  \n    <input type=\"submit\" value=\"upload\" />  \n</form> \n```\n关于 MIME 类型 `multipart/form-data` 的更多内容, 请参见: [一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理]();\n&nbsp;\n**下面来讨论如何使用 ajax 实现文件上传;**\n\n### **使用 jQuery ajaxFileUpload 插件实现文件上传**\najax 默认使用的 MIME 类型是 `application/x-www-form-urlencoded`, 这种方式只适用于传输普通字符串类型的数据; 由于在 HTML4 时代, 没有对 javascript 提供文件读取的接口, 使用 `document.getElementById('field_id').value` 也只能获得文件的 name, 并不能拿到文件的二进制数据; 所以, 想直接使用 ajax 无刷新提交表单是无法做到的;\n所以只能采用间接的方案, 比如基于 jQuery 拓展的 ajaxFileUpload 插件, 其代码逻辑大致如下: \n\n1. function createUploadIframe():\n   创建一个独立的 iframe, 并追加到 body 中;\n2. function createUploadForm(file_elem_id):\n   创建一个独立的 form, 设置 enctype 为 `multipart/form-data`;\n   根据 file_elem_id 找到页面里的目标 `<input type=\"file\" />` 对象, 使用 jQuery.clone 方法, 将新的克隆对象替换到目标对象的位置, 而将原目标对象追加到新建的 form 中(偷梁换柱);\n   最后将新创建的 form 追加到 body 中;\n3. function addOtherRequestsToForm(data, new_form):\n   将页面中目标表单的其他元素数据, 一并追加到新创建的 form 里;\n4. function ajaxFileUpload: \n   调用 createUploadForm 方法创建新 form;\n   调用 addOtherRequestsToForm 方法捎带除 file 之外的其余元素数据;\n   调用 createUploadIFrame 方法创建 iframe;\n   将新 form 的 target 属性设置为新创建 iframe 的 id, 以实现间接的无刷新;\n   submit 提交新 form;\n\n&nbsp;\najaxFileUpload 的实现逻辑并不复杂, 类似这样的插件在 github 上有各种各样的版本, 我选取了一个比较典型的实现: [carlcarl/AjaxFileUpload/ajaxfileupload.js](https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js);\n然后开发者在实际使用时需要调用的是 `jQuery.ajaxFileUpload` 方法, 设置一些参数与回调方法:\n``` javascript\nfunction ajax_submit(field_id) {\n    $.ajaxFileUpload({\n        fileElementId: field_id,    // <input id=\"field_id\" type=\"file\">, 对应元素的 id\n        data: fetch_form_data('form_id'),   // 捎带其余元素的数据\n        url: '/xxx/yyy/upload'\n        type: 'post',\n        dataType: 'json',\n        secureuri: false,   //是否启用安全提交，默认为false\n        async : true,   //是否是异步\n        success: function(data) {\n            if (data['status'] == 0) {\n                window.location.reload();\n                alert(\"提交成功\");\n            } else {\n                window.location.reload();\n                alert(\"提交失败:\" + data['message']);\n            }\n        },\n        error: function(data, status, e) {\n            window.location.reload();\n            alert(\"提交失败:\" + data['message']);\n        }\n    });\n}\n// 将给定的表单数据转为对象\nfunction fetch_form_data(form_id) {\n    var params = $('#' + form_id).serializeArray();  \n    var values = {};  \n    for( x in params ) {  \n        values[params[x].name] = params[x].value;  \n    }  \n    return values\n}\n```\n抛开 iframe 的性能影响不谈, 看起来这样的 api 还是相当友好的, 与 jQuery.ajax 同样方便, 还解决了 ajax 不能传输二进制流的问题;\n另外, 由于这种方式真正提交的表单完全是 javascript 创建出来的, 页面上自己写的那个表单, 只作为数据 clone 的载体, 所以只需要确保表单和其中的 file input 元素有自己的 id, 最后提交按钮的 onclick 事件指向了目标方法即可;\n``` html\n<form id=\"form_id\">\n    <input type=\"text\" name=\"str\" />\n    <input id=\"file_attach\" type=\"file\" name=\"fileAttach\" />\n    <input type=\"button\" onclick=\"ajax_submit('file_attach')\"  value=\"upload\" />\n</form>\n```\n\n### **使用 jQuery ajax 结合 HTML5 API 实现文件上传**\n使用 ajaxFileUplaod 插件, 无论怎么优化改造, 其需要使用 iframe 作间接无刷新的逻辑是没法绕开的; 而使用 iframe 必然会带来额外资源的消耗, 如果有更原生直接的解决方案, 我们一定乐于在项目中取代 ajaxFileUpload;\n于是, 在 HTML5 时代, 出现了一个新的接口: `FormData`, 它给出了完美的解决方案;\n``` javascript\nvar form_content = new FormData(document.getElementById(\"form_id\"));\n```\n这行代码便拿到了目标表单对象的所有信息; 我们只需要确保表单的 enctype 属性为 `multipart/form-data`, 通过该接口获得的 FormData 对象, 便是完整的二进制序列化信息:\n``` html\n<form id=\"form_id\" enctype=\"multipart/form-data\">\n    <input type=\"text\" name=\"str\" />\n    <input type=\"file\" name=\"fileAttach\" />\n    <input type=\"button\" onclick=\"upload_file()\"  value=\"upload\" />\n</form>\n```\n这样, 一个 onclick 事件触发 upload_file 方法, 使用原生的 jQuery ajax 就实现了上传文件的功能了, 同时表单内的其他字符串数据, 也一并以 multi part 的形式上传上去了;\n对应的 javascript upload_file 方法如下: \n``` javascript\nfunction uplaod_file() {\n    var form_content = new FormData(document.getElementById('form_id'));\n    $.ajax({\n        type: 'POST',\n        url: '/xxx/yyy/upload',\n        data: form_content,\n        processData: false,     // 阻止默认的 application/x-www-form-urlencoded 对象处理方法\n        contentType: false,     // 与 processData 保持一直, 不使用默认的 application/x-www-form-urlencoded\n        success: function (data) {\n            if (data['status'] == 0) {\n                window.location.reload();\n                alert(\"提交成功\");\n            } else {\n                window.location.reload();\n                alert(\"提交失败:\" + data['message']);\n            }\n        },\n        fail: function (data) {\n            window.location.reload();\n            alert(\"提交失败:\" + data['message']);\n        }\n    });\n}\n```\n以上代码需要注意的是:\n`processData` 参数默认为 true, 即将 data 转为 url 键值对形式, 这里已经是序列化后的二进制数据, 不需要再次处理,  所以应主动设置其为 false;\n同时, `contentType` 默认为 `application/x-www-form-urlencoded`, 这里不应该使用默认值;\n关于 jQuery ajax 方法, 更多的内容请参见: [jQuery ajax 阅读与理解]();\n&nbsp;\n这便是 HTML5 时代下,  ajax 异步上传文件的最佳实践;\n\n### **站内相关文章**\n- [一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理]()\n- [jQuery ajax 阅读与理解]()\n\n### **参考链接**\n- [jquery Ajax提交表单(使用jquery Ajax上传附件)](http://blog.csdn.net/qq_33556185/article/details/51086114)\n- [JQuery的ajaxFileUpload的使用](https://www.cnblogs.com/zhanghaoliang/p/6513964.html)\n- [carlcarl/AjaxFileUpload/ajaxfileupload.js](https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js)\n- [jquery插件--ajaxfileupload.js上传文件原理分析](http://blog.csdn.net/it_man/article/details/43800957)\n\n","slug":"web--一个dev的拙劣前端笔记_使用jQuery_ajax上传文件","published":1,"updated":"2018-02-07T15:43:29.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgndpd810058j1jxsfagdyan","content":"<blockquote>\n<p>从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;<br>本文整理了从传统方式到 ajax 方式上传文件的各种方法;</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"传统的上传文件方式\"><a href=\"#传统的上传文件方式\" class=\"headerlink\" title=\"传统的上传文件方式\"></a><strong>传统的上传文件方式</strong></h3><p>form 表单有三种可能的 MIME 编码类型: 默认的 <code>application/x-www-form-urlencoded</code>, 不对字符编码而保留原始信息的 <code>multipart/form-data</code>, 以及纯文本 <code>text/plain</code>;<br>如果没有异步刷新的需求, 只需要将 form 表单的 enctype 属性设置为 <code>multipart/form-data</code>, 便可以二进制的方式提交表单内容, 以达到上传文件的目的:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>关于 MIME 类型 <code>multipart/form-data</code> 的更多内容, 请参见: <a href=\"\">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a>;<br>&nbsp;<br><strong>下面来讨论如何使用 ajax 实现文件上传;</strong></p>\n<h3 id=\"使用-jQuery-ajaxFileUpload-插件实现文件上传\"><a href=\"#使用-jQuery-ajaxFileUpload-插件实现文件上传\" class=\"headerlink\" title=\"使用 jQuery ajaxFileUpload 插件实现文件上传\"></a><strong>使用 jQuery ajaxFileUpload 插件实现文件上传</strong></h3><p>ajax 默认使用的 MIME 类型是 <code>application/x-www-form-urlencoded</code>, 这种方式只适用于传输普通字符串类型的数据; 由于在 HTML4 时代, 没有对 javascript 提供文件读取的接口, 使用 <code>document.getElementById(&#39;field_id&#39;).value</code> 也只能获得文件的 name, 并不能拿到文件的二进制数据; 所以, 想直接使用 ajax 无刷新提交表单是无法做到的;<br>所以只能采用间接的方案, 比如基于 jQuery 拓展的 ajaxFileUpload 插件, 其代码逻辑大致如下: </p>\n<ol>\n<li>function createUploadIframe():<br>创建一个独立的 iframe, 并追加到 body 中;</li>\n<li>function createUploadForm(file_elem_id):<br>创建一个独立的 form, 设置 enctype 为 <code>multipart/form-data</code>;<br>根据 file_elem_id 找到页面里的目标 <code>&lt;input type=&quot;file&quot; /&gt;</code> 对象, 使用 jQuery.clone 方法, 将新的克隆对象替换到目标对象的位置, 而将原目标对象追加到新建的 form 中(偷梁换柱);<br>最后将新创建的 form 追加到 body 中;</li>\n<li>function addOtherRequestsToForm(data, new_form):<br>将页面中目标表单的其他元素数据, 一并追加到新创建的 form 里;</li>\n<li>function ajaxFileUpload:<br>调用 createUploadForm 方法创建新 form;<br>调用 addOtherRequestsToForm 方法捎带除 file 之外的其余元素数据;<br>调用 createUploadIFrame 方法创建 iframe;<br>将新 form 的 target 属性设置为新创建 iframe 的 id, 以实现间接的无刷新;<br>submit 提交新 form;</li>\n</ol>\n<p>&nbsp;<br>ajaxFileUpload 的实现逻辑并不复杂, 类似这样的插件在 github 上有各种各样的版本, 我选取了一个比较典型的实现: <a href=\"https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js\" target=\"_blank\" rel=\"noopener\">carlcarl/AjaxFileUpload/ajaxfileupload.js</a>;<br>然后开发者在实际使用时需要调用的是 <code>jQuery.ajaxFileUpload</code> 方法, 设置一些参数与回调方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax_submit</span>(<span class=\"params\">field_id</span>) </span>&#123;</span><br><span class=\"line\">    $.ajaxFileUpload(&#123;</span><br><span class=\"line\">        fileElementId: field_id,    <span class=\"comment\">// &lt;input id=\"field_id\" type=\"file\"&gt;, 对应元素的 id</span></span><br><span class=\"line\">        data: fetch_form_data(<span class=\"string\">'form_id'</span>),   <span class=\"comment\">// 捎带其余元素的数据</span></span><br><span class=\"line\">        url: <span class=\"string\">'/xxx/yyy/upload'</span></span><br><span class=\"line\">        type: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">        dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">        secureuri: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用安全提交，默认为false</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> : <span class=\"literal\">true</span>,   <span class=\"comment\">//是否是异步</span></span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'status'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交成功\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">            alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将给定的表单数据转为对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch_form_data</span>(<span class=\"params\">form_id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = $(<span class=\"string\">'#'</span> + form_id).serializeArray();  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = &#123;&#125;;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( x <span class=\"keyword\">in</span> params ) &#123;  </span><br><span class=\"line\">        values[params[x].name] = params[x].value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> values</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抛开 iframe 的性能影响不谈, 看起来这样的 api 还是相当友好的, 与 jQuery.ajax 同样方便, 还解决了 ajax 不能传输二进制流的问题;<br>另外, 由于这种方式真正提交的表单完全是 javascript 创建出来的, 页面上自己写的那个表单, 只作为数据 clone 的载体, 所以只需要确保表单和其中的 file input 元素有自己的 id, 最后提交按钮的 onclick 事件指向了目标方法即可;<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"file_attach\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"ajax_submit('file_attach')\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-jQuery-ajax-结合-HTML5-API-实现文件上传\"><a href=\"#使用-jQuery-ajax-结合-HTML5-API-实现文件上传\" class=\"headerlink\" title=\"使用 jQuery ajax 结合 HTML5 API 实现文件上传\"></a><strong>使用 jQuery ajax 结合 HTML5 API 实现文件上传</strong></h3><p>使用 ajaxFileUplaod 插件, 无论怎么优化改造, 其需要使用 iframe 作间接无刷新的逻辑是没法绕开的; 而使用 iframe 必然会带来额外资源的消耗, 如果有更原生直接的解决方案, 我们一定乐于在项目中取代 ajaxFileUpload;<br>于是, 在 HTML5 时代, 出现了一个新的接口: <code>FormData</code>, 它给出了完美的解决方案;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form_content = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"form_id\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这行代码便拿到了目标表单对象的所有信息; 我们只需要确保表单的 enctype 属性为 <code>multipart/form-data</code>, 通过该接口获得的 FormData 对象, 便是完整的二进制序列化信息:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"upload_file()\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样, 一个 onclick 事件触发 upload_file 方法, 使用原生的 jQuery ajax 就实现了上传文件的功能了, 同时表单内的其他字符串数据, 也一并以 multi part 的形式上传上去了;<br>对应的 javascript upload_file 方法如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uplaod_file</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> form_content = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form_id'</span>));</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'/xxx/yyy/upload'</span>,</span><br><span class=\"line\">        data: form_content,</span><br><span class=\"line\">        processData: <span class=\"literal\">false</span>,     <span class=\"comment\">// 阻止默认的 application/x-www-form-urlencoded 对象处理方法</span></span><br><span class=\"line\">        contentType: <span class=\"literal\">false</span>,     <span class=\"comment\">// 与 processData 保持一直, 不使用默认的 application/x-www-form-urlencoded</span></span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'status'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交成功\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">            alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码需要注意的是:<br><code>processData</code> 参数默认为 true, 即将 data 转为 url 键值对形式, 这里已经是序列化后的二进制数据, 不需要再次处理,  所以应主动设置其为 false;<br>同时, <code>contentType</code> 默认为 <code>application/x-www-form-urlencoded</code>, 这里不应该使用默认值;<br>关于 jQuery ajax 方法, 更多的内容请参见: <a href=\"\">jQuery ajax 阅读与理解</a>;<br>&nbsp;<br>这便是 HTML5 时代下,  ajax 异步上传文件的最佳实践;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a></li>\n<li><a href=\"\">jQuery ajax 阅读与理解</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://blog.csdn.net/qq_33556185/article/details/51086114\" target=\"_blank\" rel=\"noopener\">jquery Ajax提交表单(使用jquery Ajax上传附件)</a></li>\n<li><a href=\"https://www.cnblogs.com/zhanghaoliang/p/6513964.html\" target=\"_blank\" rel=\"noopener\">JQuery的ajaxFileUpload的使用</a></li>\n<li><a href=\"https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js\" target=\"_blank\" rel=\"noopener\">carlcarl/AjaxFileUpload/ajaxfileupload.js</a></li>\n<li><a href=\"http://blog.csdn.net/it_man/article/details/43800957\" target=\"_blank\" rel=\"noopener\">jquery插件–ajaxfileupload.js上传文件原理分析</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;<br>本文整理了从传统方式到 ajax 方式上传文件的各种方法;</p>\n</blockquote>","more":"<hr>\n<h3 id=\"传统的上传文件方式\"><a href=\"#传统的上传文件方式\" class=\"headerlink\" title=\"传统的上传文件方式\"></a><strong>传统的上传文件方式</strong></h3><p>form 表单有三种可能的 MIME 编码类型: 默认的 <code>application/x-www-form-urlencoded</code>, 不对字符编码而保留原始信息的 <code>multipart/form-data</code>, 以及纯文本 <code>text/plain</code>;<br>如果没有异步刷新的需求, 只需要将 form 表单的 enctype 属性设置为 <code>multipart/form-data</code>, 便可以二进制的方式提交表单内容, 以达到上传文件的目的:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>关于 MIME 类型 <code>multipart/form-data</code> 的更多内容, 请参见: <a href=\"\">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a>;<br>&nbsp;<br><strong>下面来讨论如何使用 ajax 实现文件上传;</strong></p>\n<h3 id=\"使用-jQuery-ajaxFileUpload-插件实现文件上传\"><a href=\"#使用-jQuery-ajaxFileUpload-插件实现文件上传\" class=\"headerlink\" title=\"使用 jQuery ajaxFileUpload 插件实现文件上传\"></a><strong>使用 jQuery ajaxFileUpload 插件实现文件上传</strong></h3><p>ajax 默认使用的 MIME 类型是 <code>application/x-www-form-urlencoded</code>, 这种方式只适用于传输普通字符串类型的数据; 由于在 HTML4 时代, 没有对 javascript 提供文件读取的接口, 使用 <code>document.getElementById(&#39;field_id&#39;).value</code> 也只能获得文件的 name, 并不能拿到文件的二进制数据; 所以, 想直接使用 ajax 无刷新提交表单是无法做到的;<br>所以只能采用间接的方案, 比如基于 jQuery 拓展的 ajaxFileUpload 插件, 其代码逻辑大致如下: </p>\n<ol>\n<li>function createUploadIframe():<br>创建一个独立的 iframe, 并追加到 body 中;</li>\n<li>function createUploadForm(file_elem_id):<br>创建一个独立的 form, 设置 enctype 为 <code>multipart/form-data</code>;<br>根据 file_elem_id 找到页面里的目标 <code>&lt;input type=&quot;file&quot; /&gt;</code> 对象, 使用 jQuery.clone 方法, 将新的克隆对象替换到目标对象的位置, 而将原目标对象追加到新建的 form 中(偷梁换柱);<br>最后将新创建的 form 追加到 body 中;</li>\n<li>function addOtherRequestsToForm(data, new_form):<br>将页面中目标表单的其他元素数据, 一并追加到新创建的 form 里;</li>\n<li>function ajaxFileUpload:<br>调用 createUploadForm 方法创建新 form;<br>调用 addOtherRequestsToForm 方法捎带除 file 之外的其余元素数据;<br>调用 createUploadIFrame 方法创建 iframe;<br>将新 form 的 target 属性设置为新创建 iframe 的 id, 以实现间接的无刷新;<br>submit 提交新 form;</li>\n</ol>\n<p>&nbsp;<br>ajaxFileUpload 的实现逻辑并不复杂, 类似这样的插件在 github 上有各种各样的版本, 我选取了一个比较典型的实现: <a href=\"https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js\" target=\"_blank\" rel=\"noopener\">carlcarl/AjaxFileUpload/ajaxfileupload.js</a>;<br>然后开发者在实际使用时需要调用的是 <code>jQuery.ajaxFileUpload</code> 方法, 设置一些参数与回调方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax_submit</span>(<span class=\"params\">field_id</span>) </span>&#123;</span><br><span class=\"line\">    $.ajaxFileUpload(&#123;</span><br><span class=\"line\">        fileElementId: field_id,    <span class=\"comment\">// &lt;input id=\"field_id\" type=\"file\"&gt;, 对应元素的 id</span></span><br><span class=\"line\">        data: fetch_form_data(<span class=\"string\">'form_id'</span>),   <span class=\"comment\">// 捎带其余元素的数据</span></span><br><span class=\"line\">        url: <span class=\"string\">'/xxx/yyy/upload'</span></span><br><span class=\"line\">        type: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">        dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">        secureuri: <span class=\"literal\">false</span>,   <span class=\"comment\">//是否启用安全提交，默认为false</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> : <span class=\"literal\">true</span>,   <span class=\"comment\">//是否是异步</span></span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'status'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交成功\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">            alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将给定的表单数据转为对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch_form_data</span>(<span class=\"params\">form_id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = $(<span class=\"string\">'#'</span> + form_id).serializeArray();  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = &#123;&#125;;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( x <span class=\"keyword\">in</span> params ) &#123;  </span><br><span class=\"line\">        values[params[x].name] = params[x].value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> values</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抛开 iframe 的性能影响不谈, 看起来这样的 api 还是相当友好的, 与 jQuery.ajax 同样方便, 还解决了 ajax 不能传输二进制流的问题;<br>另外, 由于这种方式真正提交的表单完全是 javascript 创建出来的, 页面上自己写的那个表单, 只作为数据 clone 的载体, 所以只需要确保表单和其中的 file input 元素有自己的 id, 最后提交按钮的 onclick 事件指向了目标方法即可;<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"file_attach\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"ajax_submit('file_attach')\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-jQuery-ajax-结合-HTML5-API-实现文件上传\"><a href=\"#使用-jQuery-ajax-结合-HTML5-API-实现文件上传\" class=\"headerlink\" title=\"使用 jQuery ajax 结合 HTML5 API 实现文件上传\"></a><strong>使用 jQuery ajax 结合 HTML5 API 实现文件上传</strong></h3><p>使用 ajaxFileUplaod 插件, 无论怎么优化改造, 其需要使用 iframe 作间接无刷新的逻辑是没法绕开的; 而使用 iframe 必然会带来额外资源的消耗, 如果有更原生直接的解决方案, 我们一定乐于在项目中取代 ajaxFileUpload;<br>于是, 在 HTML5 时代, 出现了一个新的接口: <code>FormData</code>, 它给出了完美的解决方案;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form_content = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"form_id\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这行代码便拿到了目标表单对象的所有信息; 我们只需要确保表单的 enctype 属性为 <code>multipart/form-data</code>, 通过该接口获得的 FormData 对象, 便是完整的二进制序列化信息:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"form_id\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"str\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fileAttach\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"upload_file()\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"upload\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样, 一个 onclick 事件触发 upload_file 方法, 使用原生的 jQuery ajax 就实现了上传文件的功能了, 同时表单内的其他字符串数据, 也一并以 multi part 的形式上传上去了;<br>对应的 javascript upload_file 方法如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uplaod_file</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> form_content = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'form_id'</span>));</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'/xxx/yyy/upload'</span>,</span><br><span class=\"line\">        data: form_content,</span><br><span class=\"line\">        processData: <span class=\"literal\">false</span>,     <span class=\"comment\">// 阻止默认的 application/x-www-form-urlencoded 对象处理方法</span></span><br><span class=\"line\">        contentType: <span class=\"literal\">false</span>,     <span class=\"comment\">// 与 processData 保持一直, 不使用默认的 application/x-www-form-urlencoded</span></span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'status'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交成功\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">                alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fail: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.location.reload();</span><br><span class=\"line\">            alert(<span class=\"string\">\"提交失败:\"</span> + data[<span class=\"string\">'message'</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码需要注意的是:<br><code>processData</code> 参数默认为 true, 即将 data 转为 url 键值对形式, 这里已经是序列化后的二进制数据, 不需要再次处理,  所以应主动设置其为 false;<br>同时, <code>contentType</code> 默认为 <code>application/x-www-form-urlencoded</code>, 这里不应该使用默认值;<br>关于 jQuery ajax 方法, 更多的内容请参见: <a href=\"\">jQuery ajax 阅读与理解</a>;<br>&nbsp;<br>这便是 HTML5 时代下,  ajax 异步上传文件的最佳实践;</p>\n<h3 id=\"站内相关文章\"><a href=\"#站内相关文章\" class=\"headerlink\" title=\"站内相关文章\"></a><strong>站内相关文章</strong></h3><ul>\n<li><a href=\"\">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a></li>\n<li><a href=\"\">jQuery ajax 阅读与理解</a></li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h3><ul>\n<li><a href=\"http://blog.csdn.net/qq_33556185/article/details/51086114\" target=\"_blank\" rel=\"noopener\">jquery Ajax提交表单(使用jquery Ajax上传附件)</a></li>\n<li><a href=\"https://www.cnblogs.com/zhanghaoliang/p/6513964.html\" target=\"_blank\" rel=\"noopener\">JQuery的ajaxFileUpload的使用</a></li>\n<li><a href=\"https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js\" target=\"_blank\" rel=\"noopener\">carlcarl/AjaxFileUpload/ajaxfileupload.js</a></li>\n<li><a href=\"http://blog.csdn.net/it_man/article/details/43800957\" target=\"_blank\" rel=\"noopener\">jquery插件–ajaxfileupload.js上传文件原理分析</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjgndpd5g0006j1jxbvhw18n8","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd5x000sj1jx12aqc1dn"},{"post_id":"cjgndpd5g0006j1jxbvhw18n8","category_id":"cjgndpd5r000hj1jx5404acux","_id":"cjgndpd5z000wj1jx8gs52wwc"},{"post_id":"cjgndpd550000j1jxaqi6uods","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd60000yj1jxy67lgpq3"},{"post_id":"cjgndpd550000j1jxaqi6uods","category_id":"cjgndpd5u000mj1jx6j6ooii7","_id":"cjgndpd630012j1jx7k8l7ac9"},{"post_id":"cjgndpd5h0007j1jxjn2mzt4d","category_id":"cjgndpd5x000tj1jxp2y1ot2e","_id":"cjgndpd650015j1jxgawqxofm"},{"post_id":"cjgndpd5l000bj1jxoek3fwgd","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd69001cj1jx4yttwd6r"},{"post_id":"cjgndpd5l000bj1jxoek3fwgd","category_id":"cjgndpd60000zj1jxa739azjz","_id":"cjgndpd6b001gj1jxiloh5hx1"},{"post_id":"cjgndpd5a0002j1jxm51im9lb","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6c001jj1jxcfp54y48"},{"post_id":"cjgndpd5a0002j1jxm51im9lb","category_id":"cjgndpd660018j1jx63ur2y9f","_id":"cjgndpd6f001oj1jx66ss4riu"},{"post_id":"cjgndpd5n000cj1jx31txzd10","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6i001sj1jxpub7wfzu"},{"post_id":"cjgndpd5n000cj1jx31txzd10","category_id":"cjgndpd69001dj1jxjxttf53z","_id":"cjgndpd6l001vj1jx9wbk14v3"},{"post_id":"cjgndpd5p000fj1jxyqyjlm8z","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6m001xj1jxmpq7e733"},{"post_id":"cjgndpd5p000fj1jxyqyjlm8z","category_id":"cjgndpd69001dj1jxjxttf53z","_id":"cjgndpd6n001zj1jxntbvt3af"},{"post_id":"cjgndpd5e0005j1jxwyogtosg","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6n0021j1jxptzf7sbb"},{"post_id":"cjgndpd5e0005j1jxwyogtosg","category_id":"cjgndpd5r000hj1jx5404acux","_id":"cjgndpd6o0025j1jxlj6g0hh4"},{"post_id":"cjgndpd5q000gj1jxcj9qjmz2","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6p0027j1jxx8i8dk2e"},{"post_id":"cjgndpd5q000gj1jxcj9qjmz2","category_id":"cjgndpd6m001wj1jxtiivyikm","_id":"cjgndpd6q002aj1jx7rt6q6tj"},{"post_id":"cjgndpd5s000jj1jxvh981tm6","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6r002dj1jx2w2q3fi1"},{"post_id":"cjgndpd5s000jj1jxvh981tm6","category_id":"cjgndpd6o0022j1jxefe112il","_id":"cjgndpd6r002fj1jxy10dzz6l"},{"post_id":"cjgndpd5t000lj1jxfiitwb80","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6s002hj1jx04qhoxb6"},{"post_id":"cjgndpd5t000lj1jxfiitwb80","category_id":"cjgndpd60000zj1jxa739azjz","_id":"cjgndpd6t002kj1jxydzgcjyg"},{"post_id":"cjgndpd5v000pj1jxcyk0b9j9","category_id":"cjgndpd6r002cj1jxv6kbfrs2","_id":"cjgndpd6u002mj1jx5ittdra6"},{"post_id":"cjgndpd5w000rj1jxbpdxtge7","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6x002rj1jxyrwqjuh0"},{"post_id":"cjgndpd5w000rj1jxbpdxtge7","category_id":"cjgndpd6s002ij1jxjyxdyojt","_id":"cjgndpd6y002tj1jx42uovut4"},{"post_id":"cjgndpd5y000vj1jxk0jacm2w","category_id":"cjgndpd5c0003j1jxbwm9vvql","_id":"cjgndpd6y002vj1jxw7vzvirn"},{"post_id":"cjgndpd5y000vj1jxk0jacm2w","category_id":"cjgndpd60000zj1jxa739azjz","_id":"cjgndpd6z002yj1jxvxmlbt0b"},{"post_id":"cjgndpd5z000xj1jxyd7zq5wl","category_id":"cjgndpd6w002qj1jx413r9g8n","_id":"cjgndpd700030j1jxw52ilpta"},{"post_id":"cjgndpd6b001ij1jxmj9ksqwj","category_id":"cjgndpd77003fj1jxy8rvnmit","_id":"cjgndpd79003lj1jx290sovph"},{"post_id":"cjgndpd6j001tj1jxjcbxas3p","category_id":"cjgndpd7a003pj1jxbhvvobnx","_id":"cjgndpd7e003vj1jxeiikntj1"},{"post_id":"cjgndpd610010j1jxsrrl9a9i","category_id":"cjgndpd6y002wj1jxnlr31fio","_id":"cjgndpd7g003yj1jx3vojvr8w"},{"post_id":"cjgndpd610010j1jxsrrl9a9i","category_id":"cjgndpd7c003sj1jxl640yknq","_id":"cjgndpd7i0041j1jxaikq39yt"},{"post_id":"cjgndpd630014j1jx45zcdhpz","category_id":"cjgndpd6r002cj1jxv6kbfrs2","_id":"cjgndpd7j0044j1jxdnho6459"},{"post_id":"cjgndpd630014j1jx45zcdhpz","category_id":"cjgndpd7e003wj1jx4pqe1sth","_id":"cjgndpd7k0048j1jx6nua5ric"},{"post_id":"cjgndpd650017j1jxfgr208qz","category_id":"cjgndpd710034j1jxqkhw1edt","_id":"cjgndpd7l004bj1jx0y5kgtev"},{"post_id":"cjgndpd650017j1jxfgr208qz","category_id":"cjgndpd7g003zj1jx8v2ylg34","_id":"cjgndpd7m004dj1jxt6cz8yrb"},{"post_id":"cjgndpd67001aj1jxhb2ejdfi","category_id":"cjgndpd6r002cj1jxv6kbfrs2","_id":"cjgndpd7n004fj1jx58v4lyxz"},{"post_id":"cjgndpd67001aj1jxhb2ejdfi","category_id":"cjgndpd7e003wj1jx4pqe1sth","_id":"cjgndpd7n004hj1jxrccm9ojd"},{"post_id":"cjgndpd68001bj1jx6nx1e0wq","category_id":"cjgndpd710034j1jxqkhw1edt","_id":"cjgndpd7o004ij1jx71opwmhv"},{"post_id":"cjgndpd68001bj1jx6nx1e0wq","category_id":"cjgndpd7g003zj1jx8v2ylg34","_id":"cjgndpd7o004lj1jxaeecn4y6"},{"post_id":"cjgndpd6a001fj1jxiw1acfv8","category_id":"cjgndpd75003cj1jxyu3n9gyt","_id":"cjgndpd7p004nj1jx6v6nou2g"},{"post_id":"cjgndpd6a001fj1jxiw1acfv8","category_id":"cjgndpd7n004ej1jxui3z6a3b","_id":"cjgndpd7p004rj1jxkkt4kicl"},{"post_id":"cjgndpd6d001nj1jxkeo54b5z","category_id":"cjgndpd78003ij1jxxeh2gss3","_id":"cjgndpd7q004uj1jxx0m9apyg"},{"post_id":"cjgndpd6d001nj1jxkeo54b5z","category_id":"cjgndpd7o004jj1jx131pxmuw","_id":"cjgndpd7q004wj1jxtdhr5zu7"},{"post_id":"cjgndpd6f001qj1jxsmvguqlk","category_id":"cjgndpd75003cj1jxyu3n9gyt","_id":"cjgndpd7r004yj1jx7o6btjne"},{"post_id":"cjgndpd6f001qj1jxsmvguqlk","category_id":"cjgndpd7p004pj1jx86o946nd","_id":"cjgndpd7s0050j1jxwe8qsvls"},{"post_id":"cjgndpd810058j1jxsfagdyan","category_id":"cjgndpd7a003pj1jxbhvvobnx","_id":"cjgndpd84005aj1jxc8t0k2no"}],"PostTag":[{"post_id":"cjgndpd550000j1jxaqi6uods","tag_id":"cjgndpd5e0004j1jxpx9nwlgt","_id":"cjgndpd5k000aj1jxo53zyy8z"},{"post_id":"cjgndpd5a0002j1jxm51im9lb","tag_id":"cjgndpd5i0009j1jxff2zdfl8","_id":"cjgndpd5t000kj1jxavm9nllf"},{"post_id":"cjgndpd5a0002j1jxm51im9lb","tag_id":"cjgndpd5o000ej1jx8krjrpz2","_id":"cjgndpd5u000nj1jxx00dufzi"},{"post_id":"cjgndpd5e0005j1jxwyogtosg","tag_id":"cjgndpd5s000ij1jxnzfk5egk","_id":"cjgndpd5w000qj1jx4nv2716z"},{"post_id":"cjgndpd5g0006j1jxbvhw18n8","tag_id":"cjgndpd5s000ij1jxnzfk5egk","_id":"cjgndpd630013j1jxi55bk4rn"},{"post_id":"cjgndpd5g0006j1jxbvhw18n8","tag_id":"cjgndpd5y000uj1jx6ygrrsgi","_id":"cjgndpd650016j1jxdju6ytei"},{"post_id":"cjgndpd5h0007j1jxjn2mzt4d","tag_id":"cjgndpd620011j1jxgwsn412w","_id":"cjgndpd6b001hj1jx0ntb36mc"},{"post_id":"cjgndpd5h0007j1jxjn2mzt4d","tag_id":"cjgndpd670019j1jx7d03fod0","_id":"cjgndpd6c001kj1jxjmvdsvgr"},{"post_id":"cjgndpd5l000bj1jxoek3fwgd","tag_id":"cjgndpd6a001ej1jxxfqdo2zy","_id":"cjgndpd6f001pj1jxn70a4w1p"},{"post_id":"cjgndpd5n000cj1jx31txzd10","tag_id":"cjgndpd6d001mj1jxnynqrgly","_id":"cjgndpd6n0020j1jx2c2pt08b"},{"post_id":"cjgndpd5n000cj1jx31txzd10","tag_id":"cjgndpd5s000ij1jxnzfk5egk","_id":"cjgndpd6o0023j1jx29x42xdl"},{"post_id":"cjgndpd5p000fj1jxyqyjlm8z","tag_id":"cjgndpd6m001yj1jxjsa92xvf","_id":"cjgndpd6p0026j1jxu9ni362j"},{"post_id":"cjgndpd5q000gj1jxcj9qjmz2","tag_id":"cjgndpd6o0024j1jx4bcguqkt","_id":"cjgndpd6q002bj1jxhbnn9mru"},{"post_id":"cjgndpd5s000jj1jxvh981tm6","tag_id":"cjgndpd6q0029j1jxlc9zek48","_id":"cjgndpd6s002gj1jxumwctx0c"},{"post_id":"cjgndpd5t000lj1jxfiitwb80","tag_id":"cjgndpd6a001ej1jxxfqdo2zy","_id":"cjgndpd6t002lj1jx4wfagvor"},{"post_id":"cjgndpd5v000pj1jxcyk0b9j9","tag_id":"cjgndpd6t002jj1jx3a12smy0","_id":"cjgndpd6w002pj1jx66n0cllo"},{"post_id":"cjgndpd5w000rj1jxbpdxtge7","tag_id":"cjgndpd6v002oj1jxt2bj1ypn","_id":"cjgndpd6y002uj1jxcnxghmiy"},{"post_id":"cjgndpd5y000vj1jxk0jacm2w","tag_id":"cjgndpd6a001ej1jxxfqdo2zy","_id":"cjgndpd6z002zj1jx9yev15jb"},{"post_id":"cjgndpd5z000xj1jxyd7zq5wl","tag_id":"cjgndpd6z002xj1jxnsng9414","_id":"cjgndpd710033j1jxyt0g33b0"},{"post_id":"cjgndpd610010j1jxsrrl9a9i","tag_id":"cjgndpd700032j1jxx22w5xh4","_id":"cjgndpd730038j1jxw9dc87j0"},{"post_id":"cjgndpd610010j1jxsrrl9a9i","tag_id":"cjgndpd710035j1jx97prq8dc","_id":"cjgndpd74003aj1jxu1q61wbs"},{"post_id":"cjgndpd630014j1jx45zcdhpz","tag_id":"cjgndpd720037j1jxn3zy4awy","_id":"cjgndpd76003ej1jxnvzv6czr"},{"post_id":"cjgndpd630014j1jx45zcdhpz","tag_id":"cjgndpd6t002jj1jx3a12smy0","_id":"cjgndpd77003gj1jx8uxb4h6h"},{"post_id":"cjgndpd650017j1jxfgr208qz","tag_id":"cjgndpd76003dj1jxjjuy3o5m","_id":"cjgndpd78003kj1jxfqfsc61p"},{"post_id":"cjgndpd650017j1jxfgr208qz","tag_id":"cjgndpd77003hj1jxj1sh0v22","_id":"cjgndpd79003nj1jxsi2jcuo6"},{"post_id":"cjgndpd67001aj1jxhb2ejdfi","tag_id":"cjgndpd720037j1jxn3zy4awy","_id":"cjgndpd7c003rj1jxitsdlz2n"},{"post_id":"cjgndpd67001aj1jxhb2ejdfi","tag_id":"cjgndpd6t002jj1jx3a12smy0","_id":"cjgndpd7d003tj1jxq5349frf"},{"post_id":"cjgndpd68001bj1jx6nx1e0wq","tag_id":"cjgndpd76003dj1jxjjuy3o5m","_id":"cjgndpd7i0042j1jx29dl09iw"},{"post_id":"cjgndpd68001bj1jx6nx1e0wq","tag_id":"cjgndpd6m001yj1jxjsa92xvf","_id":"cjgndpd7j0043j1jxcp7issc8"},{"post_id":"cjgndpd68001bj1jx6nx1e0wq","tag_id":"cjgndpd77003hj1jxj1sh0v22","_id":"cjgndpd7k0047j1jx7awfkimu"},{"post_id":"cjgndpd6a001fj1jxiw1acfv8","tag_id":"cjgndpd7h0040j1jx5a05mkgi","_id":"cjgndpd7k0049j1jxchx5nddy"},{"post_id":"cjgndpd6b001ij1jxmj9ksqwj","tag_id":"cjgndpd7j0046j1jx0mnqb5rz","_id":"cjgndpd7o004mj1jxzcrgjjsn"},{"post_id":"cjgndpd6b001ij1jxmj9ksqwj","tag_id":"cjgndpd6m001yj1jxjsa92xvf","_id":"cjgndpd7p004oj1jxcr22fzf4"},{"post_id":"cjgndpd6b001ij1jxmj9ksqwj","tag_id":"cjgndpd7n004gj1jxh8bmllb8","_id":"cjgndpd7p004sj1jxgo1n38ub"},{"post_id":"cjgndpd6d001nj1jxkeo54b5z","tag_id":"cjgndpd7o004kj1jxlphvpza0","_id":"cjgndpd7q004tj1jxbkmy6o87"},{"post_id":"cjgndpd6f001qj1jxsmvguqlk","tag_id":"cjgndpd7p004qj1jxxib66vft","_id":"cjgndpd7q004xj1jxy90f8rfk"},{"post_id":"cjgndpd6j001tj1jxjcbxas3p","tag_id":"cjgndpd7q004vj1jxc7594rud","_id":"cjgndpd7t0053j1jxll65aeov"},{"post_id":"cjgndpd6j001tj1jxjcbxas3p","tag_id":"cjgndpd7r004zj1jxi5gybplw","_id":"cjgndpd7t0054j1jx5qgtyhh8"},{"post_id":"cjgndpd6j001tj1jxjcbxas3p","tag_id":"cjgndpd7s0051j1jx7xhwfejp","_id":"cjgndpd7t0055j1jx5bgot9hj"},{"post_id":"cjgndpd6j001tj1jxjcbxas3p","tag_id":"cjgndpd7s0052j1jxntfproa8","_id":"cjgndpd7t0056j1jxvuo2hd3s"},{"post_id":"cjgndpd810058j1jxsfagdyan","tag_id":"cjgndpd830059j1jxpv1v0uzj","_id":"cjgndpd84005dj1jx4zg153dq"},{"post_id":"cjgndpd810058j1jxsfagdyan","tag_id":"cjgndpd84005bj1jxxa4mlhde","_id":"cjgndpd84005ej1jx3q5llyve"},{"post_id":"cjgndpd810058j1jxsfagdyan","tag_id":"cjgndpd84005cj1jx4d6d4w4y","_id":"cjgndpd85005fj1jxzf21jbfm"}],"Tag":[{"name":"linux:conf","_id":"cjgndpd5e0004j1jxpx9nwlgt"},{"name":"linux:init","_id":"cjgndpd5i0009j1jxff2zdfl8"},{"name":"systemd","_id":"cjgndpd5o000ej1jx8krjrpz2"},{"name":"linux:disk","_id":"cjgndpd5s000ij1jxnzfk5egk"},{"name":"系统安全","_id":"cjgndpd5y000uj1jx6ygrrsgi"},{"name":"elasticsearch","_id":"cjgndpd620011j1jxgwsn412w"},{"name":"httpcomponents","_id":"cjgndpd670019j1jx7d03fod0"},{"name":"linux:shell","_id":"cjgndpd6a001ej1jxxfqdo2zy"},{"name":"linux:net","_id":"cjgndpd6d001mj1jxnynqrgly"},{"name":"cheat sheet","_id":"cjgndpd6m001yj1jxjsa92xvf"},{"name":"linux:process","_id":"cjgndpd6o0024j1jx4bcguqkt"},{"name":"linux:text","_id":"cjgndpd6q0029j1jxlc9zek48"},{"name":"python:module","_id":"cjgndpd6t002jj1jx3a12smy0"},{"name":"linux:varlog","_id":"cjgndpd6v002oj1jxt2bj1ypn"},{"name":"rsync","_id":"cjgndpd6z002xj1jxnsng9414"},{"name":"nginx","_id":"cjgndpd700032j1jxx22w5xh4"},{"name":"nginx:module","_id":"cjgndpd710035j1jx97prq8dc"},{"name":"python","_id":"cjgndpd720037j1jxn3zy4awy"},{"name":"jackson","_id":"cjgndpd76003dj1jxjjuy3o5m"},{"name":"json","_id":"cjgndpd77003hj1jxj1sh0v22"},{"name":"tools:git","_id":"cjgndpd7h0040j1jx5a05mkgi"},{"name":"saltstack","_id":"cjgndpd7j0046j1jx0mnqb5rz"},{"name":"运维自动化","_id":"cjgndpd7n004gj1jxh8bmllb8"},{"name":"证券:财富先锋","_id":"cjgndpd7o004kj1jxlphvpza0"},{"name":"mvn:plugins","_id":"cjgndpd7p004qj1jxxib66vft"},{"name":"http","_id":"cjgndpd7q004vj1jxc7594rud"},{"name":"tomcat","_id":"cjgndpd7r004zj1jxi5gybplw"},{"name":"spring","_id":"cjgndpd7s0051j1jx7xhwfejp"},{"name":"spring-mvc","_id":"cjgndpd7s0052j1jxntfproa8"},{"name":"ajax","_id":"cjgndpd830059j1jxpv1v0uzj"},{"name":"jQuery","_id":"cjgndpd84005bj1jxxa4mlhde"},{"name":"文件上传","_id":"cjgndpd84005cj1jx4d6d4w4y"}]}}